<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Montador de Deck - Simulador Mytragor</title>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <style>
  body { background: #000000; color: #e2e8f0; font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; margin: 0; min-height: 100vh; }
    .container {
      width: 100%;
      min-height: 100vh;
      margin: 0 auto;
      background: linear-gradient(180deg, rgba(14,20,38,0.6), rgba(6,10,20,0.6));
  padding: 24px 14px;
      display: flex;
      flex-direction: column;
      align-items: center;
      box-sizing: border-box;
      gap: 12px;
    }
    h1 { text-align: center; margin-bottom: 6px; color: #facc15; font-family: 'Cinzel', Georgia, serif; font-weight:800; letter-spacing:1px }
  .deck-builder-wrap { width:100%; max-width:1100px; display:flex; gap:14px; align-items:flex-start }
    .panel { background: linear-gradient(180deg, rgba(14,26,43,.9), rgba(8,14,26,.72)); border:1px solid rgba(250,204,21,0.06); border-radius:12px; padding:14px; box-shadow: 0 12px 30px rgba(2,6,23,0.7); }
    .left, .right { box-sizing:border-box }
  .left { flex: 1 1 auto; min-width: 0; }
  /* slightly increase panel width so 3 columns fit without clipping */
  .right { flex: 0 0 320px; width: 320px; }
  /* make the right deck-list visually match the card-pool: three responsive columns
     with card tiles that reuse the main .card look (scaled to fit) so the "veil"
     and background don't get visually clipped. */
  .right .deck-list { display:grid; grid-template-columns: repeat(3, minmax(88px, 1fr)); gap:8px; padding:8px; min-height: 360px; }
  .right .deck-list .card { /* preserve main .card aesthetics but scale to grid cell */
    background: linear-gradient(180deg, rgba(16,32,57,0.6), rgba(8,18,32,0.6));
    border-radius: 10px;
    padding: 8px;
      width: 100%;
    box-shadow: 0 8px 20px rgba(2,6,23,0.6);
  min-height: 120px;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    gap:6px;
    text-align:center;
  }
  /* make the cards shown in the chosen-deck list smaller to reduce visual weight */
  .right .deck-list .card img{ width:40px; height:60px; object-fit:cover; border-radius:4px; }
  .right .deck-list .card div{ font-size:11px; color: #e6eef8; }
  .deck-list { display: grid; grid-template-columns: repeat(4, 1fr); gap:8px; margin-bottom:8px; min-height: 120px; background: transparent; border-radius: 8px; padding: 8px; }
  .card-pool { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px,1fr)); gap:10px; margin-bottom: 8px; min-height: 40px; max-width: 100%; justify-items: start; align-items: start; }
  /* Filter bar */
  .filterBar { display:flex; gap:8px; align-items:center; margin:6px 0 12px 0; }
  .filterSearch { padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,0.04); background: rgba(0,0,0,0.24); color:#e6eef8; font-size:14px; width:320px; }
  .chip { padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.02); color:#cbd5e1; font-size:13px; cursor:pointer; border:1px solid rgba(255,255,255,0.02); }
  .chip.selected { background:linear-gradient(180deg,#facc15,#f59e0b); color:#111; border-color:rgba(250,200,60,0.12); }
  .filterBtn { padding:8px 10px; border-radius:8px; background:transparent; color:#e6eef8; border:1px solid rgba(255,255,255,0.02); cursor:pointer; }
  .filterPopover { position:absolute; background: linear-gradient(180deg, rgba(8,12,20,0.9), rgba(6,8,14,0.9)); border:1px solid rgba(36,52,70,0.3); box-shadow:0 10px 30px rgba(2,6,23,0.75); padding:12px; border-radius:8px; display:none; z-index:50; }
  .filterRow { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    .card {
      background: linear-gradient(180deg, rgba(16,32,57,0.6), rgba(8,18,32,0.6));
      border-radius: 10px;
      padding: 8px;
  width: 140px;
      text-align: center;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(2,6,23,0.6);
  min-height: 160px;
      transition: transform 0.12s ease, box-shadow 0.12s ease, border 0.12s ease;
      font-size: 13px;
      color: #e6eef8;
    }
  .card:hover{ transform: translateY(-6px) scale(1.02); box-shadow: 0 18px 40px rgba(2,6,23,0.8); }
  .card.selected { border: 2px solid rgba(250,200,60,0.12); box-shadow: 0 18px 36px rgba(250,200,60,0.08) }
    .card.empty {
      background: rgba(255,255,255,0.02);
      border: 1px dashed rgba(255,255,255,0.04);
      box-shadow: none;
      cursor: default;
      min-height: 120px;
      font-size: 12px;
      display:flex;align-items:center;justify-content:center;color:#9ca3af;
    }
    .card.disabled { opacity: 0.55; filter: grayscale(0.5); cursor: not-allowed; }

    /* simple modal styles used for leader selection */
    .modalOverlay { position: fixed; left: 0; top: 0; width: 100%; height: 100%; background: rgba(2,6,23,0.6); display: flex; align-items: center; justify-content: center; z-index: 9999; }
  .modalBox { background: #0b1220; color: #e2e8f0; padding: 18px; border-radius: 8px; max-width: 1000px; width: 96%; box-shadow: 0 8px 40px #0008; }
    .controls { display: flex; gap: 16px; justify-content: center; margin-bottom: 24px; }
  /* golden primary buttons across the page */
  button { background: linear-gradient(180deg,#facc15,#f59e0b); color: #111111; border: 1px solid rgba(250,200,60,0.12); border-radius: 8px; padding: 8px 14px; font-size: 15px; cursor: pointer; box-shadow: 0 8px 20px rgba(250,180,20,0.06); }
    button:disabled { background: #555; color: #aaa; cursor: not-allowed; }
  /* smaller filter-style buttons use the same gold palette but subtler */
  .filterBtn { background: linear-gradient(180deg,#facc15,#f59e0b); color:#111; border:1px solid rgba(250,200,60,0.08); }
    .deck-info { text-align: center; margin-bottom: 16px; }
  /* card preview tooltip */
  .card-preview { position: fixed; pointer-events: none; background: linear-gradient(180deg, #071025, #0b1220); border: 1px solid rgba(250,204,21,0.08); padding: 12px; border-radius:12px; width:440px; max-width:50vw; box-shadow: 0 18px 48px rgba(2,6,23,0.85); color:#e6eef8; z-index:20000; display:none; }
  /* larger hover/modal preview so card text is easier to read */
  .card-preview img { width:200px; height:300px; object-fit:cover; border-radius:6px; box-shadow:0 6px 20px rgba(0,0,0,0.6); }
  /* bigger preview variant used when hovering items in the right column */
  .card-preview.deck-large { width:360px; }
  .card-preview.deck-large img { width:280px; height:420px; }
  .card-preview .meta { margin-left:12px; max-height:260px; overflow:auto }
  /* floating small hint shown when leader selected (right side modal-like) */
  .floatingHint {
    position: fixed;
    right: 28px;
    top: 140px;
    background: rgba(11,18,28,0.95);
    border: 1px solid rgba(250,200,60,0.06);
    color: #cbd5e1;
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 12px;
    box-shadow: 0 12px 30px rgba(2,6,23,0.6);
    z-index: 20010;
    max-width: 220px;
    text-align: center;
  }
  .deckInfoFloating {
    position: fixed;
    right: 28px;
    top: 200px;
    background: rgba(6,10,18,0.96);
    border: 1px solid rgba(255,255,255,0.03);
    color: #e6eef8;
    padding: 6px 10px;
    border-radius: 8px;
    font-size: 12px;
    box-shadow: 0 10px 26px rgba(2,6,23,0.6);
    z-index: 20005;
    text-align: center;
    min-width: 140px;
  }
  /* subtle pulse to draw attention to play CTA */
  @keyframes softPulse { 0% { transform: translateY(0); box-shadow: 0 6px 18px rgba(250,180,20,0.06);} 50% { transform: translateY(-3px); box-shadow: 0 18px 40px rgba(250,170,20,0.12);} 100% { transform: translateY(0); box-shadow: 0 6px 18px rgba(250,180,20,0.06);} }
  .pulse { animation: softPulse 1600ms ease-in-out infinite; }
  </style>
  <script>
    (function(){
      try{
        const v = 'v=' + Date.now();
        function addQ(el, attr){
          const url = el.getAttribute(attr);
          if(!url) return;
          if(/^(https?:|data:|file:|\/\/)/i.test(url)) return;
          if(url.indexOf('?')>-1) el.setAttribute(attr, url + '&' + v); else el.setAttribute(attr, url + '?' + v);
        }
        document.querySelectorAll('link[rel=stylesheet], script[src], img').forEach(el=>{
          if(el.tagName==='LINK') addQ(el,'href'); else addQ(el,'src');
        });
      }catch(e){ console.warn('cache-bust failed', e); }
    })();
  </script>
</head>
<body>
  <button id="btnBackMenu" onclick="location.href='../../index.html'" title="Voltar ao menu" style="position:fixed;right:18px;top:18px;z-index:9999;padding:10px 14px;border-radius:10px;background:linear-gradient(180deg,#facc15,#f59e0b);color:#111;border:1px solid rgba(250,200,60,0.12);box-shadow:0 8px 20px rgba(250,180,20,0.06);font-weight:800;">Voltar ao menu</button>
  <div class="container">
    <div style="text-align:center;margin-bottom:6px;">
      <img src="logo.png" alt="Logo Mytragor" style="max-width:220px;width:36vw;filter:drop-shadow(0 6px 22px rgba(0,0,0,0.7));margin-bottom:8px;border-radius:8px;" onerror="this.style.display='none'">
    </div>
  <h1>Montador de Deck</h1>
  <div style="text-align:center;color:#cbd5e1;max-width:760px;margin:0 auto 6px;font-size:14px">Monte um deck competitivo em minutos — escolha um líder, preencha 40 cartas e clique em "Jogar" para testar seu deck imediatamente no simulador.</div>
  <!-- Botão de tutorial (abre modal) -->
  <div style="max-width:1100px;margin:0 auto 12px;text-align:center;">
    <button id="btnShowTutorial" style="padding:10px 14px;border-radius:8px;background:linear-gradient(180deg,#facc15,#f59e0b);color:#111;border:1px solid rgba(250,200,60,0.12);box-shadow:0 8px 20px rgba(250,180,20,0.06);font-weight:700;">Tutorial</button>
  </div>

  <!-- Modal do tutorial (inicialmente escondido) -->
  <div id="tutorialModal" class="modalOverlay" style="display:none;">
    <div class="modalBox" role="dialog" aria-labelledby="tutorialTitle">
      <h2 id="tutorialTitle" style="margin-top:0;color:#facc15">Tutorial rápido: Como montar um deck</h2>
      <div style="color:#e6eef8;line-height:1.5;">
        <ol style="margin:8px 0 0 18px;padding-left:16px;">
          <li><strong>Escolha um líder</strong> — o líder define a filiação do deck. O líder não conta nas 40 cartas do deck; selecione um líder antes de salvar ou jogar.</li>
          <li><strong>40 cartas por deck</strong> — monte exatamente 40 cartas. O botão "Salvar" e "Jogar" só ficam ativos quando houver 40 cartas e um líder definido.</li>
          <li><strong>Limite de cópias</strong> — máximo de 3 cópias da mesma carta por deck.</li>
          <li><strong>Regra de filiação</strong> — se o líder tiver filiação, somente cartas com a mesma filiação ou cartas "Neutra" são permitidas no deck.</li>
          <li><strong>Curva de custo</strong> — equilibre custos: muitos aliados de custo 1–3 dão consistência; inclua alguns custos médios/altos para jogadas tardias.</li>
          <li><strong>Fragmentos e equipamentos</strong> — escolha fragmentos e equipamentos que combinem com a estratégia do seu líder; eles reforçam sinergias importantes.</li>
          <li><strong>Testar e salvar</strong> — use "Jogar" para testar o deck no simulador; use "Salvar" para guardar o deck localmente (em "Meus decks").</li>
        </ol>
        <p style="color:#cbd5e1;font-size:13px;margin-top:8px;">Dica: use a barra de filtros e a busca para encontrar cartas rapidamente. Use "Limpar" para reiniciar seu deck enquanto monta.</p>
        <div style="text-align:right;margin-top:12px;"><button id="btnCloseTutorial">Fechar</button></div>
      </div>
    </div>
  </div>
    <div class="deck-builder-wrap">
      <div class="panel left">
        <div class="deck-info" style="margin-bottom:12px;display:flex;align-items:center;justify-content:space-between;gap:12px;">
          <div>
            <h3 style="margin:0 0 6px 0;color:#cbd5e1;font-size:14px">Escolha o líder</h3>
            <div id="leaderCards" style="display:flex;gap:8px;align-items:center;margin-top:6px;"></div>
          </div>
          <div style="text-align:right">
            <div id="deckSize" style="font-weight:700;color:#facc15">0/40 cartas</div>
            <div id="deckMeta" style="font-size:12px;color:#9ca3af">Fragmentos e líder visuais</div>
          </div>
        </div>
        <div class="deck-info" style="margin-bottom:12px;">
          <h3 style="margin:0 0 6px 0;color:#cbd5e1;font-size:14px">Escolha os Fragmentos (visual)</h3>
          <div id="fragChooser2" style="display:flex;gap:8px;align-items:center;margin-top:6px;"></div>
        </div>
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;gap:8px;">
          <h2 style="font-size:18px;margin:0;color:#e6eef8">Cartas disponíveis</h2>
          <div style="display:flex;align-items:center;gap:8px;">
            <div style="position:relative;">
              <button id="btnToggleFilters" class="filterBtn" title="Filtros" aria-expanded="false">Filtros ▾</button>
              <div id="filterPopover" class="filterPopover" style="right:0;top:36px;">
                <div class="filterRow">
                  <label style="font-size:13px;color:#cbd5e1;width:72px;">Filiação</label>
                  <div id="filiationChips" style="display:flex;gap:6px;flex-wrap:wrap;max-width:260px;"></div>
                </div>
                <div class="filterRow">
                  <label style="font-size:13px;color:#cbd5e1;width:72px;">Custo</label>
                  <div style="display:flex;gap:6px;flex-wrap:wrap;">
                    <button class="chip" data-cost="0">0</button>
                    <button class="chip" data-cost="1">1</button>
                    <button class="chip" data-cost="2">2</button>
                    <button class="chip" data-cost="3">3</button>
                    <button class="chip" data-cost="4">4</button>
                    <button class="chip" data-cost="5">5+</button>
                  </div>
                </div>
                
                <div style="text-align:right;margin-top:8px;display:flex;gap:8px;justify-content:flex-end;">
                  <button id="btnClearFilters" class="filterBtn" style="background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px 10px;">Limpar filtros</button>
                </div>
              </div>
            </div>
            <div id="filterSummary" style="font-size:13px;color:#cbd5e1;min-width:180px;text-align:right"></div>
          </div>
        </div>
        <div class="filterBar" style="margin-bottom:12px;">
          <input id="filterSearch" class="filterSearch" placeholder="Buscar carta..." />
          <div id="kindChips" style="display:flex;gap:6px;">
            <div class="chip" data-kind="ally">Ally</div>
            <div class="chip" data-kind="spell">Spell</div>
            <div class="chip" data-kind="equip">Equip</div>
            <div class="chip" data-kind="env">Amb</div>
            <div class="chip" data-kind="truque">Truque</div>
          </div>
        </div>
        <div class="card-pool" id="cardPool"></div>
      </div>
      <div class="panel right">
  <div style="margin-bottom:8px;text-align:left;display:flex;align-items:center;justify-content:space-between;gap:12px"><h2 style="font-size:18px;margin:0;color:#e6eef8">Seu deck</h2><div style="display:flex;gap:8px;align-items:center"><input id="deckNameInput" type="text" placeholder="Nome do deck (opcional)" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:#e6eef8;width:140px;" /><button id="btnSalvar" class="mp-btn primary" disabled>Salvar</button><button id="btnPlay" title="Testar este deck agora" style="margin-left:6px;" class="pulse">Jogar</button></div></div>
        <div class="deck-list" id="deckList"></div>
        <!-- Importar deck via código -->
        <div style="margin-top:12px;padding:8px;border-top:1px solid rgba(255,255,255,0.04);">
          <input id="importCodeInput" type="text" placeholder="Colar código do deck aqui..." style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:#e6eef8;margin-bottom:6px;" />
          <button id="btnImportDeck" style="width:100%;margin-bottom:8px;">Importar deck</button>
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end;"><button id="btnLimpar" class="mp-btn">Limpar</button><button id="btnVerDecks" class="mp-btn">Ver decks</button></div>
      </div>
    </div>
  </div>
  <script src="../cards/cartas.js?v=2"></script>
  <script>
    // Usa o array central de cartas do cartas.js
    const CARD_POOL = (window.CARD_DEFS || []).filter(card => ['ally','spell','equip','env','truque'].includes(card.kind));
    console.log('Deckbuilder: CARD_POOL count=', CARD_POOL.length, 'contains Sede de Vingança?', !!CARD_POOL.find(c=>c.name && c.name.includes('Sede')));

    let deck = [];
  const deckList = document.getElementById('deckList');
  const cardPool = document.getElementById('cardPool');
  const deckSize = document.getElementById('deckSize');
  const btnSalvar = document.getElementById('btnSalvar');
  const btnPlay = document.getElementById('btnPlay');
  const btnLimpar = document.getElementById('btnLimpar');
  const btnVerDecks = document.getElementById('btnVerDecks');
  const deckNameInput = document.getElementById('deckNameInput');
  const leaderCards = document.getElementById('leaderCards');
  const fragChooser = document.getElementById('fragChooser');
  const fragChooser2 = document.getElementById('fragChooser2');
  let chosenLeader = null;
  let chosenFragImg = null;
  // Create floating deck info element and hide original small inline info
  (function(){
    try{
      const existing = document.getElementById('deckInfoFloating');
      if(!existing){
        const box = document.createElement('div');
        box.id = 'deckInfoFloating';
        box.className = 'deckInfoFloating';
        box.style.display = 'none';
        document.body.appendChild(box);
      }
      // hide original inline elements to avoid duplication
      if (deckSize) deckSize.style.display = 'none';
      const dm = document.getElementById('deckMeta'); if(dm) dm.style.display = 'none';
    }catch(e){ console.warn('init floating deck info failed', e); }
  })();

  const FRAG_OPTIONS = [
    { label: 'Arcano',   img: '../fragments/fragmentos_arcano.png' },
    { label: 'Marcial',  img: '../fragments/fragmentos_marcial.png' },
    { label: 'Religioso',img: '../fragments/fragmentos_religioso.png' },
    { label: 'Sombras',  img: '../fragments/fragmentos_sombras.png' }
  ];

    // Prefer leader definitions from the central `CARD_DEFS` (cartas.js).
    // Fallback to the small local list if CARD_DEFS isn't loaded.
    let LEADERS = [];
    if (window && Array.isArray(window.CARD_DEFS) && window.CARD_DEFS.length) {
      LEADERS = window.CARD_DEFS.filter(c => c.kind === 'leader').map(c => c);
    } else {
      LEADERS = [
        { name: 'Valbrak', img: '../chosens/valbrak.png' },
        { name: 'Katsu', img: '../chosens/katsu.png' },
        { name: 'Leafae', img: '../chosens/leafae.png' },
        { name: 'Ademais', img: '../chosens/ademais.png' }
      ];
    }

    // Build mapping from leader name -> filiation from the leader objects
    const LEADER_FILIACAO = {};
    LEADERS.forEach(l => { if(l && l.name) LEADER_FILIACAO[l.name] = l.filiacao || (l.filiation||''); });

    function getLeaderForFiliation(filiacao){
      if(!filiacao) return null;
      filiacao = String(filiacao).toLowerCase();
      for(const k of Object.keys(LEADER_FILIACAO)){
        if(String(LEADER_FILIACAO[k] || '').toLowerCase() === filiacao) return LEADERS.find(l=>l.name===k) || null;
      }
      return null;
    }

    // Returns whether a card is allowed in the deck given the current chosenLeader.
    function isCardAllowed(card) {
      if (!chosenLeader) return true; // nothing blocks when no leader fixed
      const leaderF = LEADER_FILIACAO[chosenLeader.name] || null;
      if (!leaderF) return true;
      const cardF = String(card.filiacao||'').toLowerCase();
      return cardF === 'neutra' || cardF === String(leaderF).toLowerCase();
    }

    // Resolve imagens robustamente para páginas dentro e fora de assets/ui — retorna URL absoluto
    function resolveImg(path) {
      if (!path) return 'card-back.png';
      try {
        // Keep absolute/data URLs
        if (/^(https?:|data:|file:)/i.test(path)) return path;
        path = String(path).replace(/\\/g, '/').replace(/^\.\//, '').replace(/^\.\.\//, '');
        // If path already references assets/, build from project root so we don't get assets/assets
        if (path.startsWith('assets/')) {
          const href = window.location && window.location.href || '';
          const marker = '/assets/ui/';
          const idx = href.indexOf(marker);
          if (idx >= 0) {
            // root ends right before /assets/ui/
            const root = href.slice(0, idx + 1); // keep trailing '/'
            return new URL(path, root).href;
          }
          // not under assets/ui -> resolve relative to current location
          return new URL(path, window.location.href).href;
        }
        // fallback: keep previous behavior for other relative paths
        const candidate = (window.location && window.location.pathname || '').includes('/assets/ui/') ? '../' + path : path;
        return new URL(candidate, window.location.href).href;
      } catch (e) { return path; }
    }

    // --- FILTERS: minimal, compact filter state and helpers ---
    const filterState = {
      query: '',
      kinds: new Set(), // empty => all
      filiation: null,
      cost: null, // null or number (5 means 5+)
      keywords: new Set()
    };

    function normalizeText(s) { return String(s||'').toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,''); }

    function applyFilters(pool) {
      const q = normalizeText(filterState.query || '');
      return pool.filter(card => {
        // NOTE: leader enforcement moved to render layer so we can visually disable cards
        if (filterState.kinds.size && !filterState.kinds.has((card.kind||'').toLowerCase())) return false;
  if (filterState.filiation && String(card.filiacao||'').toLowerCase() !== String(filterState.filiation).toLowerCase()) return false;
        if (filterState.cost != null) {
          const c = Number(card.cost || 0);
          if (filterState.cost === 5) { if (c < 5) return false; } else if (c !== filterState.cost) return false;
        }
        if (filterState.keywords.size) {
          const kws = (card.keywords||[]).map(k=>String(k).toLowerCase());
          for (let kw of filterState.keywords) if (!kws.includes(String(kw).toLowerCase())) return false;
        }
        if (q) {
          const hay = normalizeText((card.name||'') + ' ' + (card.text||'') + ' ' + (card.tipo||'') + ' ' + (card.filiacao||''));
          if (!hay.includes(q)) return false;
        }
        
        return true;
      });
    }

    // wire up filter UI (called once on load)
    function setupFilters() {
      const search = document.getElementById('filterSearch');
      const kindChips = document.getElementById('kindChips');
      const pop = document.getElementById('filterPopover');
      const btn = document.getElementById('btnToggleFilters');
      const filiationChips = document.getElementById('filiationChips');
      const filterSummary = document.getElementById('filterSummary');
  const costButtons = pop.querySelectorAll('button[data-cost]');

      // populate filiação chips with values found in CARD_POOL
      const filias = Array.from(new Set(CARD_POOL.map(c => (c.filiacao||'').toString()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));
      try{
        if(filiationChips){
          filiationChips.innerHTML = '';
          const allChip = document.createElement('div'); allChip.className='chip'; allChip.textContent='(todas)'; allChip.dataset.filiacao='';
          allChip.addEventListener('click', ()=>{
            filterState.filiation = null; Array.from(filiationChips.querySelectorAll('.chip')).forEach(c=>c.classList.remove('selected')); allChip.classList.add('selected'); renderPool(); updateFilterSummary();
          });
          filiationChips.appendChild(allChip);
          filias.forEach(f => {
            const ch = document.createElement('div'); ch.className='chip'; ch.textContent = f; ch.dataset.filiacao = f; ch.style.padding='6px 8px';
            ch.addEventListener('click', ()=>{
              if(filterState.filiation === f) { filterState.filiation = null; ch.classList.remove('selected'); }
              else { filterState.filiation = f; Array.from(filiationChips.querySelectorAll('.chip')).forEach(c=>c.classList.remove('selected')); ch.classList.add('selected'); }
              renderPool(); updateFilterSummary();
            });
            filiationChips.appendChild(ch);
          });
          allChip.classList.add('selected');
        }
      }catch(e){ console.warn('populate filiation chips failed', e); }

      // search debounce + Enter handling
      let t = null;
      if (search) {
        search.addEventListener('input', (e) => {
          clearTimeout(t);
          t = setTimeout(() => { filterState.query = e.target.value || ''; renderPool(); updateFilterSummary(); }, 180);
        });
        search.addEventListener('keydown', (e) => { if(e.key === 'Enter'){ filterState.query = search.value || ''; renderPool(); updateFilterSummary(); } });
      }

      // kind chips toggles
      kindChips.querySelectorAll('.chip').forEach(ch => {
        ch.addEventListener('click', () => {
          const k = ch.dataset.kind && ch.dataset.kind.toLowerCase();
          if (!k) return;
          if (filterState.kinds.has(k)) { filterState.kinds.delete(k); ch.classList.remove('selected'); }
          else { filterState.kinds.add(k); ch.classList.add('selected'); }
          renderPool(); updateFilterSummary();
        });
      });

      btn.addEventListener('click', (ev) => { ev.stopPropagation(); pop.style.display = pop.style.display === 'block' ? 'none' : 'block'; btn.setAttribute('aria-expanded', pop.style.display === 'block'); });
      document.addEventListener('click', (ev) => { if (!pop.contains(ev.target) && ev.target !== btn) pop.style.display = 'none'; });

      // clear filters button
      const btnClear = document.getElementById('btnClearFilters');
      if(btnClear) btnClear.addEventListener('click', ()=>{
        filterState.query = '';
        filterState.kinds = new Set();
        filterState.filiation = null;
        filterState.cost = null;
        // clear UI markers
        if(document.getElementById('filterSearch')) document.getElementById('filterSearch').value = '';
        document.querySelectorAll('#filiationChips .chip').forEach(c=>c.classList.remove('selected'));
        const allChip = document.querySelector('#filiationChips .chip'); if(allChip) allChip.classList.add('selected');
        document.querySelectorAll('#kindChips .chip').forEach(c=>c.classList.remove('selected'));
        document.querySelectorAll('[data-cost]').forEach(c=>c.classList.remove('selected'));
        renderPool(); updateFilterSummary();
      });

      costButtons.forEach(b => {
        b.addEventListener('click', () => {
          const v = Number(b.dataset.cost);
          if (filterState.cost === v) { filterState.cost = null; b.classList.remove('selected'); }
          else { filterState.cost = v; costButtons.forEach(x=>x.classList.remove('selected')); b.classList.add('selected'); }
          renderPool(); updateFilterSummary();
        });
      });
  // NOTE: "Só disponíveis" filter removed as it was not useful; no listener required.

      // update summary helper
      function updateFilterSummary(){
        if(!filterSummary) return;
        const parts = [];
        if(filterState.filiation) parts.push(filterState.filiation);
        if(filterState.cost != null) parts.push('Custo: ' + (filterState.cost===5? '5+': filterState.cost));
  if(filterState.query) parts.push('Busca');
        filterSummary.textContent = parts.length ? parts.join(' • ') : 'Nenhum filtro ativo';
      }
      // initialize summary
      try{ updateFilterSummary(); }catch(e){}
    }

      // --- Card preview (hover) ---
      const cardPreview = (function(){
        const d = document.createElement('div'); d.className = 'card-preview'; d.style.display = 'none'; document.body.appendChild(d); return d;
      })();

      function showPreviewCard(card, x, y){
        if(!card) return hidePreviewCard();
        const img = resolveImg(card.img);
        const name = card.name || '';
        const fil = card.filiacao || '';
        const cost = (typeof card.cost !== 'undefined') ? String(card.cost) : '';
        const text = String(card.text || card.description || card.tipo || '').replace(/\n/g,'<br>');
        cardPreview.innerHTML = `<div style="display:flex;align-items:flex-start;"><img src="${img}" alt="${name}"><div class="meta"><div style="font-weight:800;color:#facc15;margin-bottom:6px">${name}</div><div style="color:#9ca3af;font-size:13px;margin-bottom:8px">${fil} ${cost ? '• Custo ' + cost : ''}</div><div style="font-size:13px;color:#e6eef8;line-height:1.3">${text}</div></div></div>`;
        cardPreview.style.display = 'block';
        positionPreview(x,y);
      }

      function positionPreview(x,y){
        const pad = 12;
        const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
  const w = Math.min(440, vw * 0.45);
        const h = cardPreview.offsetHeight || 220;
        let left = x + 18;
        let top = y + 18;
        if(left + w + pad > vw) left = Math.max(pad, x - w - 18);
        if(top + h + pad > vh) top = Math.max(pad, y - h - 18);
        cardPreview.style.left = left + 'px'; cardPreview.style.top = top + 'px';
      }

      function hidePreviewCard(){ cardPreview.style.display = 'none'; cardPreview.classList.remove('deck-large'); }

      function attachPreviewHandlers(el, card){
        if(!el || !card) return;
        let moved = false;
        // determine if this element is part of the right-hand deck list (larger preview)
        const wantsLarge = el.dataset && el.dataset.preview === 'large' || !!el.closest && !!el.closest('#deckList');
        const onEnter = (ev)=>{ moved=false; if(wantsLarge) cardPreview.classList.add('deck-large'); else cardPreview.classList.remove('deck-large'); showPreviewCard(card, ev.clientX, ev.clientY); };
        const onMove = (ev)=>{ moved=true; positionPreview(ev.clientX, ev.clientY); };
        const onLeave = ()=>{ hidePreviewCard(); };
        el.addEventListener('mouseenter', onEnter);
        el.addEventListener('mousemove', onMove);
        el.addEventListener('mouseleave', onLeave);
        // touch fallback: show on touchstart briefly
        el.addEventListener('touchstart', (e)=>{ const t = e.touches && e.touches[0]; if(t){ if(wantsLarge) cardPreview.classList.add('deck-large'); else cardPreview.classList.remove('deck-large'); showPreviewCard(card, t.clientX, t.clientY); } setTimeout(hidePreviewCard, 2500); }, {passive:true});
      }

    function renderLeaders() {
      leaderCards.innerHTML = '';
      LEADERS.forEach(leader => {
        const el = document.createElement('div');
        el.className = 'card' + (chosenLeader && chosenLeader.name === leader.name ? ' selected' : '');
        const im = document.createElement('img');
        im.src = resolveImg(leader.img);
        im.alt = leader.name;
          im.style = 'width:72px;height:108px;object-fit:cover;display:block;margin:0 auto 2px auto;border-radius:4px;box-shadow:0 1px 4px #0007;';
        im.onerror = function() { this.src = 'card-back.png'; };
        el.appendChild(im);
        const nm = document.createElement('div');
          nm.textContent = leader.name;
          nm.style = 'font-size:8px;margin-top:2px;font-weight:bold;';
        el.appendChild(nm);
        el.onclick = () => {
          chosenLeader = leader;
          renderLeaders();
          renderDeck();
        };
        try{ attachPreviewHandlers(el, leader); }catch(e){}
        leaderCards.appendChild(el);
      });
      // If a leader is selected, offer a small control to clear/change it
      if (chosenLeader) {
        const clr = document.createElement('div');
        clr.className = 'card';
        clr.style = 'display:flex;flex-direction:column;align-items:center;justify-content:center;';
        clr.innerHTML = '<div style="font-size:10px;font-weight:bold;color:#f8fafc;">Mudar líder</div><div style="font-size:10px;color:#cbd5e1;margin-top:6px;">(limpar)</div>';
        clr.onclick = () => {
          if (confirm('Deseja remover a seleção de líder e permitir qualquer filiação? Isso não removerá as cartas já adicionadas.')) {
            chosenLeader = null;
            renderLeaders(); renderDeck(); renderPool();
          }
        };
        leaderCards.appendChild(clr);
      }
    }

    function renderFragChooser() {
      function mountInto(target) {
        if (!target) return;
        target.innerHTML = '';
        FRAG_OPTIONS.forEach(opt => {
          const el = document.createElement('div');
          el.className = 'card' + (chosenFragImg === opt.img ? ' selected' : '');
          const im = document.createElement('img');
          im.src = resolveImg(opt.img);
          im.alt = opt.label; im.style = 'width:72px;height:108px;object-fit:cover;display:block;margin:0 auto 2px auto;border-radius:4px;box-shadow:0 1px 4px #0007;';
          im.onerror = function(){ this.src = 'card-back.png'; };
          el.appendChild(im);
          const nm = document.createElement('div'); nm.textContent = opt.label; nm.style = 'font-size:8px;margin-top:2px;';
          el.appendChild(nm);
          el.onclick = () => { chosenFragImg = opt.img; renderFragChooser(); };
          try{ attachPreviewHandlers(el, { name: opt.label, img: opt.img, text: '' }); }catch(e){}
          target.appendChild(el);
        });
      }
      mountInto(fragChooser); mountInto(fragChooser2);
    }

    function renderPool() {
      cardPool.innerHTML = '';
      const filtered = applyFilters(CARD_POOL);
      // If chosenLeader is set, show a small floating hint on the right side instead of in the pool
      (function(){
        const existing = document.getElementById('deckHintFloating');
        if (chosenLeader) {
          const txt = `Deck restrito a: ${LEADER_FILIACAO[chosenLeader.name] || '?'} + Neutra`;
          if (existing) {
            existing.textContent = txt;
            existing.style.display = 'block';
          } else {
            const el = document.createElement('div');
            el.id = 'deckHintFloating';
            el.className = 'floatingHint';
            el.textContent = txt;
            document.body.appendChild(el);
          }
        } else {
          if (existing) existing.style.display = 'none';
        }
      })();
      if (!filtered.length) {
        cardPool.innerHTML = '<div style="color:#9ca3af;padding:8px;font-size:13px;">Nenhuma carta encontrada. Ajuste os filtros ou limpe a busca.</div>';
        return;
      }
      // Sort by filiação (filiacao) first, then by card name (both alphabetical)
      filtered.sort((a, b) => {
        const fa = String(a.filiacao || '').toLowerCase();
        const fb = String(b.filiacao || '').toLowerCase();
        if (fa !== fb) return fa.localeCompare(fb, 'pt');
        return String(a.name || '').toLowerCase().localeCompare(String(b.name || '').toLowerCase(), 'pt');
      });
      filtered.forEach(card => {
        const el = document.createElement('div');
        // determine allowed status and render accordingly
        const allowed = isCardAllowed(card);
        el.className = 'card' + (allowed ? '' : ' disabled');
        const im = document.createElement('img');
        im.src = resolveImg(card.img);
        im.alt = card.name;
          im.style = 'width:120px;height:180px;object-fit:cover;display:block;margin:0 auto 2px auto;border-radius:4px;box-shadow:0 1px 4px #0007;';
        im.onerror = function() { this.src = 'card-back.png'; };
        el.appendChild(im);
        const nm = document.createElement('div');
          nm.textContent = card.name;
          nm.style = 'font-size:8px;margin-top:2px;';
        el.appendChild(nm);
        if (allowed) {
          el.onclick = () => addToDeck(card);
        } else {
          // visually disabled — explain why when clicked
          el.onclick = () => {
            if (chosenLeader) {
              const lf = LEADER_FILIACAO[chosenLeader.name] || '?';
              alert(`Este deck está fixado para a filiação ${lf}. Só são permitidas cartas ${lf} ou Neutras.`);
            }
          };
        }
        // attach hover preview
        try{ attachPreviewHandlers(el, card); }catch(e){}
        cardPool.appendChild(el);
      });
    }

    function renderDeck() {
      deckList.innerHTML = '';
      // Deck em ordem alfabética
      const sortedDeck = [...deck].sort((a, b) => a.name.localeCompare(b.name));
      // 40 espaços fixos
      for (let i = 0; i < 40; i++) {
        if (sortedDeck[i]) {
          const card = sortedDeck[i];
          const tile = document.createElement('div');
          tile.className = 'card selected';
          const im = document.createElement('img');
          im.src = resolveImg(card.img);
          im.alt = card.name;
          im.style = 'width:40px;height:60px;object-fit:cover;display:block;margin:0 auto 2px auto;border-radius:4px;box-shadow:0 1px 4px #0007;';
          im.onerror = function() { this.src = 'card-back.png'; };
          tile.appendChild(im);
          const nm = document.createElement('div');
          nm.textContent = card.name;
          nm.style = 'font-size:8px;margin-top:2px;';
          tile.appendChild(nm);
          tile.onclick = () => removeFromDeck(deck.indexOf(card));
          try{ attachPreviewHandlers(tile, card); }catch(e){}
          deckList.appendChild(tile);
        } else {
          const el = document.createElement('div');
          el.className = 'card empty';
          el.innerHTML = '<span style="color:#555;font-size:8px;">Vazio</span>';
          deckList.appendChild(el);
        }
      }
      deckSize.textContent = `${deck.length}/40 cartas${chosenLeader ? ' + 1 líder' : ''}`;
  btnSalvar.disabled = !(chosenLeader && deck.length === 40);
  if (btnPlay) btnPlay.disabled = !(chosenLeader && deck.length === 40);
      // update floating deck info (small modal on right)
      try{
        const f = document.getElementById('deckInfoFloating');
        if(f){
          f.style.display = 'block';
          const leaderText = chosenLeader ? (`• Líder: ${chosenLeader.name}`) : '';
          f.innerHTML = `<div style="font-weight:800;color:#facc15;margin-bottom:4px">${deck.length}/40 cartas</div><div style="font-size:11px;color:#9ca3af">Fragmentos e líder visuais ${leaderText}</div>`;
        }
      }catch(e){console.warn('update floating deck info failed', e);}
    }

    function openLeaderPickModal(requestedCard) {
      const overlay = document.createElement('div');
      overlay.className = 'modalOverlay';
      const box = document.createElement('div');
      box.className = 'modalBox';
      box.innerHTML = `<h3 style="margin-top:0">Escolha o líder para este deck</h3>
        <p>Para adicionar <strong>${requestedCard.name}</strong> é preciso escolher um líder com a mesma filiação ou cancelar.</p>
        <div id="leaderPickRow" style="display:flex;gap:8px;margin-top:12px;flex-wrap:wrap;"></div>
        <div style="text-align:right;margin-top:12px;"><button id="lpCancel">Cancelar</button></div>`;
      overlay.appendChild(box);
      document.body.appendChild(overlay);
      const row = box.querySelector('#leaderPickRow');
      LEADERS.forEach(leader => {
        const tile = document.createElement('div');
        tile.className = 'card';
        tile.style = 'display:flex;flex-direction:column;align-items:center;justify-content:center;';
  const im = document.createElement('img'); im.src = resolveImg(leader.img); im.style='width:160px;height:240px;object-fit:cover;border-radius:4px;'; im.onerror=function(){this.src='card-back.png';};
        tile.appendChild(im);
        const nm = document.createElement('div'); nm.textContent = leader.name; nm.style='font-size:10px;margin-top:6px;';
        tile.appendChild(nm);
        tile.onclick = () => {
          chosenLeader = leader;
          // add requested card now that leader is chosen
          deck.push(requestedCard);
          renderLeaders(); renderDeck(); renderPool();
          document.body.removeChild(overlay);
          try { alert(`Líder definido como ${chosenLeader.name} para corresponder à filiação ${requestedCard.filiacao}.`); } catch(e){}
        };
        row.appendChild(tile);
      });
      box.querySelector('#lpCancel').onclick = () => { document.body.removeChild(overlay); };
    }

    function addToDeck(card) {
      if (deck.length >= 40) return;
      // Limite de 3 cópias por carta
      const count = deck.filter(c => c.name === card.name).length;
      if (count >= 3) return;
      // Enforce filiation rule: if chosenLeader exists, card must be Neutra or same filiation
      if (chosenLeader) {
        const leaderF = LEADER_FILIACAO[chosenLeader.name] || null;
        const cardF = String(card.filiacao||'').toLowerCase();
        if (leaderF && cardF !== 'neutra' && cardF !== String(leaderF).toLowerCase()) {
          alert(`Este deck foi fixado para a filiação ${leaderF}. Só são permitidas cartas ${leaderF} ou Neutras.`);
          return;
        }
      } else {
        // no leader chosen: if card is non-Neutral, require the user to pick a leader first
        const cf = String(card.filiacao||'').toLowerCase();
        if (cf !== 'neutra') {
          // open a modal forcing leader selection; when leader picked the requested card will be added
          openLeaderPickModal(card);
          return;
        }
      }
      deck.push(card);
      renderDeck(); renderPool();
    }

    function removeFromDeck(idx) {
      deck.splice(idx, 1);
      renderDeck();
    }

    btnLimpar.onclick = function() {
      deck = [];
      renderDeck();
    };

    // Helpers to persist saved decks under the `mytragor_decks` key (array)
    function getSavedDecksLocal() {
      const raw = localStorage.getItem('mytragor_decks');
      if (!raw) return [];
      try { return JSON.parse(raw); } catch { return []; }
    }
    function saveSavedDecksLocal(arr){ localStorage.setItem('mytragor_decks', JSON.stringify(arr)); }

    btnSalvar.onclick = function() {
      if (!chosenLeader || deck.length !== 40) return;
      const deckName = (deckNameInput && String(deckNameInput.value || '').trim()) || '';
      // derive leaderKey from leader name (lowercase, remove accents/spaces)
      function leaderKeyFrom(name){ return (name||'').toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,''); }
      const leaderKey = leaderKeyFrom(chosenLeader.name);
      const deckData = {
        deckName: deckName,
        leader: chosenLeader.name,
        leaderName: chosenLeader.name,
        leaderKey: leaderKey,
        leaderImg: chosenLeader.img,
        cards: deck.map(c => c.name),
        fragImg: chosenFragImg || null
      };
      // migrate old single-deck key if present
      const all = getSavedDecksLocal();
      const oldRaw = localStorage.getItem('mytragor_deck');
      if (oldRaw) {
        try {
          const oldObj = JSON.parse(oldRaw);
          // try to create a compatible saved deck entry
          if (oldObj && oldObj.leader && Array.isArray(oldObj.cards)) {
            const migrated = {
              deckName: '',
              leader: oldObj.leader,
              leaderName: oldObj.leader,
              leaderKey: (oldObj.leader||'').toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,''),
              leaderImg: oldObj.leaderImg || oldObj.leaderImg || null,
              cards: oldObj.cards
            };
            all.push(migrated);
          }
        } catch(e) { /* ignore */ }
        localStorage.removeItem('mytragor_deck');
      }
      all.push(deckData);
      saveSavedDecksLocal(all);
      alert(`Deck salvo: ${deckData.deckName || deckData.leaderName}!`);
      // Optionally redirect to decks salvos page
      // leave on page by default; if user wants, they can click 'Ver decks salvos'
    };

    // Play with this deck: save a temporary key and open the simulator in a new tab
    if (btnPlay) {
      btnPlay.onclick = function() {
        if (!chosenLeader || deck.length !== 40) { alert('Selecione um líder e complete 40 cartas antes de testar.'); return; }
        const deckName = (deckNameInput && String(deckNameInput.value || '').trim()) || '';
        const payload = { deckName: deckName, leader: chosenLeader.name, leaderImg: chosenLeader.img, cards: deck.map(c=>c.name), fragImg: chosenFragImg || null };
        try { localStorage.setItem('mytragor_play_deck', JSON.stringify(payload)); } catch(e){ console.warn('could not persist play deck', e); }
        // open simulator — path relative to assets/ui
        window.open('../../mytragor_simulador.html', '_blank');
      };
    }

    if (btnVerDecks) {
      btnVerDecks.onclick = function() {
        location.href = 'decks_salvos.html';
      };
    }

  // Decode deck from shareable code
  function decodeDeck(code) {
    try {
      if (!code.startsWith('MTG:')) throw new Error('Invalid deck code format');
      const data = JSON.parse(atob(code.slice(4)));
      return {
        leaderName: data.leader || '',
        leaderKey: data.leaderKey || '',
        cards: data.cards || [],
        fragImg: data.fragImg || null,
        deckName: data.deckName || ''
      };
    } catch (e) {
      console.warn('decodeDeck failed', e);
      return null;
    }
  }

  // Wire import deck functionality
  const importCodeInput = document.getElementById('importCodeInput');
  const btnImportDeck = document.getElementById('btnImportDeck');
  if (btnImportDeck && importCodeInput) {
    btnImportDeck.onclick = function() {
      const code = (importCodeInput.value || '').trim();
      if (!code) {
        alert('Cole um código de deck válido.');
        return;
      }
      const deckData = decodeDeck(code);
      if (!deckData) {
        alert('Código inválido. Verifique se copiou corretamente.');
        return;
      }
      
      // Clear current deck
      deck = [];
      chosenLeader = null;
      chosenFragImg = deckData.fragImg;
      
      // Set leader
      if (deckData.leaderName) {
        const leader = LEADERS.find(l => l.name === deckData.leaderName || l.name.toLowerCase() === deckData.leaderName.toLowerCase());
        if (leader) {
          chosenLeader = leader;
        }
      }
      
      // Import cards
      (deckData.cards || []).forEach(cardName => {
        const card = CARD_POOL.find(c => c.name === cardName);
        if (card && deck.length < 40) {
          deck.push(card);
        }
      });
      
      // Set deck name if provided
      if (deckData.deckName && deckNameInput) {
        deckNameInput.value = deckData.deckName;
      }
      
      // Clear import field
      importCodeInput.value = '';
      
      // Re-render everything
      renderLeaders();
      renderFragChooser();
      renderPool();
      renderDeck();
      
      alert(`Deck importado: ${deck.length} cartas${chosenLeader ? ', líder: ' + chosenLeader.name : ''}`);
    };
  }

  // initialize filters and render
  try { setupFilters(); } catch(e) { /* ignore if setup missing */ }
  renderLeaders();
  renderFragChooser();
  renderPool();
  renderDeck();
  
</script>
<script>
  (function(){
    try{
      const btn = document.getElementById('btnShowTutorial');
      const modal = document.getElementById('tutorialModal');
      const close = document.getElementById('btnCloseTutorial');
      if(!btn || !modal) return;
      btn.addEventListener('click', ()=>{ modal.style.display = 'flex'; });
      close && close.addEventListener('click', ()=>{ modal.style.display = 'none'; });
      // close when clicking the overlay background
      modal.addEventListener('click', (ev)=>{ if(ev.target === modal) modal.style.display = 'none'; });
      // allow Escape to close
      document.addEventListener('keydown', (ev)=>{ if(ev.key === 'Escape' && modal.style.display !== 'none') modal.style.display = 'none'; });
    }catch(e){ console.warn('tutorial modal init failed', e); }
  })();
</script>
  </script>
</body>
</html>
