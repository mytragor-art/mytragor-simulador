<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mytragor — Simulador</title>
  <link rel="stylesheet" href="assets/mp/node.css">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <script>
    // Append a timestamp to local asset URLs (styles/scripts/images) so browsers fetch updates immediately.
    (function(){
      try{
        const v = 'v=' + Date.now();
        function addQ(el, attr){
          const url = el.getAttribute(attr);
          if(!url) return;
          if(/^(https?:|data:|file:|\/\/)/i.test(url)) return;
          if(url.indexOf('?')>-1) el.setAttribute(attr, url + '&' + v); else el.setAttribute(attr, url + '?' + v);
        }
        document.querySelectorAll('link[rel=stylesheet], script[src], img').forEach(el=>{
          if(el.tagName==='LINK') addQ(el,'href'); else addQ(el,'src');
        });
      }catch(e){ console.warn('cache-bust failed', e); }
    })();
  </script>

  <script>
    // Panel toggle logic (persist state and update UI)
    (function(){
      function setBodyClass(name, val){ if(val) document.body.classList.add(name); else document.body.classList.remove(name); }
      const logBtn = document.getElementById('btnToggleLog');
      const rightBtn = document.getElementById('btnToggleRight');
      const LOG_KEY = 'mt_log_collapsed';
      const RIGHT_KEY = 'mt_right_collapsed';
      function applyInitial(){ try{
        const logCollapsed = localStorage.getItem(LOG_KEY) === '1';
        const rightCollapsed = localStorage.getItem(RIGHT_KEY) === '1';
        setBodyClass('log-collapsed', logCollapsed);
        setBodyClass('right-collapsed', rightCollapsed);
        if(logBtn) logBtn.setAttribute('aria-expanded', (!logCollapsed).toString());
        if(rightBtn) rightBtn.setAttribute('aria-expanded', (!rightCollapsed).toString());
      }catch(e){} }
      function toggleLog(){ const is = document.body.classList.toggle('log-collapsed'); if(logBtn) logBtn.setAttribute('aria-expanded', (!is).toString()); try{ localStorage.setItem(LOG_KEY, is? '1':'0'); }catch(e){} }
      function toggleRight(){ const is = document.body.classList.toggle('right-collapsed'); if(rightBtn) rightBtn.setAttribute('aria-expanded', (!is).toString()); try{ localStorage.setItem(RIGHT_KEY, is? '1':'0'); }catch(e){} }
      if(logBtn) logBtn.addEventListener('click', toggleLog);
      if(rightBtn) rightBtn.addEventListener('click', toggleRight);
      applyInitial();
    })();

    // Modal polish: close-on-esc, overlay click-to-close, focus trap and restore
    (function(){
      const focusable = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, [tabindex]:not([tabindex="-1"])';
      function initModal(modal){ if(!modal) return; try{
        modal.setAttribute('aria-hidden','false');
        // save previous focus
        modal.__prevFocus = document.activeElement;
        // focus first focusable or the modal itself
        const f = modal.querySelector(focusable);
        (f || modal).focus({preventScroll:true});
        // click outside to close (if not disabled)
        modal.__overlayClick = function(e){ if(e.target === modal && modal.dataset.noOverlayClose!=='true'){ closeModal(modal); } };
        modal.addEventListener('click', modal.__overlayClick);
        // trap tab
        modal.__trap = function(ev){ if(ev.key === 'Tab'){ const nodes = Array.from(modal.querySelectorAll(focusable)).filter(n=>n.offsetParent!==null); if(!nodes.length) { ev.preventDefault(); return; } const first = nodes[0], last = nodes[nodes.length-1]; if(ev.shiftKey && document.activeElement === first){ ev.preventDefault(); last.focus(); } else if(!ev.shiftKey && document.activeElement === last){ ev.preventDefault(); first.focus(); } } };
        document.addEventListener('keydown', modal.__trap);
      }catch(e){ console.warn('initModal error', e); }}
      function cleanupModal(modal){ if(!modal) return; try{
        modal.setAttribute('aria-hidden','true');
        if(modal.__overlayClick) modal.removeEventListener('click', modal.__overlayClick);
        if(modal.__trap) document.removeEventListener('keydown', modal.__trap);
        if(modal.__prevFocus && typeof modal.__prevFocus.focus === 'function') modal.__prevFocus.focus({preventScroll:true});
        delete modal.__prevFocus; delete modal.__overlayClick; delete modal.__trap;
      }catch(e){ console.warn('cleanupModal error', e); }}

      // close topmost modal (last in DOM that is visible)
      function closeTopModal(){ const mods = Array.from(document.querySelectorAll('.modal')).filter(m=>m.style && (m.style.display==='flex' || m.style.display==='block')); if(!mods.length) return; const top = mods[mods.length-1]; closeModal(top); }
      function closeModal(modal){ try{ modal.style.display='none'; cleanupModal(modal); // if using modal queue, ensure we clear showing flag and process queue
        try{ if(window.__modalShowing){ window.__modalShowing = false; if(window.processModalQueue) setTimeout(window.processModalQueue,20); } }catch(e){}
      }catch(e){ console.warn('closeModal error', e); }}

      // observe existing modals for being shown and init
      function watchModals(){ const mods = document.querySelectorAll('.modal'); mods.forEach(m=>{
        // initial aria
        if(!m.hasAttribute('aria-hidden')) m.setAttribute('aria-hidden','true');
        // attach attribute observer
        const obs = new MutationObserver((records)=>{
          records.forEach(r=>{
            if(r.attributeName === 'style'){
              try{
                const d = m.style.display;
                if(d === 'flex' || d === 'block'){
                  initModal(m);
                } else {
                  cleanupModal(m);
                }
              }catch(e){}
            }
          });
        });
        obs.observe(m, { attributes:true, attributeFilter:['style'] });
      }); }
      // global Esc handler
      document.addEventListener('keydown', function(ev){ if(ev.key === 'Escape'){ closeTopModal(); } });
      watchModals();
    })();
  </script>
<style>
  :root {
    --bg: #0b1220;
    --panel: #0e1a2b;
    --line: #2a3b55;
    --ink: #e2e8f0;
  --cardW: 75px;
  --cardH: 106px;
  /* Keep base (unscaled) card sizes so JS can compute scaled values reliably */
  --cardW-base: 75px;
  --cardH-base: 106px;
    /* Responsive scaler vars */
    --scale: 1;
    --left-w: 360px; /* width reserved for Log + Preview column */
    --arena-w: 1600; /* logical arena width (px) */
    --arena-h: 900;  /* logical arena height (px) */
    --radius: 8px;
    --gap: 8px;
    --zoom: 1.0;
  }

  /* Cartas menores e sem zoom/sombra dentro de modais */
  .modal .card {
    width: 63px !important;
    height: 88px !important;
    position: relative !important;
    inset: auto !important;
    margin: 0 !important;
    z-index: 1 !important;
    transition: none !important;
    box-shadow: none !important;
  }

  .modal .card:hover {
    transform: none !important;
    box-shadow: none !important;
  }

.equipBonusSeal {
  position: absolute;
  left: 6px;
  top: 6px;
  background: #fff0;
  color: #e11d48;
  font-weight: bold;
  font-size: 13px;
  text-shadow: 0 1px 0 #fff, 0 0 6px #fff8;
  border: 2px solid #e11d48;
  border-radius: 7px;
  padding: 2px 8px;
  z-index: 10;
  pointer-events: none;
  box-shadow: 0 0 8px #e11d48a0;
}
  html,body{height:100%}

  /* Scenic background: map texture + subtle highlights + grain. The global veil is removed
     so individual arenas (which have their own veils) remain visually distinct. */
  body{
    margin:0;
    background-color: #071025;
    /* Layer order: subtle highlight, map image, grain texture */
    background-image:
      radial-gradient(1200px 700px at 15% 10%, rgba(255,255,255,0.04), rgba(255,255,255,0) 45%),
      url("assets/bgambientes/campos_bg.png"),
      repeating-radial-gradient(circle at 15% 35%, rgba(0,0,0,.03) 0 1px, transparent 1px 12px);
    background-size: cover, cover, auto;
    background-position: center center, center center, 0 0;
    background-attachment: fixed, fixed, scroll;
    color:var(--ink);
    font:14px/1.4 system-ui,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;
  }

  /* Topbar */
  .topbar{display:flex;gap:10px;padding:10px;align-items:center;border-bottom:1px solid var(--line);position:sticky;top:0;background:rgba(14,26,43,.85);backdrop-filter:blur(2px) saturate(1.05);-webkit-backdrop-filter:blur(2px) saturate(1.05);z-index:5;flex-wrap:wrap}
  /* Brand (moved to topbar flow) */
  @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@600;700;900&display=swap');
  .brandWrap{position:relative;display:inline-flex;flex-direction:column;align-items:flex-start;pointer-events:none;margin-left:8px;z-index:3;max-width:220px}
  .brand{font-family:'Cinzel', Georgia, 'Times New Roman', serif;color:var(--gold1,#facc15);font-weight:900;font-size:16px;letter-spacing:1px;text-shadow:0 1px 0 rgba(0,0,0,.6);margin:0}
  .brand span{display:inline-block;background: linear-gradient(90deg, rgba(255,235,160,0.06) 0%, rgba(255,250,200,0.95) 45%, rgba(255,230,140,0.95) 52%, rgba(255,215,90,0.6) 58%, rgba(255,235,160,0.06) 100%);-webkit-background-clip:text;background-clip:text;color:transparent}
  .subtitle{font-family: Georgia, 'Times New Roman', serif;color:var(--gold1,#facc15);font-size:10px;letter-spacing:0.6px;text-transform:uppercase;margin-top:2px;pointer-events:none}
  .brand .spark, .subtitle .spark{position:absolute;top:50%;left:0;width:6px;height:6px;border-radius:50%;pointer-events:none;background: radial-gradient(circle at 30% 30%, #fff 0%, #fff9d6 30%, rgba(255,210,80,0.98) 50%, rgba(255,210,80,0.22) 70%, transparent 85%);box-shadow:0 0 6px rgba(255,230,140,0.98);opacity:0;transform:translateY(-50%) scale(.6);mix-blend-mode: screen;animation:brandSpark 3.2s linear infinite}
  @keyframes brandSpark{0%{left:-20%;opacity:0}12%{left:12%;opacity:1}35%{left:45%;opacity:0.95}55%{left:55%;opacity:0.6}78%{left:88%;opacity:0.15}100%{left:120%;opacity:0}}
  .btn{background:#13223a;border:1px solid var(--line);color:#c9d4e7;border-radius:8px;padding:8px 16px;cursor:pointer;font-size:14px;font-weight:500;box-shadow:0 1px 3px rgba(0,0,0,0.2);margin:4px 4px 4px 0;transition:all 0.2s ease;min-width:80px;text-align:center;}
  .btn:hover{transform:translateY(-1px);box-shadow:0 2px 6px rgba(0,0,0,0.3);opacity:0.9;}
  /* Estilo dourado padrão para botões melhorados */
  .gold-btn{
    background: linear-gradient(180deg,#ffd66b 0%, #e6a600 60%);
    color: #2b1600;
    border: 1px solid rgba(179,123,0,0.9);
    border-radius: 10px;
    box-shadow: 0 6px 14px rgba(166,122,24,0.18), inset 0 1px 0 rgba(255,255,255,0.25);
    text-shadow: 0 1px 0 rgba(255,255,255,0.12);
    transition: transform .08s ease, box-shadow .18s ease, filter .12s ease;
    font-weight:700;
    min-width:84px;
  }
  .gold-btn:active{ transform: translateY(1px); filter:brightness(.98); }

  /* Três efeitos de brilho diferentes (cada clique cicla entre eles) */
  @keyframes glowA{ 0%{ box-shadow:0 0 0 rgba(250,204,21,0)} 50%{ box-shadow:0 0 22px 6px rgba(250,204,21,0.45) } 100%{ box-shadow:0 0 0 rgba(250,204,21,0) } }
  @keyframes glowB{ 0%{ box-shadow:0 0 0 rgba(255,240,180,0)} 40%{ box-shadow:0 0 30px 8px rgba(255,240,180,0.34) } 100%{ box-shadow:0 0 0 rgba(255,240,180,0) } }
  @keyframes glowC{ 0%{ box-shadow:0 0 0 rgba(255,200,80,0)} 50%{ box-shadow:0 0 14px 4px rgba(255,200,80,0.5) } 100%{ box-shadow:0 0 0 rgba(255,200,80,0) } }

  .glow-0{ animation: glowA 700ms ease; }
  .glow-1{ animation: glowB 820ms cubic-bezier(.2,.9,.3,1.2); }
  .glow-2{ animation: glowC 640ms cubic-bezier(.35,.85,.45,1.05); }
  .btn-coin{background:linear-gradient(135deg,#facc15 0%,#fde68a 100%);color:#7c2d12;font-weight:600;}
  .btn-start{background:linear-gradient(135deg,#38bdf8 0%,#0ea5e9 100%);color:#fff;font-weight:600;}
  .btn-choose{background:linear-gradient(135deg,#a3e635 0%,#65a30d 100%);color:#1a2e05;font-weight:600;}
  .btn-next{background:linear-gradient(135deg,#f472b6 0%,#be185d 100%);color:#fff;font-weight:600;}
  .btn-end{background:linear-gradient(135deg,#f87171 0%,#b91c1c 100%);color:#fff;font-weight:600;}

  /* Log controls: darker translucent buttons to match the log panel */
  .logControls .btn{
    background: rgba(0,0,0,0.75);
    color: var(--gold1,#facc15);
    border: 1px solid rgba(250,204,21,0.10);
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    min-width: 84px;
  }
  .logControls .btn:hover{
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(0,0,0,0.7), 0 0 18px rgba(250,204,21,0.06);
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));
    color: #fff;
  }

  /* Log panel background (black 75%) */
  .log{
    background: rgba(0,0,0,0.75);
    border-radius: 10px;
    padding: 12px;
    min-height: 160px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.02), 0 12px 30px rgba(0,0,0,0.6);
  }
  .logLine{border-left:3px solid rgba(250,204,21,0.12);margin:8px 0;padding-left:10px;color:#e6eef8;font-size:14px;line-height:1.45}

  /* Redução de 20% nos conteúdos das colunas laterais */
  .col h3{font-size:12px}
  .col .btn{font-size:12px;padding:6px 12px;border-radius:6px;min-width:64px;margin:3px 3px 3px 0}
  .col .log{padding:12px 12px 72px 12px}

  /* Botão especial para Toupeira */
  #btnOlharTopo {
    background: linear-gradient(135deg, #f8fafc 0%, #e0e7ef 60%, #b6c2d6 100%);
    color: #1e293b;
    border: 1px solid #cbd5e1;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2), 0 0 8px 2px rgba(255,255,255,0.6);
    font-weight: 600;
    font-size: 14px;
    padding: 8px 16px;
    text-shadow: 0 1px 0 rgba(255,255,255,0.8);
    position: relative;
    overflow: hidden;
    transition: all 0.2s ease;
  }
  #btnOlharTopo:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 6px rgba(0,0,0,0.3), 0 0 12px 3px rgba(255,255,255,0.8);
  }
  #btnOlharTopo::after {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: 8px;
    pointer-events: none;
    box-shadow: 0 0 16px 6px #fff8;
    opacity: 0.7;
  }
  .pill{background:rgba(14,26,43,.75);border:1px solid #2b3b5c;border-radius:999px;padding:6px 12px;font-size:13px;color:#b7c3da}

  /* Barra de fases (Início, Principal, Combate, Final) */
  /* Slim variant used between arenas: smaller padding/font so it's less visually heavy */
  .phaseBar{display:flex;align-items:center;gap:8px;background:#0e1a2b;border:1px solid #2b3b5c;border-radius:999px;padding:4px 8px;margin:8px auto;font-size:12px;max-width:520px;justify-content:center}
  .phaseItem{display:flex;align-items:center;gap:6px;color:#b7c3da;font-size:12px;opacity:.7}
  .phaseItem .dot{width:8px;height:8px;border-radius:50%;border:2px solid #64748b;background:#0e1a2b;box-sizing:border-box}
  .phaseItem.active{opacity:1;color:#facc15}
  .phaseItem.active .dot{border-color:#facc15;background:#facc15;box-shadow:0 0 0 4px rgba(250,204,21,.18)}
  .phaseSep{width:22px;height:2px;background:#2a3b55;opacity:.6;border-radius:2px}

  /* Tour overlay (zero-deps) */
  .tour-overlay{ position: fixed; inset:0; background: rgba(2,6,23,0.78); z-index:12000; display:none; align-items:flex-start; justify-content:flex-start; }
  .tour-highlight{ position:absolute; border-radius:12px; box-shadow:0 0 0 6px rgba(250,204,21,0.18); pointer-events:none; transition: all 240ms cubic-bezier(.2,.9,.2,1); }
  .tour-tooltip{ position:absolute; max-width:780px; width: min(96%,780px); background: linear-gradient(180deg,#071523,#0c1622); color:#e6eef8; border:1px solid rgba(250,204,21,0.16); padding:20px;border-radius:12px; box-shadow:0 22px 80px rgba(0,0,0,0.75); z-index:12010; }
  .tour-tooltip .tour-body{ font-size:18px; line-height:1.6; color:#e6eef8; max-height:68vh; overflow:auto; }
  .tour-tooltip h4{ margin:0 0 10px 0; color:#facc15; font-size:20px }
  .tour-tooltip .tour-controls button{ padding:10px 12px; font-size:15px; border-radius:6px; }
  .tour-controls{ display:flex; gap:8px; justify-content:flex-end; margin-top:8px }
  .tour-controls button{ padding:6px 8px; border-radius:8px; background:linear-gradient(180deg,#facc15,#f59e0b); border: none; font-weight:700; cursor:pointer }

  /* Attack animation visuals */
  .attack-line{ position:absolute; height:6px; border-radius:6px; background: linear-gradient(90deg, rgba(255,220,100,0.95), rgba(255,140,40,0.95)); box-shadow:0 6px 18px rgba(255,160,40,0.18); transform-origin:left center; pointer-events:none; z-index:13000; transition: transform 420ms cubic-bezier(.2,.9,.2,1); }
  .attack-swing{ animation: attackSwing 420ms ease; }
  @keyframes attackSwing{ 0%{ transform: translateY(0) rotate(0) } 50%{ transform: translateY(-6px) rotate(-4deg) } 100%{ transform: translateY(0) rotate(0) } }
  .hit-flash{ box-shadow: 0 0 0 6px rgba(255,100,40,0.14), 0 8px 24px rgba(255,120,40,0.12); transition: box-shadow 320ms ease; }
  .damage-pop{ position:absolute; color:#fff7df; font-weight:900; font-size:18px; text-shadow:0 2px 6px rgba(0,0,0,0.6); transform:translateY(0); opacity:1; transition: transform 700ms ease, opacity 700ms ease; z-index:14000 }

  /* Pointer for guided lesson: arrow + label */
  .tour-pointer{ position:absolute; pointer-events:none; z-index:13050; display:flex; flex-direction:column; align-items:center; gap:6px }
  .tour-pointer .arrow{ width:36px; height:36px; background: radial-gradient(circle at 30% 30%, #fff 0%, rgba(255,240,180,0.9) 30%, rgba(255,200,80,0.95) 60%); border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,0.45); display:flex; align-items:center; justify-content:center; font-weight:900; color:#7c2d12 }
  .tour-pointer .label{ background:rgba(8,12,20,0.95); color:#fcefc2; padding:6px 10px; border-radius:8px; border:1px solid rgba(250,204,21,0.06); font-size:13px; max-width:220px; text-align:center }

  /* Slide image inside tooltip */
  .slide-img{ width:100%; height:auto; max-height:160px; object-fit:cover; border-radius:6px; margin-bottom:8px; box-shadow: 0 8px 20px rgba(0,0,0,0.6) }

  /* Layout principal */
  /* Layout: make side columns flexible to avoid large empty gutters on wide screens */
  :root{ --side-min:160px; --side-max-left:220px; --side-max-right:320px; --content-max:1100px; }
  html,body{height:100%;font-family:-apple-system,system-ui,'Segoe UI',Roboto,'Helvetica Neue',Arial; font-size:15px;}
  .app{display:grid;grid-template-columns: minmax(var(--side-min), var(--side-max-left)) 1fr minmax(220px, var(--side-max-right)); gap:8px; padding:8px; min-height:100vh; align-items:start}

  @media(max-width:1200px){ .app{grid-template-columns: minmax(140px,200px) 1fr minmax(180px,260px); } }
  @media(max-width:980px){ .app{grid-template-columns:1fr} }

  /* Background rotator layers (behind everything) */
  .bg-rotator{ position:fixed; inset:0; z-index:-9999; pointer-events:none; overflow:hidden }
  .bg-rotator .bgLayer{ position:absolute; inset:0; background-size:cover; background-position:center center; background-repeat:no-repeat; opacity:0; transition:opacity 1200ms ease; filter:brightness(0.86) saturate(1.02); }
  .bg-rotator .bgLayer.visible{ opacity:1 }

  /* Collapsed layout helpers (toggled via body class) */
  body.log-collapsed .app{ grid-template-columns: 48px 1fr minmax(220px, var(--side-max-right)) !important }
  body.right-collapsed .app{ grid-template-columns: minmax(var(--side-min), var(--side-max-left)) 1fr 48px !important }

  /* Panel toggle button */
  .panelToggle{ background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--ink);padding:6px;border-radius:6px;cursor:pointer;font-size:14px }
  .panelToggle.rightToggle{ position:absolute; right:8px; top:8px; z-index:60; opacity:0.9 }
  /* When a column is visually collapsed hide its children content except the toggle area */
  .col.collapsed > *:not(.panelToggle){ display:none }

  .col{background:linear-gradient(180deg,rgba(14,26,43,.86),rgba(12,23,40,.80));backdrop-filter:blur(1.5px) saturate(1.05);-webkit-backdrop-filter:blur(1.5px) saturate(1.05);border:1px solid var(--line);border-radius:12px;overflow:auto;padding:10px}
  .right{display:flex;flex-direction:column}

  h3{margin:12px 14px 0 14px;font-size:15px;color:#a7b5cc;letter-spacing:.04em}

  /* Log mais compacto e rolável */
  .log{padding:10px 12px 64px 12px; max-height:36vh; overflow:auto}
  .logLine{border-left:2px solid #2b3b5c;margin:8px 0;padding-left:8px;color:#c3cee3;font-size:15px;line-height:1.45}
  /* Log variants (stronger colors) */
  .logLine.hit{
    border-left:4px solid #059669; /* vivid green */
    background: transparent; /* remove veil */
    color: #e6fff4; /* light green text for contrast */
    text-shadow: 0 1px 0 rgba(0,0,0,0.7);
    font-weight:700;
  }
  .logLine.miss{
    border-left:4px solid #dc2626; /* vivid red */
    background: transparent; /* remove veil */
    color: #ffecec; /* light red/pink text for contrast */
    text-shadow: 0 1px 0 rgba(0,0,0,0.7);
    font-weight:700;
  }
  .logLine.effect{
    border-left:4px solid #b45309; /* stronger amber */
    background: transparent; /* remove veil */
    color: #fff7e6;
    text-shadow: 0 1px 0 rgba(0,0,0,0.65);
    font-weight:600;
  }
  .logLine.dice{
    border-left:3px solid #2563eb;
    background: transparent; /* remove veil */
    color: #eaf4ff;
    text-shadow: 0 1px 0 rgba(0,0,0,0.65);
    font-weight:600;
  }

  /* Board central otimizado */
  /* Layout: left column (log+preview) & right column (arena) */
  .app{ display:grid; grid-template-columns: var(--left-w) 1fr; gap:12px; align-items:start; padding:12px; box-sizing:border-box }
  /* Place preview at left column row 1 (on top) */
  #previewCol{ grid-column:1; grid-row:1 }
  /* Place log at left column row 2 (below preview) */
  #logCol{ grid-column:1; grid-row:2 }
  /* Board column occupies rows 1..2 on the right */
  .col.right{ grid-column:2; grid-row:1 / span 2 }

  .boardWrap{display:flex;justify-content:center;overflow:auto;padding:4px;align-items:center}
  /* Stage wrapper that will be scaled to fit the available right-side area */
  .scaler{ display:flex; align-items:center; justify-content:center; width:100%; height:100%; pointer-events:auto }
  .boardStage{ width: calc(var(--arena-w) * 1px); height: calc(var(--arena-h) * 1px); transform-origin: top left; pointer-events:auto; transform: scale(var(--scale)); }
  /* The board itself keeps its internal layout. We keep existing boardZoom so --zoom adjustments still apply (vertical fit). */
  .boardZoom{ transform: scale(var(--zoom)); transform-origin: 0 0 }
  /* Limit board max width to avoid huge empty gutters on wide monitors */
  .board{ padding:6px; margin:0 auto; min-width:640px; max-width:var(--content-max); width:100%; box-sizing:border-box }

  /* Arena (sem cortes e com altura fluida) */
  .arena {
    position: relative;
    isolation: isolate;
    border: 1px solid var(--line);
    border-radius: 12px;
    padding: 10px;
    padding-left: calc(10px + 72px); /* reserva espaço para os fragmentos à esquerda */
    background: transparent;
    margin-bottom: 12px;
    box-sizing: border-box;
    overflow: visible; /* permite hover/zoom das cartas sem corte */
  }

  /* Temas de arena por filiação (gradientes esfumaçados) */
  .arena.theme-arcano{
    background:
      radial-gradient(120% 100% at 10% 0%, rgba(37, 99, 235, .15), rgba(37,99,235,0) 60%),
      radial-gradient(140% 120% at 90% 100%, rgba(30, 58, 138, .18), rgba(30,58,138,0) 65%),
      linear-gradient(180deg, rgba(30,58,138,.10), rgba(30,58,138,.05)),
      /* véu sólido para não deixar o papel dominar */
      linear-gradient(0deg, rgba(12, 23, 40, .94), rgba(12, 23, 40, .94));
  }
  .arena.theme-marcial{
    background:
      radial-gradient(120% 100% at 10% 0%, rgba(185, 28, 28, .16), rgba(185,28,28,0) 60%),
      radial-gradient(140% 120% at 90% 100%, rgba(127, 29, 29, .18), rgba(127,29,29,0) 65%),
      linear-gradient(180deg, rgba(127,29,29,.10), rgba(127,29,29,.05)),
      linear-gradient(0deg, rgba(24, 12, 12, .94), rgba(24, 12, 12, .94));
  }
  .arena.theme-religioso{
    background:
      radial-gradient(120% 100% at 10% 0%, rgba(245, 158, 11, .18), rgba(245,158,11,0) 60%),
      radial-gradient(140% 120% at 90% 100%, rgba(180, 83, 9, .18), rgba(180,83,9,0) 65%),
      linear-gradient(180deg, rgba(180,83,9,.10), rgba(180,83,9,.05)),
      linear-gradient(0deg, rgba(40, 28, 6, .94), rgba(40, 28, 6, .94));
  }
  .arena.theme-sombras{
    background:
      radial-gradient(120% 100% at 10% 0%, rgba(71, 85, 105, .16), rgba(71,85,105,0) 60%),
      radial-gradient(140% 120% at 90% 100%, rgba(31, 41, 55, .18), rgba(31,41,55,0) 65%),
      linear-gradient(180deg, rgba(31,41,55,.10), rgba(31,41,55,.05)),
      linear-gradient(0deg, rgba(16, 20, 26, .94), rgba(16, 20, 26, .94));
  }

  /* Slots mais claros em cada tema */
  .arena.theme-arcano .slot{ background: rgba(37, 99, 235, .10); border:1px solid rgba(148,163,184,.35); }
  .arena.theme-marcial .slot{ background: rgba(185, 28, 28, .10); border:1px solid rgba(148,163,184,.35); }
  .arena.theme-religioso .slot{ background: rgba(245, 158, 11, .12); border:1px solid rgba(148,163,184,.35); }
  .arena.theme-sombras .slot{ background: rgba(71, 85, 105, .12); border:1px solid rgba(148,163,184,.35); }
  /* .arena-bg e véu removidos */
  /* Camada de imagem de ambiente (por cima do véu, abaixo do jogo) */
  .arenaEnvBg{
    position:absolute; inset:0; border-radius:12px; pointer-events:none; z-index:2;
    background-repeat:no-repeat; background-position:center; background-size:cover;
    opacity:.38; /* levemente escurecida via gradiente + opacidade */
  }
  .sideTitle, .sideTitle.bottom, .fragDock, .aiHand, .arenaGrid, .hand {
    position: relative;
  z-index: 4;
  }
  .sideTitle{position:absolute;left:10px;top:8px;font-weight:700;color:#b7c3da}
  .sideTitle.bottom{top:auto;bottom:8px}

  .arenaGrid{
    display:grid;
    grid-template-columns: 1fr var(--cardW); /* campo ocupa quase tudo; pilhas à direita */
    gap: 8px;
    align-items:center;
    max-width: 100%;
  }

  .mainArea{
    display:grid;
    grid-template-rows: auto auto auto; /* spells / aliados / líder+amb */
    gap: 8px;
    overflow: visible; /* não cortar cartas em hover */
  }

  /* líder + ambiente CENTRALIZADOS, lado a lado */
  .leaderBar{
    display:flex;
    justify-content:center;
    gap: var(--gap);
    align-items:center;
  }

  .pilesCol{
    display:flex; flex-direction:column; gap:6px; align-items:center; justify-content:center;
  }

  .lane{display:grid; grid-template-columns:repeat(5,var(--cardW)); grid-auto-rows:var(--cardH); gap:var(--gap); justify-content:center}
  .slot{width:var(--cardW);height:var(--cardH);border:1px dashed #3a4a6d;border-radius:var(--radius);display:flex;align-items:center;justify-content:center;color:#6d7fa3;position:relative}

  .slot.clickable{
    outline:none;
    cursor:pointer;
    /* pulso vermelho para alvos atacáveis */
    animation: pulseRed 1s ease-in-out infinite;
  }
  .slot.clickable *{pointer-events:none;}
  .slot.selected{box-shadow:0 0 0 3px #f59e0b inset}
  .slotLabel{position:absolute;bottom:4px;left:4px;background:#0f172a;border:1px solid #304566;border-radius:6px;padding:1px 5px;font-size:10px;color:#c9d4e7;z-index:5}
  .slotCount{position:absolute;top:4px;right:4px;background:#0f172a;border:1px solid #304566;border-radius:6px;padding:1px 5px;font-size:10px;color:#c9d4e7;z-index:5}

  .card{
    width:var(--cardW);
    height:var(--cardH);
    border-radius:var(--radius);
    background:#102039;
    border:1px solid #2b3b5c;
  position:absolute;
  inset:0;
  margin:auto;
  z-index: 20;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    transition: transform 0.18s cubic-bezier(.4,1.6,.6,1), box-shadow 0.18s cubic-bezier(.4,1.6,.6,1);
  }
  /* Pulso verde para cartas que podem atacar */
  .card.canAttack{
    animation: pulseGreen 1s ease-in-out infinite;
  }
  @keyframes pulseRed{
    0% { box-shadow: 0 0 0 0 rgba(255,51,51,0.0); transform: translateY(0); }
    50% { box-shadow: 0 0 12px 6px rgba(255,51,51,0.45); transform: translateY(-3px); }
    100% { box-shadow: 0 0 0 0 rgba(255,51,51,0.0); transform: translateY(0); }
  }
  @keyframes pulseGreen{
    0% { box-shadow: 0 0 0 0 rgba(34,197,94,0.0); transform: translateY(0); }
    50% { box-shadow: 0 0 12px 6px rgba(34,197,94,0.36); transform: translateY(-3px); }
    100% { box-shadow: 0 0 0 0 rgba(34,197,94,0.0); transform: translateY(0); }
  }
  .card:hover {
    transform: scale(1.13);
    z-index: 50; /* garantir que fique acima de pilhas/slots vizinhos */
    box-shadow: 0 12px 32px rgba(0,0,0,0.45);
  }
  .card img{width:100%;height:100%;object-fit:cover;display:block}
  /* Token spawn animation: brief scale+glow when a token is created */
  .card.tokenSpawn{ animation: tokenSpawnAnim 0.6s ease-out; box-shadow: 0 12px 30px rgba(250,200,60,0.35); }
  @keyframes tokenSpawnAnim{
    0% { transform: scale(.6) rotate(0deg); filter: brightness(1.4) drop-shadow(0 6px 18px rgba(250,200,60,0.55)); opacity: 0 }
    50% { transform: scale(1.08) rotate(2deg); opacity: 1 }
    100% { transform: scale(1) rotate(0deg); opacity: 1 }
  }
  .tap{transform:rotate(90deg)}
  .hpTag{position:absolute;left:4px;bottom:4px;background:#0f172a;border:1px solid #304566;border-radius:6px;font-size:11px;padding:1px 5px}
  /* Selo de vida específico para Escolhidos (líderes) */
  .hpTag.leader-safe{background:#000;border-color:#111;color:#34d399;font-weight:700;box-shadow:0 0 6px rgba(52,211,153,0.08)}
  .hpTag.leader-low{background:#000;border-color:#111;color:#ef4444;font-weight:700;box-shadow:0 0 6px rgba(239,68,68,0.08)}
  .badge{position:absolute;right:4px;top:4px;background:#0f172a;border:1px solid #304566;border-radius:6px;font-size:10px;padding:1px 5px}
  .costTag{position:absolute;left:4px;top:4px;background:#13223a;border:1px solid #3a4a6d;border-radius:6px;font-size:11px;padding:1px 5px}
  /* Custo mais legível na mão */
  .card.handCard .costTag{background:linear-gradient(180deg,#0b1325,#0d1b2a);border-color:#f59e0b;color:#fde68a;font-weight:700;font-size:12px;padding:2px 6px;letter-spacing:.02em}
  /* Bônus temporário de ATK (ex.: Campos Ensanguentados) */
  .atkBonusTag{position:absolute;right:4px;top:22px;background:#0f172a;border:1px solid #304566;border-radius:6px;font-size:10px;padding:1px 5px;color:#facc15}

  /* Tag visual para redução de dano (ex.: Redoma Santa) */
  .dmgRedTag{position:absolute;left:4px;top:22px;background:#e0f2fe;border:1px solid #60a5fa;border-radius:6px;font-size:10px;padding:1px 6px;color:#032;font-weight:700}

  /* Badge específico de Aranhas Negras: fundo preto com numeração amarela */
  .aranhaBadge{position:absolute;left:6px;top:6px;background:#000;color:#facc15;font-weight:700;border-radius:6px;padding:3px 8px;font-size:12px;border:1px solid #f6e05e;z-index:12}

  /* Selo visual das keywords (provocar, bloquear, atropelar) */
  .badgeKw{
    position:absolute;
    right:4px;
    bottom:4px;
    background:#0f172a;
    border:1px solid #304566;
    border-radius:6px;
    font-size:10px;
    padding:1px 5px;
    color:#c9d4e7;
    max-width:calc(var(--cardW) - 10px);
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  /* Ícones de palavras‑chave na mão (substitui badgeKw textual) */
  .kwIcons{position:absolute;right:4px;bottom:4px;display:flex;gap:4px}
  .kwIcons .kw{background:#0f172a;border:1px solid #304566;border-radius:6px;font-size:12px;padding:2px 6px;line-height:1;color:#c9d4e7;display:flex;align-items:center;justify-content:center}

  .hand{
    display:flex;
    align-items:flex-end;
    justify-content:center;
    gap:0;
    flex-wrap:nowrap;
    overflow-x:auto;
    padding:8px 6px;
    background:transparent;
    position:relative;
    z-index:auto;
  }
  /* Slight overlap so the hand doesn't push the board horizontally */
  .hand .card.handCard{ position:relative; width:128px; /* keep card aspect ratio based on --cardW/--cardH */ height: calc(128px * (var(--cardH) / var(--cardW))); margin-left:-34px; transition:transform .16s ease, box-shadow .16s ease }
  .hand .card.handCard:first-child{ margin-left:0 }
  /* Indicador de jogável agora: borda suave + pulso leve */
  .card.handCard.canPlay { border: 2px solid #facc15; box-shadow: 0 0 0 2px rgba(250,204,21,.35); animation: pulseRing 1.8s ease-in-out infinite; z-index:2; filter:none; }
  @keyframes pulseRing { 0%{ box-shadow:0 0 0 2px rgba(250,204,21,.35);} 70%{ box-shadow:0 0 0 10px rgba(250,204,21,0);} 100%{ box-shadow:0 0 0 2px rgba(250,204,21,0);} }
  .hand .card.handCard:hover{ transform:translateY(-6px) scale(1.03); z-index:40; box-shadow:0 10px 24px rgba(0,0,0,0.45) }

  .aiHand{display:flex;gap:6px;justify-content:center;padding:4px 0}
  .aiBack{width:34px;height:50px;border-radius:5px;border:1px solid #2b3b5c;overflow:hidden;background:#1b2a46}
  .aiBack img{width:100%;height:100%;display:block;object-fit:cover}

  /* Prévia otimizada (com redução adicional solicitada) */
  .inspector{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:12px;max-height:calc(100vh - 120px);overflow-y:auto;}
  .big{width:192px;height:268px;border-radius:10px;border:1px solid #2b3b5c;background:#101f36;overflow:hidden;flex-shrink:0;}
  .big img{width:100%;height:100%;object-fit:cover}
  .meta{font-size:12px;color:#c9d4e7;white-space:pre-wrap;max-width:192px;padding:10px 6px;line-height:1.35;text-align:center;}

  .modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:20}
  .modalBox{width:min(720px,90vw);max-height:80vh;overflow:auto;background:#0f1c31;border:1px solid #2b3b5c;border-radius:12px;padding:10px}
  .gridMini{display:grid;grid-template-columns:repeat(auto-fill, minmax(90px,1fr));gap:8px}
  .mini{height:120px;border:1px solid #2b3b5c;border-radius:8px;background:#101f36;display:flex;align-items:center;justify-content:center;overflow:hidden}
  .mini img{width:100%;height:100%;object-fit:cover}

  /* === FRAGMENTOS (cristais) — colocados fora da arena pra não empurrar layout === */
  .fragDock{
    position:absolute;
    left:6px;
    top:16px;
    display:flex;
    flex-direction:column;
    align-items:flex-start;
    gap:8px;
    width:48px;
    pointer-events:none;
    z-index:2;
    padding:0;
    background:transparent;
  }
  .fragStack {
    width:40px; height:54px; position:relative; margin-bottom:8px;
  }
  .fragStack .fragBack {
    width:100%; height:100%; border-radius:7px; box-shadow:0 1px 3px rgba(0,0,0,0.18); background:#222; position:absolute; left:0; top:0;
    transition: box-shadow 0.2s;
  }
  .fragStack .fragBack img {
    width:100%; height:100%; object-fit:cover; border-radius:7px;
  }
  .fragTokensRow {
    display:grid; grid-template-columns:repeat(2, 36px); grid-template-rows:repeat(5, 52px); gap:10px 12px;
  }
  .fragToken {
    width:36px; height:52px; border-radius:8px; overflow:hidden; background:#222; box-shadow:0 1px 3px rgba(0,0,0,0.18); display:flex; align-items:center; justify-content:center; transition:filter 0.2s, box-shadow 0.2s;
  }
  .fragToken.lit {
    filter: drop-shadow(0 0 8px #6ee7ff) brightness(1.1);
    box-shadow:0 0 8px #6ee7ff,0 1px 3px rgba(0,0,0,0.18);
  }
  .fragToken.spent img {
    filter: grayscale(0.7) brightness(0.6);
  }
  .fragDock .fragTitle{
    writing-mode:vertical-rl;
    transform:rotate(180deg);
    font-size:11px;
    color:#9fb4d6;
    letter-spacing:.06em;
    opacity:.8;
  }
  .fragDock .crystal{
    width:28px; height:28px; position:relative; opacity:.25;
    filter:drop-shadow(0 2px 4px rgba(0,0,0,.45));
  }
  .fragDock .crystal::before{
    content:""; position:absolute; inset:0; transform:rotate(45deg); border-radius:6px;
    background:radial-gradient(60% 60% at 50% 35%, #1b2a46 0%, #0b1730 60%, #071022 100%);
    border:1px solid #2f4a7a;
  }
  .fragDock .crystal.ready{opacity:.55;}
  .fragDock .crystal.on{opacity:1;}
  .fragDock .crystal.on::before{
    background:radial-gradient(60% 60% at 50% 35%, #6ee7ff 0%, #3ab4ff 45%, #0ea5e9 80%);
    border-color:#76d1ff;
    box-shadow:0 0 10px rgba(80,200,255,.65), inset 0 0 6px rgba(255,255,255,.35);
  }
  @media(max-width:1200px){
    .fragDock{ left:-52px; right:auto; }
  }

  /* === NOVAS ESTILIZAÇÕES === */
  .cardChoiceCard {
    width: 132px !important;
    height: 189px !important;
    min-width: 0 !important;
    min-height: 0 !important;
    max-width: 132px !important;
    max-height: 189px !important;
    margin: 0 !important;
    box-shadow: none !important;
    position: relative !important;
    z-index: 1 !important;
  }
  #cardChoiceGrid {
    display: grid !important;
    grid-template-columns: repeat(auto-fit, minmax(132px, 1fr));
    gap: 12px !important;
    justify-content: center !important;
    align-items: center !important;
  }
  
  /* MOBILE ADJUSTMENTS: Force preview+log to stack above the arena on small screens
     and reduce preview/log sizes so the arena remains visible. These rules override
     the desktop two-column layout only on narrow viewports. */
  @media (max-width: 700px) {
    .app {
      grid-template-columns: 1fr !important;
      grid-template-rows: auto auto 1fr;
      gap: 8px;
      padding: 8px;
    }
    /* ensure preview and log occupy full width and keep order */
    #previewCol { grid-column: 1; grid-row: 1; }
    #logCol { grid-column: 1; grid-row: 2; }
    .col.right { grid-column: 1; grid-row: 3; }

    /* reduce inspector/preview size on mobile */
    .inspector { padding: 8px; }
    .inspector .big { width: 140px; height: 196px; }
    .meta { max-width: 140px; font-size: 12px; }

    /* make the log reasonably tall but not dominant */
    .log { max-height: 34vh; padding-bottom: 48px; }

    /* board wrapper should allow the board to take remaining space and center */
    .boardWrap { padding: 4px 0; }
    .scaler { justify-content: center; align-items: flex-start; }
    .boardStage { transform-origin: top center; }

    /* hand and other side elements should wrap more compactly */
    .hand .card.handCard { width: 112px; height: calc(112px * (var(--cardH) / var(--cardW))); margin-left: -28px; }
  }
</style>

</head>

<script>
// Modal queue helpers: defer modal displays during sensitive UI refreshes (e.g., fragment renewal)
// Usage: enqueueModal(function(done){ show modal UI; when modal closes call done(); })
try{
  window.__modalQueue = window.__modalQueue || [];
  window.__modalShowing = !!window.__modalShowing;
  window.enqueueModal = function(showFn){ if(typeof showFn!=='function') return; window.__modalQueue.push(showFn); if(window.processModalQueue) window.processModalQueue(); };
  window.processModalQueue = function(){ if(window.__modalShowing) return; if(window.__BEGIN_TURN_IN_PROGRESS) return; const fn = window.__modalQueue.shift(); if(!fn) return; window.__modalShowing = true; try{ fn(function(){ window.__modalShowing = false; setTimeout(window.processModalQueue, 20); }); }catch(e){ console.error('modalQueue error', e); window.__modalShowing=false; setTimeout(window.processModalQueue,20); } };
}catch(e){ console.warn('modal queue init failed', e); }
</script>

<script>
// Background selection script: pick one image from assets/bgambientes on each load
;(function(){
  const IMAGES = [
    'assets/bgambientes/tempestade_bg.png',
    'assets/bgambientes/labirinto_bg.png',
    'assets/bgambientes/catedral_bg.png',
    'assets/bgambientes/campos_bg.png'
  ];
  function preload(src){ const i=new Image(); i.src=src; }
  IMAGES.forEach(preload);
  function setBg(el, src){ if(!el) return; el.style.backgroundImage = `url("${src}")`; }

  document.addEventListener('DOMContentLoaded', ()=>{
    try{
      const a = document.getElementById('bgLayerA');
      const b = document.getElementById('bgLayerB');
      if(!a) return;
      const idx = Math.floor(Math.random() * IMAGES.length);
      setBg(a, IMAGES[idx]);
      a.classList.add('visible');
      // ensure the secondary layer is empty/hidden
      if(b){ b.classList.remove('visible'); b.style.backgroundImage = '' }
    }catch(e){ console.warn('bg select failed', e); }
  });
})();
</script>

<body>

  <!-- Background rotator (controlled by JS) -->
  <div class="bg-rotator" aria-hidden="true">
    <div class="bgLayer" id="bgLayerA"></div>
    <div class="bgLayer" id="bgLayerB"></div>
  </div>

<!-- Topbar -->
<div class="topbar">
  <span class="pill" id="whoActive">Ativo —</span>
  <span class="pill" id="phasePill">Fase: —</span>
  <span class="pill" id="fragPill">Frags: 0/10 (turno)</span>
  <!-- phaseBar moved down between arenas to make it more visible and less crowded in the topbar -->
  <label class="pill" style="display:flex;align-items:center;gap:6px">
    Zoom <input id="zoomRange" type="range" min="0.9" max="1.35" step="0.01" value="1.12" style="width:140px">
  </label>
  <button id="btnBackMenu" class="btn btn-coin" title="Voltar ao menu" style="margin-left:8px;background:linear-gradient(135deg,#facc15 0%,#f59e0b 100%);color:#111;font-weight:700;">Voltar ao menu</button>
  <button id="btnTutorial" class="btn" title="Abrir tutorial" style="margin-left:6px;background:linear-gradient(135deg,#facc15 0%,#e6a600 100%);color:#111;font-weight:700;">Tutorial</button>
  <div class="brandWrap" aria-hidden="true">
    <div class="brand"><span>Mytragor</span>
      <i class="spark" aria-hidden="true"></i>
    </div>
    <div class="subtitle"><span>Simulador</span>
      <i class="spark" aria-hidden="true"></i>
    </div>
  </div>
</div>

  <!-- Modal de Seleção de Personagem -->

  <div id="charSelect" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);z-index:1000;align-items:center;justify-content:center;padding:20px;">
    <div style="width:100%;max-width:980px;display:flex;gap:18px;align-items:flex-start;">
      <div style="flex:0 0 320px;background:linear-gradient(180deg,#070709,#0b0b10);border:1px solid rgba(250,204,21,0.08);border-radius:12px;padding:14px;box-shadow:0 10px 30px rgba(0,0,0,0.6),0 0 28px rgba(250,190,40,0.03);">
        <button onclick="hideCharSelect()" style="position:absolute;right:34px;top:24px;background:none;border:none;color:#cbd5e1;font-size:22px;cursor:pointer;padding:4px">&times;</button>
        <div style="text-align:center;margin-bottom:12px;color:#facc15;font-weight:800;font-size:18px">Pré-visualização do Líder</div>
        <div id="charPreview" style="display:flex;flex-direction:column;align-items:center;gap:10px;color:#e2e8f0">
          <img id="charPreviewImg" src="assets/chosens/valbrak.png" alt="preview" style="width:220px;height:300px;object-fit:cover;border-radius:8px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 22px rgba(0,0,0,0.6)" />
          <div id="charPreviewName" style="color:#facc15;font-weight:900"></div>
          <div id="charPreviewStats" style="color:#aab9d3;font-size:13px;text-align:center"></div>
        </div>
      </div>
      <div style="flex:1;background:linear-gradient(180deg,#07121b,#07111a);border:1px solid rgba(255,255,255,0.02);border-radius:12px;padding:18px;box-shadow:0 10px 40px rgba(0,0,0,0.7);">
        <h2 style="margin:0 0 12px 0;color:#facc15;font-size:20px">Escolha seu Escolhido</h2>
        <div id="charGrid" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:18px;margin-top:8px"></div>
      </div>
    </div>
  </div>

<div class="app">
  <!-- Log -->
  <div class="col" id="logCol">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:6px">
      <h3 style="margin:0">Log</h3>
      <button id="btnToggleLog" class="panelToggle" title="Colapsar/Expandir log" aria-expanded="true">▸</button>
    </div>
    <div class="logControls" style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:16px;align-items:center;">
      <button class="btn btn-choose" id="btnChoose">Escolher Baralho</button>
      <button class="btn" id="btnRestart" title="Reiniciar o simulador">Reiniciar</button>
    </div>
    <div class="log" id="log"></div>
  </div>

  <!-- Board -->
  <div class="col right">
    <button id="btnToggleRight" class="panelToggle rightToggle" title="Colapsar/Expandir coluna direita" aria-expanded="true">◂</button>
    <div class="boardWrap">
      <div class="scaler">
        <div class="boardStage" id="boardStage">
          <div class="board boardZoom">

        <!-- Oponente -->
        <div class="arena" id="opArena">
          <!-- BG de Ambiente (por cima do véu) -->
          <div class="arenaEnvBg" id="opEnvBg" aria-hidden="true"></div>
          <div class="aiHand" id="aiHand"></div>
          <div class="fragDock" id="ai-frags" aria-label="Fragmentos do Oponente"></div>
          <div class="sideTitle">Oponente</div>
          <div class="arenaGrid">
            <div class="mainArea">
              <div class="lane" id="ai-spells"></div>
              <div class="lane" id="ai-allies"></div>
              <div class="leaderBar">
                <div class="slot" id="ai-leader"></div>
                <div class="slot" id="ai-env"><span class="slotLabel">Amb</span></div>
              </div>
            </div>
            <div class="pilesCol">
              <div class="slot" id="ai-ban"><span class="slotLabel">Banidas</span><span class="slotCount" id="ai-ban-count">0</span></div>
              <div class="slot" id="ai-grave"><span class="slotLabel">Cemitério</span><span class="slotCount" id="ai-grave-count">0</span></div>
              <div class="slot" id="ai-deck"><span class="slotLabel">Deck</span><span class="slotCount" id="ai-deck-count">0</span></div>
            </div>
          </div>
        </div>
        
        <!-- thin phase bar placed between arenas -->
        <div class="phaseBar" id="phaseBar" aria-label="Barra de fases">
          <div class="phaseItem" data-phase="start"><span class="dot" aria-hidden="true"></span><span>Início</span></div>
          <div class="phaseSep" aria-hidden="true"></div>
          <div class="phaseItem" data-phase="main"><span class="dot" aria-hidden="true"></span><span>Principal</span></div>
          <div class="phaseSep" aria-hidden="true"></div>
          <div class="phaseItem" data-phase="battle"><span class="dot" aria-hidden="true"></span><span>Combate</span></div>
          <div class="phaseSep" aria-hidden="true"></div>
          <div class="phaseItem" data-phase="end"><span class="dot" aria-hidden="true"></span><span>Final</span></div>
        </div>

        <!-- single action button that mirrors Start / Next / End actions -->
        <div style="display:flex;align-items:center;justify-content:center;margin:6px 0 12px 0;">
          <button id="phaseActionBtn" class="btn btn-start" style="min-width:120px;">Iniciar</button>
        </div>

        <!-- Você -->
        <div class="arena" id="youArena">
          <!-- BG de Ambiente (por cima do véu) -->
          <div class="arenaEnvBg" id="youEnvBg" aria-hidden="true"></div>
          <div class="fragDock" id="you-frags" aria-label="Seus Fragmentos"></div>
          <div class="sideTitle bottom">Você</div>
          <div class="arenaGrid">
            <div class="mainArea">
              <div class="leaderBar">
                <div class="slot" id="you-leader"></div>
                <div class="slot" id="you-env"><span class="slotLabel">Amb</span></div>
              </div>
              <div class="lane" id="you-allies"></div>
              <div class="lane" id="you-spells"></div>
            </div>
            <div class="pilesCol">
              <div class="slot" id="you-ban"><span class="slotLabel">Banidas</span><span class="slotCount" id="you-ban-count">0</span></div>
              <div class="slot" id="you-grave"><span class="slotLabel">Cemitério</span><span class="slotCount" id="you-grave-count">0</span></div>
              <div class="slot" id="you-deck"><span class="slotLabel">Deck</span><span class="slotCount" id="you-deck-count">0</span></div>
            </div>
          </div>
          <div class="hand" id="youHand"></div>
        </div>

          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Prévia (moved visually to left column via CSS grid) -->
  <div class="col" id="previewCol">
    <h3>Prévia</h3>
    <div class="inspector"><div class="big"><img id="bigImg" src="" alt=""></div></div>
    <div class="meta" id="bigMeta">
Passe o mouse sobre uma carta…
Dica: na Fase de Combate, clique no seu aliado/líder e depois no alvo (líder inimigo ou aliados deitados).
    </div>
  </div>
</div>

<!-- Modal pilhas -->

<div class="modal" id="pileModal">
  <div class="modalBox">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <h3 id="pileTitle" style="margin:0">—</h3>
      <button class="btn" onclick="hidePile()">Fechar</button>
    </div>
  <div class="gridMini" id="pileGrid"></div>
  </div>
</div>

<!-- Modal de Escolha de Cartas (Ajustado) -->

<div id="cardChoiceModal" class="modal" style="display:none;align-items:center;justify-content:center;z-index:100">
  <div class="modalBox" style="max-width:800px;width:90vw">
  <h3 id="cardChoiceTitle" style="margin:0 0 16px 0;font-size:18px;color:#e2e8f0;font-weight:bold;text-align:center">Escolha uma carta</h3>
  <div id="cardChoiceGrid" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(48px,1fr));gap:6px;justify-content:center;"></div>
  <button class="btn" id="cardChoiceCancel" style="width:100%">Cancelar</button>
  </div>
</div>

<!-- body será fechado após os scripts -->

<!-- Modal de Conversa Fiada (Ajustado) -->
<div id="conversaFiadaModal" class="modal" style="display:none;align-items:center;justify-content:center;z-index:100">
  <div class="modalBox" style="max-width:600px;width:90vw;padding:20px 18px;display:flex;flex-direction:column;align-items:center;">
    <h3 style="margin:0 0 12px 0;font-size:18px;color:#e2e8f0;font-weight:bold;text-align:center">Conversa Fiada</h3>
    <div style="display:flex;gap:14px;align-items:center;width:100%;margin-bottom:12px;">
      <div id="cfTargetPreview" style="display:flex;gap:12px;align-items:center;">
        <img id="cfTargetImg" src="assets/ui/card-back.png" alt="alvo" style="width:64px;height:90px;border-radius:8px;box-shadow:0 4px 18px rgba(0,0,0,0.6);object-fit:cover;" onerror="this.src='assets/ui/card-back.png'">
        <div style="display:flex;flex-direction:column;gap:6px;">
          <div id="cfTargetName" style="font-size:15px;color:#e2e8f0;font-weight:700;">Carta do oponente</div>
          <div id="cfTargetSubtitle" style="font-size:13px;color:#94a3b8;">Você pode anular esta magia ou truque</div>
        </div>
      </div>
    </div>
    <div style="font-size:14px;color:#e2e8f0;text-align:center;margin-bottom:12px;width:100%;">
      Ativar <b style="color:#facc15">Conversa Fiada</b> para anular a magia/truque em resposta?
    </div>
    <div style="font-size:13px;margin-bottom:10px;color:#94a3b8;">Custo: <b style="color:#facc15" id="cfCusto">0</b> fragmento(s).</div>
    <div style="display:flex;gap:12px;justify-content:center;width:100%">
      <button id="btnConversaSim" class="btn" style="flex:1;background:#facc15;color:#1f2937;font-weight:700;">Ativar</button>
      <button id="btnConversaNao" class="btn" style="flex:1;background:#334155;color:#e2e8f0;">Fechar</button>
    </div>
  </div>
</div>

    <!-- Modal de Vitória (moderno) -->
    <div id="victoryModal" class="modal" style="display:none;align-items:center;justify-content:center;z-index:200">
      <div class="modalBox" style="max-width:480px;width:90vw;text-align:center;padding:22px;display:flex;flex-direction:column;align-items:center;gap:12px">
        <div style="font-size:48px">🏆</div>
        <h2 id="victoryTitle" style="margin:0;font-size:22px;color:#facc15">—</h2>
        <img id="victoryImg" src="assets/ui/card-back.png" style="width:120px;height:170px;border-radius:10px;object-fit:cover;box-shadow:0 8px 30px rgba(0,0,0,0.6)" onerror="this.src='assets/ui/card-back.png'" />
        <div id="victoryText" style="color:#e2e8f0;font-size:15px;max-width:360px"></div>
        <div style="display:flex;gap:12px;width:100%;justify-content:center;margin-top:6px">
          <button id="victoryBtnClose" class="btn" style="flex:1;background:#334155;color:#e2e8f0;">Fechar</button>
          <button id="victoryBtnReload" class="btn" style="flex:1;background:linear-gradient(135deg,#facc15 0%,#fde68a 100%);color:#7c2d12;font-weight:700;">Jogar de novo</button>
        </div>
      </div>
    </div>

<!-- Script principal -->
<!-- Add a version query to force cache-bust when deploying edits -->
<script src="assets/cards/cartas.js?v=2"></script>
<script src="assets/cards/effects.js"></script>
<!-- Debug helper (temporary): log whether CARD_DEFS is loaded and show the leader entry for 'leafae' -->
<script>
  try {
    console.log('DEBUG: CARD_DEFS loaded?', !!window.CARD_DEFS);
    if (window.CARD_DEFS) {
      const l = window.CARD_DEFS.find(c => c.key === 'leafae' || (c.name && c.name.toLowerCase().includes('leafae')));
      console.log('DEBUG: leafae entry from CARD_DEFS:', l || 'NOT FOUND');
    }
  } catch (e) { console.log('DEBUG: error checking CARD_DEFS', e); }
</script>
<script>
/* =================== Util / Base =================== */

// Multiplayer flags (new) + legacy aliases for backward compatibility
const QS = new URLSearchParams(location.search);
const IS_MP   = QS.get('mode') === 'mp';
const MY_SIDE = (QS.get('side') || 'p1').toLowerCase() === 'p2' ? 'p2' : 'p1';
const OP_SIDE = MY_SIDE === 'p1' ? 'p2' : 'p1';
// legacy aliases used by older code in this file
const __URLP = QS;
const __MODE = (__URLP.get('mode') || (IS_MP ? 'mp' : 'vsia'));
const __IS_MP = IS_MP;
const __SIDE = MY_SIDE;

// Utilitário: conta cartas de um tipo em pilhas específicas
function contarCartasTipo(side, tipo, pilhas=['grave']) {
  let count = 0;
  pilhas.forEach(pilha => {
    let arr = [];
    if (pilha === 'grave') arr = STATE[side].grave;
    else if (pilha === 'ban') arr = STATE[side].ban;
    else if (pilha === 'hand') arr = STATE[side].hand;
    arr.forEach(card => {
      if (card && card.tipo === tipo) count++;
    });
  });
  return count;
}
const $ = s => document.querySelector(s);
const logEl = $('#log');
// Logging helpers
function appendLogLine(text, cls){ try{ const d=document.createElement('div'); d.className='logLine' + (cls? ' '+cls : ''); d.innerHTML = `[${STATE && STATE.active==='you'?'Você':'IA'}] ${text}`; if(logEl) logEl.prepend(d); }catch(e){ console.warn('appendLogLine error', e); } }
function logDice(text){ appendLogLine(text, 'dice'); console.log('[dice]', text); }
function logEffect(text){ appendLogLine(text, 'effect'); console.log('[effect]', text); }
function logAttackResult(hit, text){ appendLogLine(text, hit? 'hit':'miss'); console.log('[attack]', hit? 'HIT':'MISS', text); }
// Legacy: keep log(...) as console-only (won't appear in UI) to avoid cluttering the log panel
function log(msg){ try{ console.log('[log]', msg); }catch(e){} }
function rnd(n){ try{ const r = (window.RNG && typeof window.RNG.random === 'function') ? window.RNG.random() : Math.random(); return Math.floor(r * n); }catch(e){ return Math.floor(Math.random()*n); } }
const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));
const zoomRange = document.getElementById('zoomRange');

// Garante que o tabuleiro caiba verticalmente na viewport, ajustando --zoom para o máximo possível sem cortar a mão
function ensureBoardFits(syncSliderAndPersist = false){
  const board = document.querySelector('.board');
  if(!board) return;
  const root = document.documentElement;
  const prevZoom = parseFloat(getComputedStyle(root).getPropertyValue('--zoom')) || 1;
  // aplicamos zoom 1.0 temporariamente para medir altura "natural"
  root.style.setProperty('--zoom','1');
  requestAnimationFrame(()=>{
    const topbar = document.querySelector('.topbar');
    const topbarH = topbar ? topbar.getBoundingClientRect().height : 0;
    const naturalH = board.getBoundingClientRect().height; // com zoom=1
    const availableH = window.innerHeight - topbarH - 20; // margem de respiro
    const fitZoom = Math.min(1, availableH / Math.max(1, naturalH));
    const userZoom = zoomRange ? parseFloat(zoomRange.value) : prevZoom;
    const finalZoom = Math.max(0.75, Math.min(userZoom || 1, fitZoom || 1)); // evita ficar muito pequeno
    root.style.setProperty('--zoom', String(finalZoom));
    if (syncSliderAndPersist && zoomRange){
      zoomRange.value = String(finalZoom);
      try { localStorage.setItem('mytragor_zoom', String(finalZoom)); } catch {}
    }
  });
}

if (zoomRange) {
  // Aplicar valor persistido, se houver
  try {
    const savedZoom = localStorage.getItem('mytragor_zoom');
    if (savedZoom) {
      document.documentElement.style.setProperty('--zoom', savedZoom);
      zoomRange.value = savedZoom;
    }
  } catch {}
  // Atualizar variável CSS e persistir
  zoomRange.oninput = (e) => {
    const v = e.target.value;
    document.documentElement.style.setProperty('--zoom', v);
    // após ajuste manual, garantir que caiba na viewport (sem aumentar além do possível)
    ensureBoardFits(true);
  };
}

// Ajuste automático ao carregar e ao redimensionar a janela
window.addEventListener('load', () => ensureBoardFits(true));
window.addEventListener('resize', () => {
  // debounce simples
  clearTimeout(window.__fitZoomTO);
  window.__fitZoomTO = setTimeout(()=>ensureBoardFits(false), 120);
});

/* =================== Arena responsive scaler =================== */
(function(){
  const root = document.documentElement;
  function recalcArenaScale(){
    try{
      const leftWraw = getComputedStyle(root).getPropertyValue('--left-w') || '360px';
      const leftW = parseFloat(leftWraw) || 360;
      const topbar = document.querySelector('.topbar');
      const topH = topbar ? topbar.getBoundingClientRect().height : 0;
      const gap = 24; // grid gap + padding allowance
      const availW = Math.max(320, window.innerWidth - leftW - gap);
      const availH = Math.max(300, window.innerHeight - topH - 24);
      const logicalW = parseFloat(getComputedStyle(root).getPropertyValue('--arena-w')) || 1600;
      const logicalH = parseFloat(getComputedStyle(root).getPropertyValue('--arena-h')) || 900;
      let scale = Math.min(availW / logicalW, availH / logicalH);
      if(!isFinite(scale) || scale <= 0) scale = 1;
      // clamp to reasonable bounds so UI doesn't explode on ultra-wide monitors
      scale = Math.max(0.45, Math.min(scale, 1.4));
      root.style.setProperty('--scale', String(scale));
      // update boardStage transform (inline style as fallback)
      const stage = document.getElementById('boardStage');
      if(stage) stage.style.transform = `scale(${scale})`;

      // Scale card vars so slot grid uses proportional sizes
  const baseCardW = parseFloat(getComputedStyle(root).getPropertyValue('--cardW-base')) || 75;
  const baseCardH = parseFloat(getComputedStyle(root).getPropertyValue('--cardH-base')) || 106;
  root.style.setProperty('--cardW', Math.round(baseCardW * scale) + 'px');
  root.style.setProperty('--cardH', Math.round(baseCardH * scale) + 'px');

      // Ensure the internal zoom logic re-evaluates to avoid clipping of hand, etc.
      try{ ensureBoardFits(false); }catch(e){}
      // Debug
      // console.log('recalcArenaScale', { scale, availW, availH, leftW, topH });
    }catch(e){ console.warn('recalcArenaScale error', e); }
  }
  window.addEventListener('resize', ()=>{ clearTimeout(window.__arenaScaleTO); window.__arenaScaleTO = setTimeout(recalcArenaScale, 110); });
  window.addEventListener('orientationchange', recalcArenaScale);
  window.addEventListener('load', ()=>{ setTimeout(recalcArenaScale, 60); });
  // Expose for manual debugging
  window.recalcArenaScale = recalcArenaScale;
})();

/* Imagens */
// Build chosen images map from CARD_DEFS leaders so leaders are centralized in cartas.js
function _slugKey(name){ return String(name||'').toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,''); }
const CHOSEN_IMAGES = (function(){
  const map = {};
  try{
    (window.CARD_DEFS || []).filter(c=>c.kind === 'leader').forEach(l => {
      const k = l.key || _slugKey(l.name);
      map[k] = l.img || '';
    });
  }catch(e){ /* ignore */ }
  return map;
})();

function getLeaderOpts(){
  try{
    return (window.CARD_DEFS || []).filter(c=>c.kind==='leader').map(l => ({ key: l.key || _slugKey(l.name), name: l.name, ac: l.ac||13, hp: l.hp||20, maxHp: l.maxHp||l.hp||20, atkBonus: l.atkBonus||0, damage: l.damage||0, filiacao: l.filiacao||'', classe: l.classe||'', tipo: l.tipo||'', img: l.img }));
  }catch(e){ return [] }
}
const CARD_BACK = 'assets/ui/card-back.png';
const FALLBACK_BACK = 'data:image/svg+xml;utf8,'+encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="260" height="360"><rect width="100%" height="100%" rx="14" ry="14" fill="#0b0b0b"/><rect x="8" y="8" width="244" height="344" rx="12" ry="12" stroke="#f9d34a" stroke-width="4" fill="none"/><text x="50%" y="54%" fill="#f9d34a" font-family="Georgia, serif" font-weight="700" font-size="30" text-anchor="middle">Mytragor</text></svg>`);

// Simple deterministic RNG (Mulberry32)
window.RNG = window.RNG || (function(){
  let seed = 1;
  function setSeed(s){ seed = Number(s) || 1; }
  function getSeed(){ return seed; }
  function random(){
    // Mulberry32
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  return { setSeed, getSeed, random, get currentSeed(){ return seed; } };
})();

// card id generator
window._CARD_UID = window._CARD_UID || 0;
function generateCardId(){ window._CARD_UID = (window._CARD_UID || 0) + 1; return 'c' + (Date.now().toString(36)) + '_' + window._CARD_UID; }
function ensureCardId(card){ if(!card) return null; if(!card.id) card.id = generateCardId(); return card.id; }

/* Helpers */
const hasKw = (card, kw) => !!card?.keywords?.some(k => (k||'').toLowerCase()===kw);

// Resolve a leader definition (prefer CARD_DEFS entry when available)
function resolveLeaderDef(leader){
  if(!leader) return null;
  try{
    if(window.CARD_DEFS && leader.key){
      const f = (window.CARD_DEFS||[]).find(c=>c.key === leader.key);
      if(f) return f;
    }
    if(window.CARD_DEFS && leader.name){
      const name = String(leader.name).toLowerCase();
      const f = (window.CARD_DEFS||[]).find(c=> (c.name && c.name.toLowerCase() === name) || (c.name && name.includes(c.name.toLowerCase())) || (c.key && name.includes(c.key)) );
      if(f) return f;
    }
  }catch(e){/* ignore */}
  return leader;
}

function leaderHasEffect(leader, effectName){
  if(!leader) return false;
  const def = resolveLeaderDef(leader) || {};
  if(def.effect && def.effect === effectName) return true;
  if(def.key && def.key === effectName) return true;
  if(def.name && typeof def.name === 'string' && def.name.toLowerCase().includes(String(effectName).toLowerCase())) return true;
  return false;
}

/* Templates (com keywords) */
const TEMPLATES = {
  ally_cervo_ga_brancos: () => ({
    kind: 'ally',
    name: 'Cervo de Galhos Brancos',
    cost: 3,
    classe: 'Criatura',
    tipo: 'Animal',
    filiacao: 'Religiosa',
    ac: 6,
    hp: 3,
    maxHp: 3,
    damage: 2,
    atkBonus: 1,
    keywords: [],
    img: 'assets/allies/cervo_ga_brancos.png',
    effect: 'curar_animal',
    effectValue: 1,
    text: 'Ao entrar em campo, cura 1 de vida de outro aliado do tipo Animal.'
  }),
  ally_o_protetor: ()=>({
    kind:'ally',
    name:'O Protetor',
    cost:3,
    classe:'Cidadão',
    tipo:'Humano',
    filiacao:'Arcana',
  ac:7,
    hp:4,
    maxHp:4,
    damage:1,
    atkBonus:1,
    keywords:['bloquear'],
    img:'assets/allies/o_protetor.png',
    // Aura: +1 HP para aliados da classe Cidadão enquanto em campo
    effect: 'aura_hp',
    effectValue: 1,
    auraTarget: { classe: 'Cidadão' },
    auraScope: 'allies',
    text:'Bloquear.'
  }),
  ally_estudante_magia: ()=>({
    kind:'ally',
    name:'Estudante de Magia',
    cost:1,
    classe:'Cidadão',
    tipo:'Humano',
    filiacao:'Neutra',
    ac:6,
    hp:2,
    maxHp:2,
    damage:1,
    atkBonus:0,
    keywords:[],
    img:'assets/allies/estudante_magia.png',
    text:'—'
  }),
  // === EQUIPAMENTOS ===
  equip_espada_longavida: () => ({
    kind: 'equip',
    name: 'Espada Longavida',
    cost: 2,
    classe: 'Marcial',
    tipo: 'Equipamento',
    img: 'assets/equip/espada_longavida.png',
    atkBonus: 2,
    text: '+2 ATK para o portador.'
  }),
  equip_escudo_sagrado: () => ({
    kind: 'equip',
    name: 'Escudo Sagrado',
    cost: 2,
    classe: 'Religiosa',
    tipo: 'Equipamento',
    img: 'assets/equip/escudo_sagrado.png',
    acBonus: 2,
    text: '+2 AC para o portador.'
  }),
  equip_lamina_serrilhada: () => ({
    kind: 'equip',
    name: 'Lâmina Serralhada',
    cost: 1,
    classe: 'Marcial',
    tipo: 'Equipamento',
    filiacao: 'Marcial',
    img: 'assets/equip/lamina_serrilhada.png',
    damageBonus: 1,
    text: '+1 de dano para o portador.'
  }),

  equip_orbe_observacao: () => ({
    kind: 'equip',
    name: 'Orbe de Observação',
    cost: 4,
    classe: 'Arcana',
    tipo: 'Equipamento',
    filiacao: 'Arcana',
    img: 'assets/equip/orbe_observação.png'
  }),
  equip_manto_couro: () => ({
    kind: 'equip',
    name: 'Manto de Couro',
    cost: 1,
    classe: 'Neutra',
    tipo: 'Equipamento',
    filiacao: 'Neutra',
    img: 'assets/equip/manto_couro.png',
    acBonus: 1,
    hpBonus: 1,
    text: '+1 AC e +1 HP para o portador.'
  }),
  equip_redoma_santa: () => ({
    kind: 'equip',
    name: 'Redoma Santa',
    cost: 5,
    classe: 'Religiosa',
    tipo: 'Equipamento',
    filiacao: 'Religiosa',
    img: 'assets/equip/redoma_santa.png',
    // reduz dano recebido em 3 e dá +2 AC
    damageTakenReduction: 3,
    acBonus: 2,
    // efeito customo para curar ao equipar em aliado ferido
    effect: 'redoma_santa',
    text: 'O portador recebe −3 de dano recebido e +2 AC. Ao ser equipado em um aliado que já sofreu dano, cura todo o dano desse aliado.'
  }),
  ally_gladiador_impenetravel: ()=>({ kind:'ally', name:'Gladiador Impenetrável', cost:5, classe:'Guerreiro', tipo:'Humano', ac:8, hp:8, maxHp:8, damage:2, atkBonus:2, keywords:['bloquear','provocar'], img:'assets/allies/gladiador_impenetravel.png', filiacao:'Neutra', text:'Bloquear e Provocar.' }),
  ally_toupeira_escavadora: ()=>({ kind:'ally', name:'Toupeira Escavadora', cost:1, classe:'Criatura', tipo:'Animal', ac:5, hp:1, maxHp:1, damage:1, atkBonus:1, keywords:[], img:'assets/allies/toupeira_escavadora.png', filiacao:'Neutra', effect: 'olhar_topo', text:'Ao entrar em campo, olhe a carta do topo do seu baralho. Você pode colocá-la no topo ou no fundo do seu baralho.' }),
  ally_gladiador_ousado: ()=>({ kind:'ally', name:'Gladiador Ousado', cost:4, classe:'Guerreiro', tipo:'Humano', filiacao:'Neutra', ac:8, hp:6, maxHp:6, damage:3, atkBonus:3, keywords:['provocar'], img:'assets/allies/gladiador_ousado.png' }),
  ally_bartolomeu_inspirador: ()=>({ kind:'ally', name:'Bartolomeu, o Inspirador', cost:3, classe:'Cidadão', tipo:'Humano', ac:8, hp:5, maxHp:5, damage:3, atkBonus:3, keywords:[], img:'assets/allies/bartolomeu_inspirador.png', filiacao:'Arcana' }),
  ally_bartolomeu_inspirador: ()=>({
    kind:'ally',
    name:'Bartolomeu, o Inspirador',
    cost:3,
    classe:'Cidadão',
    tipo:'Humano',
    ac:8,
    hp:5,
    maxHp:5,
    damage:3,
    atkBonus:3,
    keywords:[],
    img:'assets/allies/bartolomeu_inspirador.png',
    filiacao:'Arcana',
    chamarEspecial: {
      classe: 'Cidadão',
      origem: ['hand'] // pode expandir para ['hand','grave','deck','ban']
    }
  }),
  ally_miliciano_vila: ()=>({ kind:'ally', name:'Miliciano da Vila', cost:2, classe:'Cidadão', tipo:'Humano', ac:6, hp:2, maxHp:2, damage:2, atkBonus:2, keywords:[], img:'assets/allies/miliciano_vila.png', filiacao:'Neutra' }),
  ally_informante_beco: ()=>({ kind:'ally', name:'Informante do Beco', cost:2, classe:'Cidadão', tipo:'Elfo', ac:5, hp:2, maxHp:2, damage:2, atkBonus:2, keywords:[], img:'assets/allies/informante_beco.png', filiacao:'Neutra', effect: 'olhar_topo', text:'Ao entrar em campo, olhe a carta do topo do seu baralho. Você pode colocá-la no topo ou no fundo do seu baralho.' }),
  ally_cervo_galhos_brancos: ()=>({ kind:'ally', name:'Cervo de Galhos Brancos', cost:3, classe:'Criatura', tipo:'Animal', ac:6, hp:3, maxHp:3, damage:2, atkBonus:1, keywords:[], img:'assets/allies/cervo_ga_brancos.png', filiacao:'Religioso', effect: 'curar_animal', effectValue: 1, text:'Ao entrar em campo, cura 1 de vida de outro aliado Animal que tenha tomado dano.' }),
  ally_urso_negro_tanque: ()=>({ kind:'ally', name:'Urso Negro Tanque', cost:5, classe:'Criatura', tipo:'Animal', ac:11, hp:5, maxHp:5, damage:5, atkBonus:5, keywords:[], img:'assets/allies/urso_N_tanque.png', filiacao:'Neutra' }),
  ally_ogro_montanha: ()=>({ kind:'ally', name:'Ogro da Montanha', cost:6, classe:'Criatura', tipo:'Monstro', ac:5, hp:4, maxHp:4, damage:5, atkBonus:3, keywords:['atropelar'], img:'assets/allies/ogro_montanha.png', filiacao:'Neutra' }),
  ally_defensor: ()=>({ kind:'ally', name:'Defensor', cost:2, classe:'Marcial', tipo:'Aliado', filiacao:'Marcial', ac:12, hp:5, maxHp:5, damage:1, atkBonus:0, keywords:['provocar'] }),
  ally_agressor: ()=>({ kind:'ally', name:'Agressor', cost:3, classe:'Marcial', tipo:'Aliado', filiacao:'Marcial', ac:12, hp:4, maxHp:4, damage:2, atkBonus:2, keywords:['atropelar'] }),
  ally_blocker:  ()=>({ kind:'ally', name:'Guardião', cost:1, classe:'Sombras', tipo:'Aliado', filiacao:'Sombras', ac:12, hp:3, maxHp:3, damage:1, atkBonus:1, keywords:['bloquear'] }),
  spell_quebra_aco: () => ({
    kind: 'spell',
    name: 'Quebra-Aço',
    cost: 1,
    classe: 'Neutra',
    tipo: 'Magia',
    filiacao: 'Neutra',
    img: 'assets/spell/quebra_aco.png',
    effect: 'destroy_equip',
    text: 'Destrua um equipamento em campo.'
  }),

  spell_maos_flamejantes: () => ({
    kind: 'spell',
    name: 'Mãos Flamejantes',
    cost: 2,
    classe: 'Arcana',
    tipo: 'Magia',
    filiacao: 'Arcana',
  img: 'assets/spell/Maos_flamejantes.png',
    effect: 'dano_2_inimigo',
    text: 'Cause 2 de dano a um inimigo.'
  }),
  env_caminho_sombras:      ()=>({ kind:'env', name:'Caminho das Sombras', cost:3, classe:'Sombras',  tipo:'Ambiente', filiacao:'Sombras',  img:'assets/envs/caminho_sombras.png',      text:'Enquanto ativa, jogadores não-Sombra têm -1 ação no turno.', effect:'sombra_penalty' }),
  env_catedral_ensolarada:  ()=>({ kind:'env', name:'Catedral Ensolarada', cost:3, classe:'Religiosa',tipo:'Ambiente', filiacao:'Religioso',img:'assets/envs/catedral_ensolarada.png',  text:'No início do turno, se o Escolhido for Religioso, um aliado recebe -1 de dano até o próximo turno.', effect:'religioso_protecao' }),
  env_campos_ensanguentados:()=>({ kind:'env', name:'Campos Ensanguentados', cost:4, classe:'Marcial', tipo:'Ambiente', filiacao:'Marcial',  img:'assets/envs/campos_ensanguentados.png', text:'Enquanto ativa, personagens Marciais recebem +1 de ATK.', effect:'marcial_bonus' }),
  env_tempestade_arcana:    ()=>({ kind:'env', name:'Tempestade Arcana',   cost:3, classe:'Arcana',  tipo:'Ambiente', filiacao:'Arcana',   img:'assets/envs/tempestade_arcana.png',    text:'Enquanto ativa, se o Escolhido for Arcano, compre 1 carta extra no início do turno.', effect:'arcana_draw' }),

  spell_tonico_revigorante: () => ({
    kind: 'spell',
    name: 'Tônico Revigorante',
    cost: 2,
    classe: 'Neutra',
    tipo: 'Magia',
    img: 'assets/spell/tonico_revigorante.png',
    escolha1: true,
    effectA: { type: 'heal', value: 3 },
    effectB: { type: 'draw', value: 2 },
    text: 'Escolha 1: Cure 3 de vida OU Compre 2 cartas.'
  }),

  // === TRUQUES ===
  // Truques são magias que podem ser ativadas da mão após um gatilho específico
  // Exemplo: "Conversa Fiada" — anula magia/truque do oponente

  truque_conversa_fiada: () => ({
    kind: 'truque',
    name: 'Conversa Fiada',
  cost: 1,
  classe: 'Neutra',
  tipo: 'Truque',
  filiacao: 'Arcana',
  img: 'assets/trick/conversa_fiada.png',
  effect: 'anular_magia_truque',
  text: 'Quando o oponente ativa uma magia ou truque, anule o efeito. Ativa direto da mão após o gatilho. Vai para o cemitério após a resolução.'
  }),

  ally_teste_precisao: ()=>({
    kind:'ally',
    name:'Testador de Precisão',
    cost:2,
    classe:'Guerreiro',
    tipo:'Humano',
    ac:10,
    hp:5,
    maxHp:5,
    damage:2,
    atkBonus:1,
    keywords:['precisão'],
  img:'assets/allies/agressor.png', // imagem genérica de teste
    filiacao:'Neutra',
    text:'Possui precisão: rola 2d20 e usa o maior para atacar.'
  }),
};

/* ============== Sync TEMPLATES with CARD_DEFS ============== */
function syncTemplatesWithCardDefs(){
  if(typeof TEMPLATES === 'undefined' || typeof CARD_DEFS === 'undefined') return;
  Object.keys(TEMPLATES).forEach(key => {
    try{
      const originalFactory = TEMPLATES[key];
      // call original to get template's name (some factories expect no args)
      const tmpl = (typeof originalFactory === 'function') ? originalFactory() : null;
      if(!tmpl || !tmpl.name) return;
      // find definition by name (case-insensitive)
      const def = CARD_DEFS.find(c => (c.name||'').toLowerCase() === (tmpl.name||'').toLowerCase());
      if(!def) return;
      // replace factory so returned object is def merged with template (template overrides def)
      TEMPLATES[key] = () => {
        const base = (typeof originalFactory === 'function') ? originalFactory() : {};
        const defCopy = JSON.parse(JSON.stringify(def));
        return Object.assign({}, defCopy, base);
      };
    }catch(e){ console.warn('syncTemplatesWithCardDefs error on', key, e); }
  });
}

// Execute sync now so templates include fields from CARD_DEFS (like effect/effectValue/aura*)
try{ syncTemplatesWithCardDefs(); }catch(e){console.warn('syncTemplatesWithCardDefs failed', e); }

/* Estado */
const STATE = {
  first:'you', active:'you', phase:'main',
  turnCount:{you:0, ai:0}, maxPool:{you:0, ai:0}, pool:{you:0, ai:0},
  you:{ leader:null, env:null, allies:[null,null,null,null,null], spells:[null,null,null,null,null], deck:[], hand:[], grave:[], ban:[], tokens:[] },
  ai:{  leader:null, env:null, allies:[null,null,null,null,null], spells:[null,null,null,null,null], deck:[], hand:[], grave:[], ban:[], tokens:[] }
};

// Track whether a match has been started via UI (used to change the phase action button)
window.__MATCH_STARTED = false;

// Minimal Game API used by NetController: load a full snapshot and apply to local STATE
window.Game = window.Game || {};
window.Game.loadSnapshot = function(snapshot){
  try{
    if(!snapshot) return;
    // primitive safety: clone primitive/top-level pieces into existing STATE object
    if(snapshot.first !== undefined) STATE.first = snapshot.first;
    if(snapshot.active !== undefined) STATE.active = snapshot.active;
    if(snapshot.phase !== undefined) STATE.phase = snapshot.phase;
    if(snapshot.turnCount) STATE.turnCount = Object.assign({}, snapshot.turnCount);
    if(snapshot.maxPool) STATE.maxPool = Object.assign({}, snapshot.maxPool);
    if(snapshot.pool) STATE.pool = Object.assign({}, snapshot.pool);
    if(snapshot.you){
      // copy fields into STATE.you (preserve object reference)
      Object.keys(snapshot.you).forEach(k => { STATE.you[k] = JSON.parse(JSON.stringify(snapshot.you[k])); });
    }
    if(snapshot.ai){
      Object.keys(snapshot.ai).forEach(k => { STATE.ai[k] = JSON.parse(JSON.stringify(snapshot.ai[k])); });
    }
    // Recompute visuals and derived state after applying snapshot
    try{ render(); }catch(e){ console.warn('render after loadSnapshot failed', e); }
    console.log('Game.loadSnapshot: applied snapshot from network');
  }catch(e){ console.error('Game.loadSnapshot error', e); }
};

// Small Game helper API used by multiplayer flow
// map p1/p2 to local STATE sides ('you'/'ai')
function mapToStateSide(s){
  if(!s) return s;
  s = String(s).toLowerCase();
  if(s === 'you' || s === 'ai') return s;
  if(s === 'p1' || s === 'p2'){
    return (MY_SIDE === s) ? 'you' : 'ai';
  }
  return s;
}

window.Game.createDeck = function(side, deckSpec){
  try{
    const st = mapToStateSide(side);
    if(!st) return;
    if(deckSpec && Array.isArray(deckSpec)) STATE[st].customDeck = deckSpec;
    buildDeck(st);
  }catch(e){ console.warn('Game.createDeck error', e); }
};
window.Game.shuffle = function(side){
  try{
    const st = mapToStateSide(side);
    if(!st || !STATE[st] || !Array.isArray(STATE[st].deck)) return;
    for(let i=STATE[st].deck.length-1;i>0;i--){ const j=rnd(i+1); [STATE[st].deck[i], STATE[st].deck[j]]=[STATE[st].deck[j], STATE[st].deck[i]]; }
  }catch(e){ console.warn('Game.shuffle error', e); }
};
window.Game.drawStartHand = function(side){ try{ const st = mapToStateSide(side); for(let i=0;i<5;i++) draw(st); }catch(e){ console.warn('drawStartHand error', e); } };
window.Game.drawStartHands = function(){ try{ ['you','ai'].forEach(s=>{ for(let i=0;i<5;i++) draw(s); }); }catch(e){ console.warn('drawStartHands error', e); } };
window.Game.renderEmptyBoard = function(side){ try{ const st = mapToStateSide(side); STATE[st].env=null; STATE[st].allies=[null,null,null,null,null]; STATE[st].spells=[null,null,null,null,null]; STATE[st].hand=[]; STATE[st].grave=[]; STATE[st].ban=[]; ensureDefaultFrag(st); render(); }catch(e){ console.warn('renderEmptyBoard error', e); } };
window.Game.buildSnapshot = function(){ try{ return JSON.parse(JSON.stringify(STATE)); }catch(e){ console.warn('buildSnapshot error', e); return null; } };

// Helpers to map p1/p2 (canonical) to local state sides ('you' or 'ai')
function localSideFromP(p){
  // p expected 'p1' or 'p2'
  if(!p) return null;
  p = String(p).toLowerCase();
  if(p !== 'p1' && p !== 'p2') return null;
  return (MY_SIDE === 'p1') ? (p === 'p1' ? 'you' : 'ai') : (p === 'p1' ? 'ai' : 'you');
}

function serializeBoardFor(side){
  // side is local 'you'/'ai'
  const obj = {};
  const s = STATE[side]; if(!s) return obj;
  obj.leader = s.leader ? { id: ensureCardId(s.leader), name: s.leader.name, hp: s.leader.hp, ac: s.leader.ac, tapped: !!s.leader.tapped } : null;
  obj.env = s.env ? { id: ensureCardId(s.env), name: s.env.name } : null;
  obj.allies = (s.allies||[]).map(a => a ? { id: ensureCardId(a), name: a.name, hp: a.hp, tapped: !!a.tapped } : null);
  obj.spells = (s.spells||[]).map(c => c ? { id: ensureCardId(c), name: c.name } : null);
  return obj;
}

function restoreBoardFor(side, boardObj){
  const s = STATE[side]; if(!s) return;
  try{
    s.leader = null; s.env = null; s.allies = [null,null,null,null,null]; s.spells = [null,null,null,null,null];
    if(boardObj.leader){ const c = createCardFromName(boardObj.leader.name); if(c){ c.id = boardObj.leader.id; c.hp = boardObj.leader.hp; c.tapped = boardObj.leader.tapped; s.leader = c; } }
    if(boardObj.env){ const c = createCardFromName(boardObj.env.name); if(c){ c.id = boardObj.env.id; s.env = c; } }
    (boardObj.allies||[]).forEach((slot,i)=>{ if(slot){ const c=createCardFromName(slot.name); if(c){ c.id = slot.id; c.hp = slot.hp; c.tapped = slot.tapped; s.allies[i]=c; } } });
    (boardObj.spells||[]).forEach((sp,i)=>{ if(sp){ const c=createCardFromName(sp.name); if(c){ c.id = sp.id; s.spells[i]=c; } } });
  }catch(e){ console.warn('restoreBoardFor error', e); }
}

window.Game.buildSnapshot = function(){
  try{
    const snap = { seed: (window.RNG && window.RNG.currentSeed) ? window.RNG.currentSeed : (window.RNG?window.RNG.getSeed():null), turn: (STATE.active=== (MY_SIDE==='p1'?'you':'ai') ? 'p1' : 'p2'), p1:{}, p2:{} };
    // helper to collect side data
    ['p1','p2'].forEach(p => {
      const ls = localSideFromP(p);
      const s = STATE[ls];
      const obj = {};
      obj.life = s.leader ? s.leader.hp : 0;
      obj.mana = s.pool || 0;
      obj.hand = (s.hand||[]).map(c=>({ id: ensureCardId(c), name: c.name }));
      obj.deck = (s.deck||[]).map(c=>({ id: ensureCardId(c), name: c.name }));
      obj.board = serializeBoardFor(ls);
      snap[p] = obj;
    });
    return snap;
  }catch(e){ console.warn('buildSnapshot error', e); return null; }
};

window.Game.resetBoards = function(){ try{ ['you','ai'].forEach(s=>{ STATE[s].env=null; STATE[s].allies=[null,null,null,null,null]; STATE[s].spells=[null,null,null,null,null]; STATE[s].hand=[]; STATE[s].grave=[]; STATE[s].ban=[]; STATE[s].deck=[]; }); render(); }catch(e){ console.warn('resetBoards error', e); } };

window.Game.applySnapshot = function(snap, { remote=false } = {}){
  try{
    if(!snap) return;
    if(snap.seed && window.RNG && typeof window.RNG.setSeed === 'function') window.RNG.setSeed(snap.seed);
    // clear current boards
    Game.resetBoards();
    // reconstruct decks/hands/board from snapshot
    ['p1','p2'].forEach(p => {
      const ls = localSideFromP(p);
      const data = snap[p] || {};
      if(!ls) return;
      // rebuild deck
      STATE[ls].deck = (data.deck||[]).map(e => { const c = createCardFromName(e.name); if(c) c.id = e.id; return c; }).filter(Boolean);
      // rebuild hand
      STATE[ls].hand = (data.hand||[]).map(e => { const c = createCardFromName(e.name); if(c) c.id = e.id; return c; }).filter(Boolean);
      // restore board
      restoreBoardFor(ls, data.board || {});
      // leader HP/mana
      if(data.life != null && STATE[ls].leader) STATE[ls].leader.hp = data.life;
      if(data.mana != null) STATE[ls].pool = data.mana;
    });
    // set turn
    if(snap.turn) {
      STATE.active = (snap.turn === 'p1') ? (MY_SIDE === 'p1' ? 'you' : 'ai') : (MY_SIDE === 'p1' ? 'ai' : 'you');
    }
    render();
  }catch(e){ console.warn('applySnapshot error', e); }
};

// helper used by startMatch: choose deck spec for side (uses STATE customDeck if present)
function getDeckFor(side){ try{ return STATE[side] && STATE[side].customDeck ? STATE[side].customDeck : null; }catch(e){ return null; } }


/* ===== Equip Helpers (NOVOS) ===== */
function detachEquipFromTarget(equip){
  if(!equip || !equip.equippedTo) return;
  const side = equip.equippedSide || equip.ownerSide;
  const tgt = equip.equippedTo.type === 'leader'
    ? STATE[side].leader
    : STATE[side].allies?.[equip.equippedTo.index];
  if(!tgt) return;

  if(equip.atkBonus)    tgt.atkBonus = (tgt.atkBonus||0) - equip.atkBonus;
  if(equip.acBonus)     tgt.ac       = (tgt.ac||0)       - equip.acBonus;
  if(equip.damageBonus) tgt.damage   = (tgt.damage||0)   - equip.damageBonus;
  if(equip.dmgBonus)    tgt.damage   = (tgt.damage||0)   - equip.dmgBonus;
  if(equip.damageTakenReduction) tgt.damageTakenReduction = Math.max(0,(tgt.damageTakenReduction||0) - equip.damageTakenReduction);
  if(equip.hpBonus)     tgt.hp       = Math.max(0,(tgt.hp||0) - equip.hpBonus);

  if(tgt.equipments) tgt.equipments = tgt.equipments.filter(e=>e!==equip);
}

function sendEquipToGrave(ownerSide, equip){
  if(!equip) return;
  detachEquipFromTarget(equip);
  if(typeof equip.slotIndex === 'number' && STATE[ownerSide].spells[equip.slotIndex] === equip){
    STATE[ownerSide].spells[equip.slotIndex] = null;
  } else {
    const idx = STATE[ownerSide].spells.findIndex(x=>x===equip);
    if(idx !== -1) STATE[ownerSide].spells[idx] = null;
  }
  STATE[ownerSide].grave.push(equip);
  // Trigger: alguns equipamentos têm efeito ao ir para o cemitério
  try {
    if (equip.kind === 'equip' && (equip.effect === 'on_grave_damage_leader' || equip.onGraveDamageLeader)) {
      const dmg = typeof equip.effectValue === 'number' ? equip.effectValue : (Number(equip.onGraveDamageLeader) || 2);
      const foe = ownerSide === 'you' ? 'ai' : 'you';
      if (STATE[foe].leader) {
        STATE[foe].leader.hp = Math.max(0, (STATE[foe].leader.hp||0) - dmg);
  logEffect(`${equip.name}: ao ir para o cemitério, causou ${dmg} de dano ao líder ${STATE[foe].leader.name}. (HP: ${STATE[foe].leader.hp})`);
        if (STATE[foe].leader.hp === 0) {
          showVictory(ownerSide==='you'?'Você':'IA', ownerSide);
        }
      }
    }
  } catch(e){ console.warn('equip grave trigger error', e); }
}

function cleanupEquipsOf(side, targetObj){
  if(!targetObj?.equipments?.length) return;
  const equips = [...targetObj.equipments];
  equips.forEach(eq => sendEquipToGrave(eq.ownerSide || side, eq));
}

// ===== Token compatibility: prevent tokens from being pushed to grave =====
// Tokens are ephemeral allies created by effects; when they leave the field
// they should NOT be placed in the grave. To avoid editing many push sites,
// we filter pushes into the grave arrays here.
(function(){
  // simulate an attack visually between two elements (selectors) without changing game state
  function simulateAttackDemo(attSelector, defSelector, dmg){
    try{
      const att = document.querySelector(attSelector);
      const def = document.querySelector(defSelector);
      if(!att || !def) return;
      const aRect = att.getBoundingClientRect();
      const dRect = def.getBoundingClientRect();
      const ax = aRect.left + aRect.width/2;
      const ay = aRect.top + aRect.height/2;
      const dx = dRect.left + dRect.width/2;
      const dy = dRect.top + dRect.height/2;
      const minX = Math.min(ax, dx);
      const minY = Math.min(ay, dy) - 6; // small vertical offset
      const dist = Math.hypot(dx-ax, dy-ay);
      const angle = Math.atan2(dy-ay, dx-ax) * 180 / Math.PI;

      // create line
      const line = document.createElement('div'); line.className = 'attack-line';
      line.style.left = (minX) + 'px';
      line.style.top = (minY) + 'px';
      line.style.width = dist + 'px';
      line.style.transform = `rotate(${angle}deg) scaleX(0)`;
      document.body.appendChild(line);

      // add swing to attacker and flash to defender
      att.classList.add('attack-swing');
      def.classList.add('hit-flash');

      // animate line after short delay
      requestAnimationFrame(()=>{ setTimeout(()=>{ line.style.transform = `rotate(${angle}deg) scaleX(1)`; }, 40); });

      // after reach, show damage popup and cleanup
      setTimeout(()=>{
        // damage popup
        const pop = document.createElement('div'); pop.className = 'damage-pop'; pop.textContent = '-' + (dmg||1);
        pop.style.left = (dx - 12) + 'px'; pop.style.top = (dy - 18) + 'px';
        document.body.appendChild(pop);
        // animate popup
        requestAnimationFrame(()=>{ pop.style.transform = 'translateY(-28px)'; pop.style.opacity = '0'; });
        // cleanup visual classes and elements later
        setTimeout(()=>{ pop.remove(); line.remove(); try{ att.classList.remove('attack-swing'); def.classList.remove('hit-flash'); }catch(e){} }, 900);
      }, 520);
    }catch(e){ console.warn('simulateAttackDemo error', e); }
  }

    // expose for tutorial/demo scripts
    try{ window.simulateAttackDemo = simulateAttackDemo; }catch(e){}

  try{
    const origPush = Array.prototype.push;
    Array.prototype.push = function(...items){
      try{
        // Only intercept pushes into the main grave piles
        if(this === STATE.you.grave || this === STATE.ai.grave){
          const filtered = items.filter(it => {
            if(!it) return true;
            if(it.token) {
        try{ console.log(`${it.name || 'Ficha'} deixou o campo (token) e não foi para o cemitério.`); }catch(e){}
              // Also remove token from STATE.tokens if present
              try{
                const owner = it.ownerSide || (it.owner && it.owner.side) || null;
                if (owner && STATE[owner] && Array.isArray(STATE[owner].tokens)) {
                  const idx = STATE[owner].tokens.findIndex(x => x === it);
                  if (idx !== -1) STATE[owner].tokens.splice(idx,1);
                }
              }catch(e){}
              return false; // exclude tokens from being pushed
            }
            return true;
          });
          if(filtered.length === 0) return this.length; // nothing to push
          return origPush.apply(this, filtered);
        }
      }catch(e){ /* fallthrough to default */ }
      return origPush.apply(this, items);
    };
  }catch(e){ console.warn('token grave patch failed', e); }
})();

/* ============== Render ============== */
function cardEl(card,{hand=false,onClick=null,canPlay=false,blockerReady=false,tauntProne=false,canAttack=false}={}){
  const el=document.createElement('div');
  let equipped = card && card.equip && (Array.isArray(card.equip) ? card.equip.length > 0 : true);
  el.className = 'card'
    + (hand ? ' handCard' : '')
    + (card?.tapped ? ' tap' : '')
    + (hand && canPlay ? ' canPlay' : '')
    + (blockerReady ? ' blockerReady' : '')
    + (tauntProne ? ' tauntProne' : '')
    + (equipped ? ' equippedGlow' : '');
  if (canAttack) el.className += ' canAttack';
  el.onmouseenter = ()=>inspect(card);
  if(onClick) el.onclick = e=>{ e.stopPropagation(); onClick(); };

  // If this card was just created as a token, trigger a short spawn animation on its element
  if (card && card.token && card._justCreated) {
    try {
      el.className += ' tokenSpawn';
      // remove the _justCreated marker shortly after render so future renders don't retrigger
      setTimeout(()=>{ try{ delete card._justCreated; }catch(e){} }, 900);
    } catch(e) { console.warn('token spawn animation error', e); }
  }

  const im=document.createElement('img');
  im.src = card?.faceDown ? CARD_BACK : (card?.img || CARD_BACK);
  im.onerror=()=>im.src=FALLBACK_BACK;
  el.appendChild(im);

  const facedown=!!card?.faceDown;
  if(!facedown && card?.cost!=null){
    const c=document.createElement('div'); c.className='costTag'; c.textContent='C '+card.cost; el.appendChild(c);
  }
  if(!facedown && card?.hp!=null){
    const tag=document.createElement('div'); tag.className='hpTag';
    // If this is a leader (Escolhido), style the HP seal black with green (safe) or red (low)
    try{
      if(card.kind === 'leader' || (card.key && String(card.key).toLowerCase().includes('leader'))){
        const hp = Number(card.hp) || 0;
        // 20..11 => green, 10..0 => red
        if(hp > 10) tag.classList.add('leader-safe'); else tag.classList.add('leader-low');
      }
    }catch(e){/* ignore */}
    tag.textContent='HP '+card.hp; el.appendChild(tag);
  }
  if(!facedown && card?.classe){
    const b=document.createElement('div'); b.className='badge'; b.textContent=card.classe; el.appendChild(b);
  }
  if(!facedown && card?.keywords?.length){
    if (hand) {
      const icons=document.createElement('div'); icons.className='kwIcons';
      const iconFor=(kw)=>{
        const s=String(kw||'').toLowerCase();
        if (s.includes('provocar')) return '🛡️';
        if (s.includes('bloquear')) return '✋';
        if (s.includes('atropelar')) return '🐗';
        if (s.includes('furtividade')) return '🥷';
        if (s.includes('voar')||s.includes('voo')) return '🕊️';
        return '★';
      };
      card.keywords.forEach(kw => { const e=document.createElement('span'); e.className='kw'; e.textContent=iconFor(kw); e.title=kw; icons.appendChild(e); });
      el.appendChild(icons);
    } else {
      const k=document.createElement('div'); k.className='badgeKw'; k.textContent = card.keywords.join(' • '); el.appendChild(k);
    }
  }
  // Visual indicator for protected ally (Catedral Ensolarada)
  if (!facedown && card?.protegido) {
    const prot = document.createElement('div');
    prot.className = 'protBadge';
    prot.textContent = '−1';
    prot.style.position = 'absolute';
    prot.style.top = '6px';
    prot.style.right = '6px';
    prot.style.background = '#fde68a';
    prot.style.color = '#7c2d12';
    prot.style.borderRadius = '6px';
    prot.style.padding = '2px 6px';
    prot.style.fontSize = '12px';
    prot.style.fontWeight = 'bold';
    el.appendChild(prot);
  }
  if(!facedown && (card.hpBuffProtetor||0) > 0){
    const tag=document.createElement('div'); tag.className='hpTag'; tag.textContent='HP +' + card.hpBuffProtetor; el.appendChild(tag);
  }
  // Exibe bônus de ataque temporário (Campos Ensanguentados)
  if(!facedown && card?.atkBonusTemp > 0){
    const tag=document.createElement('div'); tag.className='atkBonusTag'; tag.textContent='+ATK ' + card.atkBonusTemp; el.appendChild(tag);
  }
  // Exibe redução de dano aplicada por equipamentos (ex.: Redoma Santa)
  if(!facedown && card?.damageTakenReduction > 0){
    const tag=document.createElement('div'); tag.className='dmgRedTag'; tag.textContent='−' + card.damageTakenReduction + ' Dmg'; el.appendChild(tag);
  }
  // Exibe badge específico de Aranhas Negras (fundo preto, numeração amarela)
  if(!facedown && (card.aranhaAtkBadge||0) > 0){
    const tag=document.createElement('div'); tag.className='aranhaBadge'; tag.textContent='+' + card.aranhaAtkBadge; el.appendChild(tag);
  }
  return el;
}
function slotEl(id,label,count){ const el=document.createElement('div'); el.className='slot'; el.id=id;
  if(label){ const L=document.createElement('div'); L.className='slotLabel'; L.textContent=label; el.appendChild(L); }
  if(count!=null){ const C=document.createElement('div'); C.className='slotCount'; C.textContent=count; el.appendChild(C); }
  return el;
}
// Show a simple modal preview for any card (used for spells/tricks on the board)
function showCardModal(card, ownerSide, pile, idx){
  if(!card) return;
  let modal = document.getElementById('cardPreviewModal');
  if(!modal){
    modal = document.createElement('div');
    modal.id = 'cardPreviewModal';
    modal.className = 'modal';
    modal.style.zIndex = '200';
    document.body.appendChild(modal);
  }
  const title = card.name || 'Carta';
  const cost = (card.cost!=null)?`Custo: ${card.cost}`:'';
  const kind = card.kind || card.tipo || '';
  const text = card.text || card.description || '';
  modal.innerHTML = `
    <div class="modalBox" style="min-width:320px;max-width:520px;padding:18px;display:flex;gap:12px;align-items:flex-start;">
      <img src="${card.img||'assets/ui/card-back.png'}" alt="${title}" style="width:96px;height:134px;border-radius:8px;box-shadow:0 6px 18px #0008;object-fit:cover;" onerror="this.src='assets/ui/card-back.png'">
      <div style="flex:1;display:flex;flex-direction:column;gap:8px;">
        <div style="font-weight:700;font-size:18px;color:#f8fafc;">${title}</div>
        <div style="font-size:13px;color:#cbd5e1;">${kind} ${cost}</div>
        <div style="font-size:13px;color:#e6eef8;white-space:pre-wrap;">${text||''}</div>
        <div style="margin-top:8px;display:flex;gap:8px;justify-content:flex-end;">
          <button id="cardPreviewClose" class="btn" style="background:#334155;color:#e2e8f0;">Fechar</button>
        </div>
      </div>
    </div>`;
  modal.style.display = 'flex';
  const btn = modal.querySelector('#cardPreviewClose'); if(btn) btn.onclick = ()=>{ modal.style.display = 'none'; };
}
// aplicarEfeitoOProtetor removido - agora usamos recomputeAuras()

// Checa e aplica o efeito passivo de Leafae: sempre que UM ALIADO for curado,
// o líder Leafae ganha permanentemente +1 ATK, +1 Damage e +1 AC até o fim do jogo.
function checkLeafaeOnAllyHealed(side, healedObj){
  if(!healedObj) return;
  // When any ally is healed, apply passive buffs to cards that listen for that event.
  // Historically this handled only the leader "Leafae"; now we also support allies
  // with effect === 'ally_heal_buff' (e.g. Porco Espinho Furioso).
  // Do nothing if healedObj is falsy.
  try {
    // Leader Leafae behavior (legacy): leader gains the buff when ANOTHER ally is healed
    const leader = STATE[side].leader;
    if (leader) {
      const isLeafae = leaderHasEffect(leader, 'leafae');
      if (isLeafae && healedObj !== leader) {
        leader.atkBonus = (leader.atkBonus||0) + 1;
        leader.damage  = (leader.damage||0)  + 1;
        leader.ac      = (leader.ac||0)      + 1;
  logEffect('Leafae absorveu vigor: +1 ATK, +1 Dano, +1 AC.');
      }
    }

    // Allies that listen for ally-healed events (new behavior)
    (STATE[side].allies || []).forEach((ally) => {
      if (!ally) return;
      // Identify Porco Espinho Furioso or any card using effect 'ally_heal_buff'
      const isPorco = (ally.effect === 'ally_heal_buff') || (typeof ally.name === 'string' && ally.name.includes('Porco Espinho'));
      if (!isPorco) return;
      // Don't trigger if the healed target is the buffing ally itself
      if (healedObj === ally) return;
      // Apply permanent buffs to the ally (Porco)
      ally.atkBonus = (ally.atkBonus||0) + 1;
      ally.damage  = (ally.damage||0)  + 1;
      ally.ac      = (ally.ac||0)      + 1;
      // Increase maxHp and current hp by 1 to reflect permanent +1 HP
      ally.maxHp = (ally.maxHp||ally.hp||0) + 1;
      ally.hp = (ally.hp||0) + 1;
      // Porco-specific styled log: +1 in yellow, text in orange
      try {
        const actor = `[${STATE.active==='you'?'Você':'IA'}]`;
        const d = document.createElement('div');
        d.className = 'logLine porcoLog';
        d.innerHTML = `${actor} <span style="color:orange;font-weight:600;">${ally.name} ativou fúria:</span> ` +
                      `<span style="color:yellow;font-weight:700;">+1</span> <span style="color:orange;">ATK,</span> ` +
                      `<span style="color:yellow;font-weight:700;">+1</span> <span style="color:orange;">Dano,</span> ` +
                      `<span style="color:yellow;font-weight:700;">+1</span> <span style="color:orange;">AC</span> ` +
                      ` <span style="color:orange;">e</span> <span style="color:yellow;font-weight:700;">+1</span> <span style="color:orange;">HP</span> <span style="color:orange;">permanentemente.</span>`;
        logEl.prepend(d);
      } catch (e) { console.warn('porco log error', e); }
    });
  } catch (e) {
    console.warn('checkLeafaeOnAllyHealed error', e);
  }
}

// Chama ao renderizar o lado
function renderSide(side){
  // Aplica efeito do Orbe de Observação
  STATE[side].allies.concat([STATE[side].leader]).forEach(target => {
    if (!target || !target.equipments) return;
    target.equipments.forEach(equip => {
      if (equip.name === 'Orbe de Observação') {
        // Conta magias no cemitério do lado
        const magiasNoCemiterio = contarCartasTipo(side, 'Magia', ['grave']);
        // Remove bônus anterior, se houver
        if (equip._orbeAtkBonus) {
          target.atkBonus = (target.atkBonus||0) - equip._orbeAtkBonus;
        }
        // Aplica novo bônus
        equip._orbeAtkBonus = magiasNoCemiterio;
        target.atkBonus = (target.atkBonus||0) + magiasNoCemiterio;
      }
    });
  });
  $(`#${side}-deck-count`).textContent=String(STATE[side].deck.length);
  $(`#${side}-grave-count`).textContent=String(STATE[side].grave.length);
  $(`#${side}-ban-count`).textContent=String(STATE[side].ban.length);

  const L=$(`#${side}-leader`);L.innerHTML=''; const E=$(`#${side}-env`);E.innerHTML='';
  if(STATE[side].leader) L.appendChild(cardEl(STATE[side].leader,{onClick:()=> side==='you'&&selectLeaderAttacker(side), canAttack: canAttackCardQuiet(side, STATE[side].leader)}));
  if(STATE[side].env) E.appendChild(cardEl(STATE[side].env));

  // Deck
  const D=$(`#${side}-deck`); if(D){ [...D.querySelectorAll('.card')].forEach(n=>n.remove());
    if(STATE[side].deck.length>0){ const back=document.createElement('div'); back.className='card';
      const img=document.createElement('img'); img.src=CARD_BACK; img.onerror=()=>img.src=FALLBACK_BACK; back.appendChild(img);
      back.style.width='calc(var(--cardW) - 8px)'; back.style.height='calc(var(--cardH) - 8px)'; D.appendChild(back); }
  }

  // Cemitério (capa + overlay)
  const graveSlot = $(`#${side}-grave`);
  if(graveSlot) {
    [...graveSlot.querySelectorAll('.card')].forEach(n=>n.remove());
    [...graveSlot.querySelectorAll('.cem-overlay')].forEach(n=>n.remove());
    const grave = STATE[side].grave;
    if(grave && grave.length > 0) {
      const top = grave[grave.length-1];
      const el = cardEl({...top, tapped: false}, {});
      el.style.position = 'absolute';
      el.style.left = '0';
      el.style.top = '0';
      el.style.width = '100%';
      el.style.height = '100%';
      el.style.zIndex = '1';
      graveSlot.appendChild(el);
      const overlay = document.createElement('div');
      overlay.className = 'cem-overlay';
      overlay.style.position = 'absolute';
      overlay.style.left = '0';
      overlay.style.top = '0';
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.background = 'rgba(60,60,70,0.38)';
      overlay.style.borderRadius = '10px';
      overlay.style.zIndex = '2';
      graveSlot.appendChild(overlay);
    }
  }

  // Banidas (capa + overlay)
  const banSlot = $(`#${side}-ban`);
  if(banSlot) {
    [...banSlot.querySelectorAll('.card')].forEach(n=>n.remove());
    [...banSlot.querySelectorAll('.ban-overlay')].forEach(n=>n.remove());
    const ban = STATE[side].ban;
    if(ban && ban.length > 0) {
      const top = ban[ban.length-1];
      const el = cardEl({...top, tapped: false}, {});
      el.style.position = 'absolute';
      el.style.left = '0';
      el.style.top = '0';
      el.style.width = '100%';
      el.style.height = '100%';
      el.style.zIndex = '1';
      banSlot.appendChild(el);
      const overlay = document.createElement('div');
      overlay.className = 'ban-overlay';
      overlay.style.position = 'absolute';
      overlay.style.left = '0';
      overlay.style.top = '0';
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.background = 'rgba(180,120,255,0.28)';
      overlay.style.borderRadius = '10px';
      overlay.style.zIndex = '2';
      banSlot.appendChild(overlay);
    }
  }

  // Aliados
  const A=$(`#${side}-allies`);A.innerHTML='';
  for(let i=0;i<5;i++){
    const s=slotEl(`${side}-ally-${i}`);
    const c=STATE[side].allies[i];
    if(c) {
      const blockerReady = hasKw(c,'bloquear') && !c.tapped && c.hp>0;
      const tauntProne = hasKw(c,'provocar') && !!c.tapped && c.hp>0;
      const canAtk = canAttackCardQuiet(side, c);
      s.appendChild(cardEl({...c, tapped: !!c.tapped},{onClick:()=> side==='you'&&selectAttacker('you',i), blockerReady, tauntProne, canAttack: canAtk}));
    }
    A.appendChild(s);
  }
  // Magias/Equipamentos
  const S=$(`#${side}-spells`);S.innerHTML='';
  for(let i=0;i<5;i++){ const s=slotEl(`${side}-spell-${i}`); const c=STATE[side].spells[i]; if(c) s.appendChild(cardEl(c,{onClick:()=> showCardModal(c, side, 'spells', i)})); S.appendChild(s); }

  if(side==='you'){
    const H=$('#youHand'); H.innerHTML='';
    STATE.you.hand.forEach((c,i)=>{
      const canPlay = (STATE.pool.you >= (c.cost||0));
      H.appendChild(cardEl(c,{hand:true,onClick:()=>playFromHand('you',i),canPlay}));
    });
  } else {
    const AH=$('#aiHand'); AH.innerHTML='';
    (STATE.ai.hand||[]).forEach(()=>{ const b=document.createElement('div'); b.className='aiBack'; const img=document.createElement('img'); img.src=CARD_BACK; img.onerror=()=>img.src=FALLBACK_BACK; b.appendChild(img); AH.appendChild(b); });
  }
}

/* === Cristais de Fragmentos === */
function renderFrags(side){
  const meter = document.getElementById(`${side}-fragDock`) || document.getElementById(`${side}-frags`);
  if(!meter) return;
  meter.innerHTML = '';

  const stack = document.createElement('div');
  stack.className = 'fragStack';
  for(let i=0;i<10-STATE.pool[side];i++){
    const back = document.createElement('div');
    back.className = 'fragBack';
    const img = document.createElement('img');
    img.src = CARD_BACK;
    img.alt = 'Fragmento virado';
    back.appendChild(img);
    back.onmouseenter = ()=>inspect({name:'Fragmento',classe:'Cristal',tipo:'Recurso',img:CARD_BACK,text:'Usado para pagar custos de cartas.'});
    back.onmouseleave = ()=>inspect(null);
    stack.appendChild(back);
  }
  meter.appendChild(stack);

  const row = document.createElement('div');
  row.className = 'fragTokensRow';
  for(let i=0;i<10;i++){
    if(i < STATE.maxPool[side]){
      const card=document.createElement('div');
      card.className='fragToken';
      if(i < STATE.pool[side]){
        card.classList.add('lit');
        const img=document.createElement('img');
        img.src=getFragImage(side);
        img.onerror=()=>{ img.src='assets/fragments/FRAGMENTOS.png'; };
        img.alt='Fragmento';
        img.style.width='100%';
        img.style.height='100%';
        img.style.objectFit='cover';
        card.appendChild(img);
        card.onmouseenter = ()=>inspect({name:'Fragmento',classe:'Cristal',tipo:'Recurso',img:getFragImage(side),text:'Fragmento ativo. Usado para pagar custos de cartas.'});
        card.onmouseleave = ()=>inspect(null);
      }else{
        card.classList.add('spent');
        const img=document.createElement('img');
        img.src = CARD_BACK;
        img.alt = 'Fragmento gasto';
        img.style.width='100%';
        img.style.height='100%';
        img.style.objectFit='cover';
        card.appendChild(img);
        card.onmouseenter = ()=>inspect({name:'Fragmento',classe:'Cristal',tipo:'Recurso',img:CARD_BACK,text:'Fragmento gasto. Não pode ser usado.'});
        card.onmouseleave = ()=>inspect(null);
      }
      row.appendChild(card);
    }
  }
  meter.appendChild(row);
}

function renderHUD(){
  $('#whoActive').textContent = `Ativo — ${STATE.active==='you'?'Você':'Oponente'}`;
  const phaseName = STATE.phase==='main'?'Principal':STATE.phase==='battle'?'Combate':'Final';
  $('#phasePill').textContent = `Fase: ${phaseName}`;
  const rest = STATE.pool[STATE.active];
  const max = STATE.maxPool[STATE.active];
  const spent = Math.max(0, max - rest);
  const fragEl = $('#fragPill');
  fragEl.textContent = `Frags: ${rest}/${max} (turno)`;
  fragEl.title = `Restantes: ${rest} | Gastos: ${spent} | Max: ${max}`;

  // Atualiza a barra de fases
  try {
    const bar = document.getElementById('phaseBar');
    if (bar) {
      const items = bar.querySelectorAll('.phaseItem');
      const map = { start:0, main:1, battle:2, end:3 };
      const idx = map[STATE.phase] ?? 0;
      items.forEach((it, i) => {
        if (i === idx) it.classList.add('active'); else it.classList.remove('active');
      });
    }
    // Update the single phase action button (mirror Start / Next / End)
    try{
      const btn = document.getElementById('phaseActionBtn');
      if(btn){
        // Decide state based on whether a match has been started and current phase
        if(!window.__MATCH_STARTED){
          btn.textContent = 'Iniciar';
          btn.className = 'btn btn-start';
          btn.onclick = startMatch;
          btn.disabled = false;
        } else if (STATE.phase === 'main'){
          btn.textContent = 'Próxima Fase';
          btn.className = 'btn btn-next';
          btn.onclick = nextPhase;
          // disable if it's not the active side (optional UX) — keep enabled to match old behavior
          btn.disabled = false;
        } else {
          // battle or final -> offer 'Encerrar Turno'
          btn.textContent = 'Encerrar Turno';
          btn.className = 'btn btn-end';
          btn.onclick = endTurn;
          btn.disabled = false;
        }
      }
    }catch(e){}
  } catch {}
}

// ===== Escolha e imagens de Fragmentos =====
const FRAG_IMAGES = {
  Arcana: 'assets/fragments/fragmentos_arcano.png',
  Marcial: 'assets/fragments/fragmentos_marcial.png',
  Religioso: 'assets/fragments/fragmentos_religioso.png',
  Sombras: 'assets/fragments/fragmentos_sombras.png'
};

function resolveFragPath(p){
  try {
    if (!p) return null;
    let s = String(p).replace(/\\/g,'/');
    if (/^(https?:|data:|file:)/i.test(s)) return s; // absolute/data/file URLs
    if (s.includes('assets/fragments/')) return s;   // already correct
    // normalize common relative forms
    s = s.replace(/^(\.\.\/)+assets\/fragments\//,'assets/fragments/');
    s = s.replace(/^(\.\.\/)+fragments\//,'assets/fragments/');
    s = s.replace(/^fragments\//,'assets/fragments/');
    return s;
  } catch { return p; }
}

function getFragImage(side){
  try {
    if (STATE[side]?.fragImg) return resolveFragPath(STATE[side].fragImg) || 'assets/fragments/FRAGMENTOS.png';
    const aff = STATE[side]?.leader?.filiacao;
    if (aff && FRAG_IMAGES[aff]) return FRAG_IMAGES[aff];
  } catch {}
  // fallback genérico
  return 'assets/fragments/FRAGMENTOS.png';
}

function ensureDefaultFrag(side){
  try {
    if (STATE[side]?.fragImg) return;
    const aff = STATE[side]?.leader?.filiacao;
    STATE[side].fragImg = (aff && FRAG_IMAGES[aff]) ? FRAG_IMAGES[aff] : (FRAG_IMAGES.Arcana || 'assets/fragments/FRAGMENTOS.png');
  } catch(e) { console.warn('ensureDefaultFrag failed', e); }
}

// ===== Imagem de fundo para Ambientes na Arena =====
function envBgFor(card){
  try{
    if(!card) return null;
    // Tenta mapear pelo caminho da imagem (assets/envs/*.png)
    const src = (card.img||'').toLowerCase();
    const name = (card.name||'').toLowerCase();
    // Mapeamento explícito solicitado
    if(src.includes('catedral_ensolarada') || name.includes('catedral'))
      return 'assets/bgambientes/catedral_bg.png';
    if(src.includes('campos_ensanguentados') || name.includes('campos'))
      return 'assets/bgambientes/campos_bg.png';
    if(src.includes('caminho_sombras') || name.includes('sombras'))
      return 'assets/bgambientes/labirinto_bg.png';
    if(src.includes('tempestade_arcana') || name.includes('tempestade'))
      return 'assets/bgambientes/tempestade_bg.png';
  }catch{}
  return null; // sem fundo conhecido
}

function updateEnvArenaBackgrounds(){
  try{
    const youCard = STATE.you?.env || null;
    const aiCard  = STATE.ai?.env  || null;
    const youBg = envBgFor(youCard);
    const aiBg  = envBgFor(aiCard);

    const youEl = document.getElementById('youEnvBg');
    const opEl  = document.getElementById('opEnvBg');
    if(!youEl || !opEl) return;

    // Caso: nenhum ambiente -> esconder
    if(!youBg && !aiBg){
      youEl.style.display='none';
      opEl.style.display='none';
      youEl.style.backgroundImage='';
      opEl.style.backgroundImage='';
      return;
    }

    // Caso: apenas um ambiente -> usar a mesma imagem nas duas arenas
    const singleBg = youBg || aiBg;
    if((youBg && !aiBg) || (!youBg && aiBg)){
      const bgCss = `linear-gradient(rgba(0,0,0,0.30), rgba(0,0,0,0.30)), url(${singleBg})`;
      youEl.style.display='block';
      opEl.style.display='block';
      youEl.style.backgroundImage = bgCss;
      opEl .style.backgroundImage = bgCss;
      return;
    }

    // Caso: dois ambientes -> cada arena com seu respectivo fundo
    const youCss = `linear-gradient(rgba(0,0,0,0.30), rgba(0,0,0,0.30)), url(${youBg})`;
    const aiCss  = `linear-gradient(rgba(0,0,0,0.30), rgba(0,0,0,0.30)), url(${aiBg})`;
    youEl.style.display='block';
    opEl.style.display='block';
    youEl.style.backgroundImage = youCss;
    opEl .style.backgroundImage = aiCss;
  }catch(e){ console.warn('updateEnvArenaBackgrounds failed', e); }
}

function chooseFragmentsFor(side){
  const modal = document.createElement('div');
  modal.id = 'fragPickerModal';
  modal.style.position = 'fixed'; modal.style.inset = '0'; modal.style.background = 'rgba(0,0,0,0.8)';
  modal.style.display = 'flex'; modal.style.alignItems = 'center'; modal.style.justifyContent = 'center'; modal.style.zIndex = '9999';

  const box = document.createElement('div');
  box.style.background = '#0e1a2b'; box.style.border = '2px solid #2a3b55'; box.style.borderRadius = '16px';
  box.style.padding = '20px'; box.style.maxWidth = '760px'; box.style.color = '#e2e8f0';

  const h = document.createElement('h3'); h.textContent = side==='you' ? 'Escolha seus Fragmentos' : 'Escolha os Fragmentos da IA'; h.style.marginTop='0'; h.style.color='#facc15';
  const p = document.createElement('p'); p.textContent = 'Selecione o estilo/afilição dos seus fragmentos. Apenas estética.'; p.style.marginTop='4px'; p.style.opacity='0.9';

  const grid = document.createElement('div');
  grid.style.display = 'grid'; grid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(140px, 1fr))'; grid.style.gap = '14px'; grid.style.marginTop = '12px';

  const makeOpt = (label, imgPath) => {
    const card = document.createElement('div'); card.style.background='#182a4d'; card.style.borderRadius='12px'; card.style.padding='10px'; card.style.cursor='pointer'; card.style.border='2px solid transparent';
    const img = document.createElement('img'); img.src = imgPath; img.alt = label; img.style.width='100%'; img.style.height='120px'; img.style.objectFit='cover'; img.style.borderRadius='8px';
    const cap = document.createElement('div'); cap.textContent = label; cap.style.textAlign='center'; cap.style.marginTop='6px'; cap.style.color='#cbd5e1';
    card.onmouseover = ()=> card.style.borderColor = '#facc15';
    card.onmouseout  = ()=> card.style.borderColor = 'transparent';
  card.onclick = ()=>{ STATE[side].fragImg = imgPath; console.log(`${side==='you'?'Você':'IA'} selecionou fragmentos: ${label}.`); try{ document.body.removeChild(modal);}catch{} renderFrags(side); };
    card.appendChild(img); card.appendChild(cap); return card;
  };

  grid.appendChild(makeOpt('Arcano', FRAG_IMAGES.Arcana));
  grid.appendChild(makeOpt('Marcial', FRAG_IMAGES.Marcial));
  grid.appendChild(makeOpt('Religioso', FRAG_IMAGES.Religioso));
  grid.appendChild(makeOpt('Sombras', FRAG_IMAGES.Sombras));

  const row = document.createElement('div'); row.style.display='flex'; row.style.gap='10px'; row.style.justifyContent='center'; row.style.marginTop='14px';
  const cancel = document.createElement('button'); cancel.className='btn'; cancel.style.background='#475569'; cancel.textContent='Cancelar'; cancel.onclick=()=>{ try{ document.body.removeChild(modal);}catch{} };
  row.appendChild(cancel);

  box.appendChild(h); box.appendChild(p); box.appendChild(grid); box.appendChild(row);
  modal.appendChild(box); document.body.appendChild(modal);
}
function render(){
    // Recalcula auras e buffs dependentes do estado do campo (ex: O Protetor)
    recomputeAuras();
  // Atualiza temas de arena de acordo com a filiação dos líderes
  try { updateArenaTheme(); } catch(e) { /* ignore */ }
  // Aplica o BG dos ambientes na arena, se houver
  try { updateEnvArenaBackgrounds(); } catch(e) { /* ignore */ }
  // Render fragment stacks according to chosen images
  try { renderFrags('you'); renderFrags('ai'); } catch(e) { /* ignore */ }
    // Kornex Ronin effect: self-only, only atkBonus
    ['you','ai'].forEach(side => {
      (STATE[side].allies||[]).forEach(card => {
        if (!card || card.effect !== 'kornex_buff_per_marcial_in_play') return;
        let count = 0;
        (STATE[side].allies||[]).forEach(a => { if(a && a !== card && a.filiacao && a.filiacao.toLowerCase() === 'marcial') count++; });
        if(STATE[side].leader && STATE[side].leader !== card && STATE[side].leader.filiacao && STATE[side].leader.filiacao.toLowerCase() === 'marcial') count++;
        if(STATE[side].env && STATE[side].env.filiacao && STATE[side].env.filiacao.toLowerCase() === 'marcial') count++;
        (STATE[side].allies||[]).forEach(a => {
          if(a && Array.isArray(a.equipments)) a.equipments.forEach(eq => { if(eq && eq.filiacao && eq.filiacao.toLowerCase() === 'marcial') count++; });
        });
        if(STATE[side].leader && Array.isArray(STATE[side].leader.equipments)) STATE[side].leader.equipments.forEach(eq => { if(eq && eq.filiacao && eq.filiacao.toLowerCase() === 'marcial') count++; });
        // Remove bônus anterior (atk and damage)
        if (typeof card._kornexAtkBonus === 'number') card.atkBonus = (card.atkBonus || 0) - card._kornexAtkBonus;
        if (typeof card._kornexDmgBonus === 'number') card.damage = (card.damage || 0) - card._kornexDmgBonus;
        // Aplica novo bônus em atkBonus E em damage (Kornex: +ATK e +DANO por cada Marcial)
        const per = Number(card.effectValue || 1) || 0;
        card._kornexAtkBonus = count * per;
        card._kornexDmgBonus = count * per;
        card.atkBonus = (card.atkBonus || 0) + card._kornexAtkBonus;
        card.damage = (card.damage || 0) + card._kornexDmgBonus;
      });
    });
    // Ademais (líder Aranha Negra): ganha +1 ATK e +1 AC para cada carta "Aranhas Negras" no SEU campo
    ['you','ai'].forEach(side => {
      const leader = STATE[side].leader;
      if (!leader || !leaderHasEffect(leader, 'ademais')) return;
  // Capture previous applied value to avoid spamming logs
  const prevAdemais = (typeof leader._ademaisAtk === 'number') ? leader._ademaisAtk : 0;
  // Remove bônus anterior
  if (typeof leader._ademaisAtk === 'number') leader.atkBonus = (leader.atkBonus||0) - leader._ademaisAtk;
  if (typeof leader._ademaisAc === 'number') leader.ac = (leader.ac||0) - leader._ademaisAc;
      // Contar cartas Aranhas Negras apenas no campo do próprio líder (lado 'side')
      let count = 0;
      (STATE[side].allies||[]).forEach(a => { if (a && (a.effect === 'agiota' || (a.name && a.name.toLowerCase().includes('aranhas')))) count++; });
      if (STATE[side].leader && (STATE[side].leader.effect === 'agiota' || (STATE[side].leader.name && STATE[side].leader.name.toLowerCase().includes('aranhas')))) count++;
      if (STATE[side].env && (STATE[side].env.effect === 'agiota' || (STATE[side].env.name && STATE[side].env.name.toLowerCase().includes('aranhas')))) count++;
      // equipments on the same side
      (STATE[side].spells||[]).forEach(eq => { if (eq && (eq.effect === 'agiota' || (eq.name && eq.name.toLowerCase().includes('aranhas')))) count++; });
      leader._ademaisAtk = count;
      leader._ademaisAc = count;
      leader.atkBonus = (leader.atkBonus||0) + leader._ademaisAtk;
      leader.ac = (leader.ac||0) + leader._ademaisAc;
      // Log only when the applied bonus changes
      if (prevAdemais !== count) {
  logEffect(`${leader.name}: bônus Ademais atualizado — +${count} ATK / +${count} AC (anterior: +${prevAdemais}).`);
      }
    });
    renderSide('you');
    renderSide('ai');
    renderFrags('you');
    renderFrags('ai');
    renderHUD();
  }

  // Diagnostic: verifica se imagens referenciadas em CARD_DEFS carregam corretamente
  function checkCardImages(){
    if(!window.CARD_DEFS || !Array.isArray(window.CARD_DEFS)) return;
    window._missingCardImages = window._missingCardImages || [];
    window.CARD_DEFS.forEach(c=>{
      if(!c || !c.img) return;
      const img = new Image();
      img.onload = ()=>{
        // ok
      };
      img.onerror = ()=>{
        console.warn('Imagem não carregou:', c.name, c.img);
        window._missingCardImages.push({name:c.name, img:c.img});
      };
      img.src = c.img;
    });
  }
  // Executa checagem breve após load
  setTimeout(()=>{ try{ checkCardImages(); }catch(e){ console.warn('checkCardImages failed', e); } }, 1200);

  // Recalcula auras genéricas aplicadas por cartas em campo.
  // Estrutura:
  // - cards podem declarar campos: effect (ex: 'aura_hp' ou legado 'buff_cidadão_hp_1'),
  //   effectValue (valor numérico), auraTarget (ex: {classe:'Cidadão'}), auraScope ('allies'|'both'|'foe'), auraProp ('hp'|'atk')
  // - Esta função remove modifiers aplicados anteriormente (guardados em _auraModifiers) e reaplica tudo de forma idempotente.
  function recomputeAuras(){
    const sides = ['you','ai'];
    // Primeiro, limpar modificadores aplicados anteriormente
    sides.forEach(side => {
      const lista = (STATE[side].allies || []).concat(STATE[side].leader ? [STATE[side].leader] : []);
      lista.forEach(t => {
        if(!t) return;
        if(t._auraModifiers){
          const mod = t._auraModifiers;
          if(mod.hp){ t.maxHp = (t.maxHp || t.hp) - mod.hp; if(t.hp > t.maxHp) t.hp = t.maxHp; delete t.hpBuffProtetor; }
          if(mod.atk){ t.atkBonus = (t.atkBonus||0) - mod.atk; }
          if(mod.aranha){
            // remove aranha badge marker
            t.aranhaAtkBadge = (t.aranhaAtkBadge||0) - mod.aranha;
            if((t.aranhaAtkBadge||0) <= 0) delete t.aranhaAtkBadge;
          }
          delete t._auraModifiers;
        }
      });
    });

    // Varre todas as cartas em campo e aplica auras declaradas
    sides.forEach(side => {
      const campos = (STATE[side].allies || []).concat(STATE[side].leader ? [STATE[side].leader] : []);
      campos.forEach(c => {
        if(!c) return;
        const eff = (c.effect || '').toString().toLowerCase();
        let appliedValue = c.effectValue || 0;
        // Legacy: efeito do tipo 'buff_cidadão_hp_1' (aceita variações)
        if(!appliedValue && eff.indexOf('buff') !== -1){
          // tenta extrair número no final
          const m = eff.match(/(\d+)$/);
          appliedValue = m ? Number(m[1]) : 1;
        }
        // Detecta aura por prefixo 'aura_' ou palavras-chave
        if(eff.startsWith('aura_') || eff.includes('buff') || c.auraTarget){
          // Determina tipo de aura (prioriza explicitamente c.auraProp)
          let prop = 'hp';
          if (c.auraProp) prop = c.auraProp;
          else {
            if(eff.includes('atk')) prop = 'atk';
            if(eff.includes('hp')) prop = 'hp';
          }
          // Determine targets based on auraTarget or legacy naming
          let targetFilter = null;
              if(c.auraTarget){
            const t = c.auraTarget;
            targetFilter = (cardObj) => {
              if(!cardObj) return false;
              if(t.classe && typeof cardObj.classe === 'string' && cardObj.classe.toLowerCase().includes((t.classe||'').toLowerCase())) return true;
              if(t.tipo && typeof cardObj.tipo === 'string' && cardObj.tipo.toLowerCase().includes((t.tipo||'').toLowerCase())) return true;
              if(t.nameIncludes && typeof cardObj.name === 'string' && cardObj.name.toLowerCase().includes((t.nameIncludes||'').toLowerCase())) return true;
              return false;
            };
          } else if(eff.indexOf('cidad') !== -1){
            targetFilter = (cardObj) => cardObj && typeof cardObj.classe === 'string' && cardObj.classe.toLowerCase().includes('cid');
          } else if(eff.indexOf('animal') !== -1){
            targetFilter = (cardObj) => cardObj && cardObj.tipo && cardObj.tipo.toLowerCase().includes('animal');
          } else {
            // default: affect allies
            targetFilter = () => true;
          }

          const scope = c.auraScope || 'allies';
          // aplique aura de acordo com scope
          const applyToSide = (s) => {
            const lista = STATE[s].allies || [];
            lista.forEach(tgt => {
              if(!tgt) return;
              if(!targetFilter(tgt)) return;
              // Prepare _auraModifiers
              if(!tgt._auraModifiers) tgt._auraModifiers = { hp:0, atk:0 };
              if(prop === 'hp'){
                const val = appliedValue || 1;
                tgt._auraModifiers.hp = (tgt._auraModifiers.hp||0) + val;
                // Only increase maxHp, do NOT heal to full
                tgt.maxHp = (tgt._baseMaxHp || tgt.maxHp || tgt.hp) + val;
                // compatibilidade com UI antiga
                tgt.hpBuffProtetor = (tgt.hpBuffProtetor||0) + val;
              } else if(prop === 'atk'){
                const val = appliedValue || 1;
                tgt._auraModifiers.atk = (tgt._auraModifiers.atk||0) + val;
                tgt.atkBonus = (tgt.atkBonus||0) + val;
                // sinaliza bónus temporário de atk (para UI)
                tgt.atkBonusTemp = (tgt.atkBonusTemp||0) + val;
                // se a aura está dirigida por nome (ex: Aranhas Negras), marque badge visual específico
                if (c.auraTarget && c.auraTarget.nameIncludes) {
                  tgt._auraModifiers.aranha = (tgt._auraModifiers.aranha||0) + val;
                  tgt.aranhaAtkBadge = (tgt.aranhaAtkBadge||0) + val;
                }
              }
            });
          };

          if(scope === 'allies' || scope === 'both') applyToSide(side);
          if(scope === 'foe' || scope === 'both') applyToSide(side === 'you' ? 'ai' : 'you');
        }
      });
    });
  }

  // Aplica efeito de O Protetor na carta inspecionada, se relevante
  function aplicarBuffProtetorPreview(card, side) {
    // Verifica se há O Protetor em campo do lado
    const aliados = STATE[side]?.allies || [];
    const temProtetor = aliados.some(a => a && a.name === 'O Protetor');
    // apply protetor preview as before
    let preview = { ...card };
    if (temProtetor && card.classe === 'Cidadão') {
      preview.hpBuffProtetor = 1;
    } else {
      preview.hpBuffProtetor = 0;
    }
    // Additionally: compute Aranhas Negras aura badge for preview if any executor/aura sources present
    try {
      const aliados = STATE[side]?.allies || [];
      // find all aura sources that target nameIncludes
      const auraSources = aliados.filter(a => a && a.auraTarget && a.auraTarget.nameIncludes);
      if (auraSources.length && preview.name && typeof preview.name === 'string') {
        let sum = 0;
        auraSources.forEach(src => {
          try { sum += Number(src.effectValue) || 1; } catch(e){ sum += 1; }
        });
        // if preview.name matches any of the auraTargets, set aranhaAtkBadge
        const matches = auraSources.some(s => preview.name.toLowerCase().includes((s.auraTarget.nameIncludes||'').toLowerCase()));
        if (matches) preview.aranhaAtkBadge = sum;
      }
    } catch(e){ console.warn('aplicarBuffProtetorPreview aranha preview error', e); }
    return preview;
  }

  // Intercepta mouseover para mostrar o selo na prévia
  const inspector = document.querySelector('.inspector');
  if (inspector) {
    const bigImg = document.getElementById('bigImg');
    const bigMeta = document.getElementById('bigMeta');
    // Monkey patch inspect()
    const oldInspect = window.inspect;
    window.inspect = function(card) {
      if (!card) {
        bigImg.src = '';
        bigMeta.textContent = 'Passe o mouse sobre uma carta…\nDica: na Fase de Combate, clique no seu aliado/líder e depois no alvo (líder inimigo ou aliados deitados).';
        return;
      }
      // Detecta lado (you/ai) pelo campo
      let side = null;
      let isLeader = false;
      if (STATE.you.leader === card) { side = 'you'; isLeader = true; }
      else if (STATE.ai.leader === card) { side = 'ai'; isLeader = true; }
      else if (STATE.you.hand.includes(card) || STATE.you.allies.includes(card)) side = 'you';
      else if (STATE.ai.hand?.includes(card) || STATE.ai.allies?.includes(card)) side = 'ai';
      // Aplica buff se relevante
      let cardPreview = card;
      if (side) cardPreview = aplicarBuffProtetorPreview(card, side);
      // Corrige AC do líder na prévia
      if (isLeader) {
        cardPreview = { ...cardPreview, ac: STATE[side].leader?.ac };
      }
      bigImg.src = cardPreview.img || '';
      let meta = `${cardPreview.name || ''}\n`;
      if (cardPreview.classe) meta += `Classe: ${cardPreview.classe}\n`;
      if (cardPreview.hp != null) meta += `HP: ${cardPreview.hp}`;
      if (cardPreview.hpBuffProtetor) meta += ` (+${cardPreview.hpBuffProtetor} O Protetor)`;
      meta += '\n';
      if (cardPreview.ac != null) meta += `AC: ${cardPreview.ac}\n`;
      if (cardPreview.damage != null) meta += `Dano: ${cardPreview.damage}\n`;
      if (cardPreview.atkBonus != null) meta += `Bônus ATK: ${cardPreview.atkBonus}\n`;
      if (cardPreview.keywords?.length) meta += `Keywords: ${cardPreview.keywords.join(', ')}\n`;
      if (cardPreview.text) meta += `${cardPreview.text}\n`;
      bigMeta.textContent = meta;
    };
  }

function updateArenaTheme(){
  const mapAffToTheme = (aff) => {
    const s = String(aff||'').toLowerCase();
    if (s.includes('marcial')) return 'marcial';
    if (s.includes('arcana') || s.includes('arcano')) return 'arcano';
    if (s.includes('religio')) return 'religioso';
    if (s.includes('sombra')) return 'sombras';
    return 'arcano';
  };
  const apply = (el, aff) => {
    if (!el) return;
    const themes = ['theme-arcano','theme-marcial','theme-religioso','theme-sombras'];
    el.classList.remove(...themes);
    const t = mapAffToTheme(aff);
    el.classList.add('theme-' + t);
  };
  apply(document.getElementById('youArena'), STATE.you?.leader?.filiacao);
  apply(document.getElementById('opArena'), STATE.ai?.leader?.filiacao);
}

/* ============== Setup / Decks / Escolhido ============== */
function buildDeck(side){
  let d=[];
  
  // Usar deck personalizado se disponível (para jogador ou IA)
  if (STATE[side] && STATE[side].customDeck && Array.isArray(STATE[side].customDeck)) {
    // If this is AI, enforce filiation rules on the saved/custom deck: only leader's filiation + neutras
    let custom = STATE[side].customDeck.slice();
    if (side === 'ai') {
      try{
        let leaderF = (STATE && STATE[side] && STATE[side].leader && STATE[side].leader.filiacao) || null;
        if(!leaderF && STATE && STATE[side] && STATE[side].leader){
          const lk = STATE[side].leader.key || STATE[side].leader.name || null;
          if(lk && window.CARD_DEFS){
            const ld = CARD_DEFS.find(x => (x.key && x.key === lk) || (x.name && x.name === lk));
            if(ld) leaderF = ld.filiacao || leaderF;
          }
        }
        if(leaderF){
          const norm = s => String(s||'').toLowerCase().trim();
          const leaderNorm = norm(leaderF);
          const allowed = custom.filter(n => {
            const def = (window.CARD_DEFS||[]).find(c => c.name === n);
            if(!def) return true; // keep unknowns to avoid data loss
            const cf = norm(def.filiacao);
            return cf === leaderNorm || cf === 'neutra' || cf === '' || !def.filiacao;
          });
          if(allowed.length !== custom.length){ console.log('AI customDeck filtered to respect leader filiation:', {before: custom.length, after: allowed.length}); }
          custom = allowed;
        }
      }catch(e){ console.warn('buildDeck: failed to filter AI customDeck by filiation', e); }
    }
    custom.forEach(cardName => {
      const card = createCardFromName(cardName);
      if (card) d.push(card);
    });
  } else {
    // Deck padrão: construir a partir de `CARD_DEFS` via createCardFromName
    // Isso garante que os campos (ex: effect) venham do arquivo central `assets/cards/cartas.js`.
    const defaultDeckNames = [
      'Ogro da Montanha',
      'Miliciano da Vila','Miliciano da Vila',
      'Bartolomeu Inspirador',
      'Estudante de Magia',
      'Toupeira Escavadora','Toupeira Escavadora',
      'Informante do Beco','Informante do Beco',
      'Cervo de Galhos Brancos','Cervo de Galhos Brancos',
      'Urso Negro Tanque','Urso Negro Tanque',
  'Gladiador Impenetrável',
  'Goblin Sabotador',
    'Aranhas Negras, Agiota','Aranhas Negras, Agiota',
      'Gladiador Ousado','Gladiador Ousado','Gladiador Ousado',
      'Lâmina Serralhada',
      'Manto de Couro','Manto de Couro',
      'Orbe de Observação','Orbe de Observação',
      'Quebra-Aço','Quebra-Aço','Quebra-Aço',
      'Mãos Flamejantes','Mãos Flamejantes',
      'Tônico Revigorante','Tônico Revigorante',
      'Conversa Fiada','Conversa Fiada','Conversa Fiada','Conversa Fiada',
      'O Protetor','O Protetor',
      'Caminho das Sombras'
    ];
    defaultDeckNames.forEach(name => {
      const card = createCardFromName(name);
      if (card) d.push(card);
      else console.warn('buildDeck: carta não encontrada em CARD_DEFS:', name);
    });

    // Prefer canonical env cards from CARD_DEFS when available
    const envs = [
      createCardFromName('Catedral Ensolarada'),
      createCardFromName('Campos Ensanguentados'),
      createCardFromName('Tempestade Arcana')
    ].filter(Boolean);
    envs.forEach(e=>d.push(e));

    // Adiciona um card de teste de precisão: prefira versão em CARD_DEFS se existir,
    // senão caia para o template legacy
    const precisionTest = createCardFromName('Testador de Precisão') || TEMPLATES.ally_teste_precisao();
    if (precisionTest) d.push(precisionTest);

    // Completa até 40 cartas usando o pool canônico de CARD_DEFS (aliados/equip/spell/env/truque)
    // Para IA, aplicar regra: apenas cartas da mesma filiação do escolhido + cartas neutras
    const allowedKinds = ['ally','equip','spell','env','truque'];
    let poolCards = (window.CARD_DEFS || []).filter(c => allowedKinds.includes(c.kind));

    if (side === 'ai') {
      try{
        // tentar obter filiação do líder da IA
        let leaderF = (STATE && STATE[side] && STATE[side].leader && STATE[side].leader.filiacao) || null;
        // se líder estiver apenas como key/name, tente buscar em CARD_DEFS
        if(!leaderF && STATE && STATE[side] && STATE[side].leader){
          const lk = STATE[side].leader.key || STATE[side].leader.name || null;
          if(lk && window.CARD_DEFS){
            const ld = CARD_DEFS.find(x => (x.key && x.key === lk) || (x.name && x.name === lk));
            if(ld) leaderF = ld.filiacao || leaderF;
          }
        }
        const norm = s => String(s||'').toLowerCase().trim();
        if(leaderF){
          const leaderNorm = norm(leaderF);
          poolCards = poolCards.filter(c => {
            const cf = norm(c.filiacao);
            return cf === leaderNorm || cf === 'neutra' || cf === '' || !c.filiacao;
          });
        } else {
          // sem líder definido: prefer manter só neutras e todos para segurança
          poolCards = poolCards.filter(c => { const cf = String(c.filiacao||'').toLowerCase(); return cf === 'neutra' || !c.filiacao || cf===''; });
        }
      }catch(e){ console.warn('buildDeck: filtro de filiação da IA falhou', e); }
    }

    const pool = poolCards.map(c => c.name);
    let safeIdx = 0;
    while (d.length < 40) {
      // escolher aleatoriamente do pool para variar decks da IA
      const name = pool.length ? pool[Math.floor(Math.random() * pool.length)] : null;
      if (!name) break;
      const card = createCardFromName(name);
      if (card) d.push(card);
      else {
        // fallback para templates legacy se algo falhar
        const tmpl = [TEMPLATES.ally_agressor, TEMPLATES.ally_blocker, TEMPLATES.ally_defensor, TEMPLATES.equip_espada_longavida][safeIdx % 4];
        if (tmpl) d.push(tmpl());
      }
      safeIdx++;
    }
  }
  
  // ensure every card has a stable id
  d.forEach(c=>{ try{ ensureCardId(c); }catch(e){} });
  for(let i=d.length-1;i>0;i--){ const j=rnd(i+1); [d[i],d[j]]=[d[j],d[i]]; }
  STATE[side].deck = d;
  // Diagnostic log to help verify AI deck building rules in the browser console
  try{
    if(side === 'ai'){
      const leaderF = (STATE && STATE.ai && STATE.ai.leader && STATE.ai.leader.filiacao) || null;
      console.log('buildDeck: AI deck built. leader.filiacao=', leaderF, 'deckCount=', (STATE.ai.deck||[]).length);
      const counts = (STATE.ai.deck||[]).reduce((m,c)=>{ const f = (c && c.filiacao) ? c.filiacao : '??'; m[f]=(m[f]||0)+1; return m; },{});
      console.log('buildDeck: AI deck filiation counts:', counts);
    }
  }catch(e){ console.warn('buildDeck: diagnostic log failed', e); }
  // O líder é definido separadamente (STATE[side].leader)
}

// Unified createCardFromName: prefer CARD_DEFS (canonical), fall back to legacy TEMPLATES mapping
function createCardFromName(cardName) {
  // 1) try canonical CARD_DEFS by exact name match
  if (window.CARD_DEFS) {
    const def = CARD_DEFS.find(c => c.name === cardName);
    if (def) return JSON.parse(JSON.stringify(def));
  }

  // 2) legacy mapping for older template-based names (normalize keys)
  const cardMap = {
    'bartolomeu inspirador': TEMPLATES.ally_bartolomeu_inspirador,
    'estudante de magia': TEMPLATES.ally_estudante_magia,
    'gladiador impenetravel': TEMPLATES.ally_gladiador_impenetravel,
    'informante do beco': TEMPLATES.ally_informante_beco,
    'miliciano da vila': TEMPLATES.ally_miliciano_vila,
    'o protetor': TEMPLATES.ally_o_protetor,
    'ogro da montanha': TEMPLATES.ally_ogro_montanha,
    'toupeira escavadora': TEMPLATES.ally_toupeira_escavadora,
    'urso negro tanque': TEMPLATES.ally_urso_negro_tanque,
    'cervo de galhos brancos': TEMPLATES.ally_cervo_ga_brancos,
    'gladiador ousado': TEMPLATES.ally_gladiador_ousado,
    'catedral ensolarada': TEMPLATES.env_catedral_ensolarada,
    'caminho das sombras': TEMPLATES.env_caminho_sombras,
    'campos ensanguentados': TEMPLATES.env_campos_ensanguentados,
    'tempestade arcana': TEMPLATES.env_tempestade_arcana,
    'lamina serralhada': TEMPLATES.equip_lamina_serrilhada,
    'manto de couro': TEMPLATES.equip_manto_couro,
    'orbe de observacao': TEMPLATES.equip_orbe_observacao,
    'maos flamejantes': TEMPLATES.spell_maos_flamejantes,
    'quebra aco': TEMPLATES.spell_quebra_aco,
    'tonico revigorante': TEMPLATES.spell_tonico_revigorante,
    'conversa fiada': TEMPLATES.truque_conversa_fiada
  };

  function normalize(str) {
    return String(str || '')
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-z0-9]+/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
  }

  const normName = normalize(cardName);
  const template = cardMap[normName];
  if (template) {
    return template();
  }

  // Not found anywhere: warn and return a safe fallback
  console.warn(`Carta não encontrada: ${cardName}`);
  return TEMPLATES.ally_miliciano_vila();
}

function chooseLeader(){
  // Verificar se há decks salvos
  const savedDecks = getSavedDecks();
  if (savedDecks.length > 0) {
    showDeckSelect(savedDecks);
  } else {
    // Se não há decks salvos, obter líderes a partir de CARD_DEFS e mostrar seleção
    const opts = getLeaderOpts();
    // fallback: if for some reason there are no leader defs, keep the hardcoded small list
    if(!opts || !opts.length){
      showCharSelect([
        { key:'katsu',name:'Katsu, o Vingador',ac:12,hp:20,maxHp:20,atkBonus:4,damage:4,filiacao:'Marcial',classe:'Guerreiro',tipo:'Humano' },
        { key:'valbrak',name:'Valbrak, Herói do Povo',ac:10,hp:20,maxHp:20,atkBonus:2,damage:2,filiacao:'Arcana',classe:'Mago',tipo:'Anão' },
        { key:'leafae',name:'Leafae, Guardião',ac:10,hp:20,maxHp:20,atkBonus:2,damage:1,filiacao:'Religioso',classe:'Druida',tipo:'Elfo' },
        { key:'ademais',name:'Ademais, Aranha Negra',ac:11,hp:20,maxHp:20,atkBonus:3,damage:3,filiacao:'Sombras',classe:'Clérigo',tipo:'Humano' },
      ]);
    } else {
      showCharSelect(opts);
    }
  }
}

function showCharSelect(opts){
  const grid = document.getElementById('charGrid');
  grid.innerHTML = '';
  // reset preview
  const prevImg = document.getElementById('charPreviewImg');
  const prevName = document.getElementById('charPreviewName');
  const prevStats = document.getElementById('charPreviewStats');
  if(prevImg) prevImg.src = '';
  if(prevName) prevName.textContent = '';
  if(prevStats) prevStats.textContent = '';
  opts.forEach((c, idx) => {
    const div = document.createElement('div');
    div.className = 'charOption';
    div.style.cursor = 'pointer';
    div.onclick = function(){ selectLeader(idx, opts); hideCharSelect(); };
    div.onmouseover = function(){
      try{
        if(prevImg) prevImg.src = c.img || CHOSEN_IMAGES[c.key] || '';
        if(prevName) prevName.textContent = c.name || '';
        if(prevStats) prevStats.textContent = `AC: ${c.ac||''}  HP: ${c.hp||''}  Dano: ${c.damage||''}  Bônus: ${c.atkBonus||''}`;
      }catch(e){}
    };
    div.innerHTML = `
      <img src="${CHOSEN_IMAGES[c.key]}" alt="${c.name}">
      <h4>${c.name}</h4>
      <div class="charStats">AC: ${c.ac} | HP: ${c.hp} | Dano: ${c.damage} | Bônus: ${c.atkBonus}<br>Filiacao: ${c.filiacao}</div>
    `;
    grid.appendChild(div);
  });
  document.getElementById('charSelect').style.display = 'flex';
}

function hideCharSelect(){
  document.getElementById('charSelect').style.display = 'none';
}

function selectLeader(idx, opts){
  // Assign chosen leader to player and pick a random leader for AI from available opts
  STATE.you.leader = {...opts[idx], kind:'leader', img: opts[idx].img || CHOSEN_IMAGES[opts[idx].key]};
  const other = opts[(idx+1+rnd(Math.max(1, opts.length)))%Math.max(1, opts.length)];
  STATE.ai.leader = {...other, kind:'leader', img: other.img || CHOSEN_IMAGES[other.key]};
  // Limpar deck customizado quando usar seleção manual
  STATE.you.customDeck = null;
  render();
  // Perguntar fragmentos do jogador
  try { chooseFragmentsFor('you'); } catch(e) { console.warn('chooseFragmentsFor you failed', e); }
  // If multiplayer, let p1 broadcast the chosen initial state to the room
  try{
    if(__IS_MP && typeof __SIDE !== 'undefined' && __SIDE === 'p1' && window.NetPeer && window.NetPeer.sendSync){
      window.NetPeer.sendSync(JSON.parse(JSON.stringify(STATE)));
      console.log('selectLeader: sent SYNC_FULL to peers');
    }
  }catch(e){ console.warn('selectLeader: sync failed', e); }
}

// Funções para carregar decks salvos
function getSavedDecks() {
  const raw = localStorage.getItem('mytragor_decks');
  if (!raw) return [];
  try { return JSON.parse(raw); } catch { return []; }
}

function showDeckSelect(decks) {
  const modal = document.createElement('div');
  modal.id = 'deckSelectModal';
  Object.assign(modal.style, { position:'fixed', inset:'0', background:'rgba(0,0,0,0.7)', display:'flex', alignItems:'center', justifyContent:'center', zIndex:'9999', padding:'20px' });

  const container = document.createElement('div');
  Object.assign(container.style, { display:'flex', gap:'18px', width:'100%', maxWidth:'1000px', maxHeight:'80vh', overflow:'auto' });

  // Left preview column
  const preview = document.createElement('div');
  Object.assign(preview.style, { flex:'0 0 320px', background:'linear-gradient(180deg,#070709,#0b0b10)', border:'1px solid rgba(250,204,21,0.06)', borderRadius:'12px', padding:'14px', color:'#e2e8f0', boxShadow:'0 12px 40px rgba(0,0,0,0.7)' });
  const pvTitle = document.createElement('div'); pvTitle.textContent='Pré-visualização do Deck'; pvTitle.style.color='#facc15'; pvTitle.style.fontWeight='800'; pvTitle.style.marginBottom='10px';
  const pvImg = document.createElement('img'); pvImg.id='deckPreviewImg'; pvImg.src='assets/ui/card-back.png'; pvImg.style.width='260px'; pvImg.style.height='340px'; pvImg.style.objectFit='cover'; pvImg.style.borderRadius='8px'; pvImg.style.border='1px solid rgba(255,255,255,0.03)'; pvImg.style.boxShadow='0 10px 30px rgba(0,0,0,0.6)';
  const pvName = document.createElement('div'); pvName.id='deckPreviewName'; pvName.style.color='#facc15'; pvName.style.fontWeight='800'; pvName.style.marginTop='8px'; pvName.style.textAlign='center';
  const pvMeta = document.createElement('div'); pvMeta.id='deckPreviewMeta'; pvMeta.style.color='#9fb4d6'; pvMeta.style.fontSize='13px'; pvMeta.style.textAlign='center'; pvMeta.style.marginTop='6px';
  preview.appendChild(pvTitle); preview.appendChild(pvImg); preview.appendChild(pvName); preview.appendChild(pvMeta);

  // Right: grid of decks
  const right = document.createElement('div'); Object.assign(right.style, { flex:'1 1 auto', background:'linear-gradient(180deg,#07121b,#07111a)', borderRadius:'12px', padding:'18px', border:'1px solid rgba(255,255,255,0.02)' });
  const title = document.createElement('h2'); title.textContent='Escolher Deck Salvo'; title.style.color='#facc15'; title.style.margin='0 0 12px 0'; right.appendChild(title);

  const grid = document.createElement('div'); Object.assign(grid.style, { display:'grid', gridTemplateColumns:'repeat(auto-fit, minmax(220px, 1fr))', gap:'16px', marginBottom:'18px' });

  decks.forEach((deck, idx) => {
    const deckDiv = document.createElement('div');
    Object.assign(deckDiv.style, { background:'#0f1724', borderRadius:'12px', padding:'12px', cursor:'pointer', border:'2px solid transparent', transition:'box-shadow 160ms, transform 160ms' });
    deckDiv.onmouseover = ()=>{ deckDiv.style.boxShadow='0 12px 30px rgba(250,180,40,0.06)'; deckDiv.style.transform='translateY(-4px)'; pvImg.src = deck.leaderImg || CHOSEN_IMAGES[(deck.leader && getLeaderKey(deck.leader))||'katsu'] || 'assets/ui/card-back.png'; pvName.textContent = deck.deckName || deck.leader || 'Deck sem nome'; const total = (deck.cards?deck.cards.length:0) + (deck.leader?1:0); pvMeta.textContent = `${total} cartas • Líder: ${deck.leader || '—'}`; };
    deckDiv.onmouseout = ()=>{ deckDiv.style.boxShadow=''; deckDiv.style.transform=''; };

    const deckName = document.createElement('div'); deckName.textContent = deck.deckName || deck.leader || 'Deck sem nome'; deckName.style.color = '#facc15'; deckName.style.fontWeight='800'; deckName.style.marginBottom='6px'; deckName.style.textAlign='center';
    const leaderInfo = document.createElement('div'); leaderInfo.textContent = `Líder: ${deck.leader || '—'}`; leaderInfo.style.color='#e2e8f0'; leaderInfo.style.fontSize='13px'; leaderInfo.style.textAlign='center'; leaderInfo.style.marginBottom='6px';
    const cardCount = document.createElement('div'); const totalCards = (deck.cards ? deck.cards.length : 0) + (deck.leader ? 1 : 0); cardCount.textContent = `${totalCards} cartas${deck.leader ? ' (inclui líder)' : ''}`; cardCount.style.color='#94a3b8'; cardCount.style.fontSize='12px'; cardCount.style.textAlign='center';
    deckDiv.appendChild(deckName); deckDiv.appendChild(leaderInfo); deckDiv.appendChild(cardCount);

    deckDiv.onclick = () => { selectSavedDeck(deck); document.body.removeChild(modal); };
    grid.appendChild(deckDiv);
  });

  const buttonContainer = document.createElement('div'); Object.assign(buttonContainer.style, { display:'flex', justifyContent:'center', gap:'12px' });
  const manualButton = document.createElement('button'); manualButton.textContent = 'Escolher Líder Manualmente'; Object.assign(manualButton.style, { background:'linear-gradient(180deg,#facc15,#f59e0b)', color:'#111', border:'none', borderRadius:'8px', padding:'8px 14px', cursor:'pointer', fontWeight:'800' });
  manualButton.onclick = () => { document.body.removeChild(modal); const opts=[ { key:'katsu',name:'Katsu, o Vingador',ac:12,hp:20,maxHp:20,atkBonus:4,damage:4,filiacao:'Marcial',classe:'Guerreiro',tipo:'Humano' }, { key:'valbrak',name:'Valbrak, Herói do Povo',ac:10,hp:20,maxHp:20,atkBonus:2,damage:2,filiacao:'Arcana',classe:'Mago',tipo:'Anão' }, { key:'leafae',name:'Leafae, Guardião',ac:10,hp:20,maxHp:20,atkBonus:2,damage:1,filiacao:'Religioso',classe:'Druida',tipo:'Elfo' }, { key:'ademais',name:'Ademais, Aranha Negra',ac:11,hp:20,maxHp:20,atkBonus:3,damage:3,filiacao:'Sombras',classe:'Clérigo',tipo:'Humano' }, ]; showCharSelect(opts); };

  const cancelButton = document.createElement('button'); cancelButton.textContent = 'Cancelar'; Object.assign(cancelButton.style, { background:'#111', color:'#e2e8f0', border:'1px solid rgba(255,255,255,0.03)', borderRadius:'8px', padding:'8px 14px', cursor:'pointer' }); cancelButton.onclick = () => document.body.removeChild(modal);

  buttonContainer.appendChild(manualButton); buttonContainer.appendChild(cancelButton);
  right.appendChild(grid); right.appendChild(buttonContainer);
  container.appendChild(preview); container.appendChild(right);
  modal.appendChild(container); document.body.appendChild(modal);
}

function selectSavedDeck(deck) {
 
  // Definir o líder baseado no deck salvo
  const leaderKey = getLeaderKey(deck.leader);
  const leaderData = {
    key: leaderKey,
    name: deck.leader,
    kind: 'leader',
    img: CHOSEN_IMAGES[leaderKey] || deck.leaderImg
  };
  
  // Definir stats baseado no líder
  switch(leaderKey) {
    case 'katsu':
      leaderData.ac = 12; leaderData.hp = 20; leaderData.maxHp = 20; 
      leaderData.atkBonus = 4; leaderData.damage = 4; leaderData.filiacao = 'Marcial';
      break;
    case 'valbrak':
      leaderData.ac = 10; leaderData.hp = 20; leaderData.maxHp = 20; 
      leaderData.atkBonus = 2; leaderData.damage = 2; leaderData.filiacao = 'Arcana';
      break;
    case 'leafae':
      leaderData.ac = 10; leaderData.hp = 20; leaderData.maxHp = 20; 
      leaderData.atkBonus = 2; leaderData.damage = 1; leaderData.filiacao = 'Religioso';
      break;
    case 'ademais':
      leaderData.ac = 11; leaderData.hp = 20; leaderData.maxHp = 20; 
      leaderData.atkBonus = 3; leaderData.damage = 3; leaderData.filiacao = 'Sombras';
      break;
    default:
      // Fallback para Katsu se não encontrar
      leaderData.ac = 12; leaderData.hp = 20; leaderData.maxHp = 20; 
      leaderData.atkBonus = 4; leaderData.damage = 4; leaderData.filiacao = 'Marcial';
  }
  
  STATE.you.leader = leaderData;
  
  // Configurar deck personalizado para o jogador
  STATE.you.customDeck = deck.cards;
  // Aplicar fragmentos do deck salvo (se houver); senão perguntar
  if (deck.fragImg) {
    STATE.you.fragImg = deck.fragImg;
  } else {
    try { chooseFragmentsFor('you'); } catch(e) { console.warn('chooseFragmentsFor you failed', e); }
  }
  
  // Em MP não inicializamos um líder de IA local — o oponente humano cuida do próprio estado
  if(!__IS_MP){
    // Escolher líder aleatório para a IA a partir de CARD_DEFS
    const leaderOpts = getLeaderOpts();
    const randomLeader = leaderOpts.length ? leaderOpts[Math.floor(Math.random() * leaderOpts.length)] : null;
    if(randomLeader){
      STATE.ai.leader = { ...randomLeader, kind: 'leader', img: randomLeader.img || CHOSEN_IMAGES[randomLeader.key] };
    } else {
      // fallback hardcoded
      STATE.ai.leader = { key:'valbrak', name:'Valbrak', kind:'leader', ac:13, hp:20, maxHp:20, atkBonus:2, damage:2, filiacao:'Arcana', img: CHOSEN_IMAGES.valbrak };
    }
  }
  
  console.log(`Deck "${deck.deckName || deck.leader}" carregado! Líder: ${deck.leader}`);

  // Após escolher o deck do jogador, somente oferecer deck da IA se não for MP
  if(!__IS_MP){
    try { configureAIDeck(); } catch(e) { console.warn('configureAIDeck failed', e); }
  }
  // In MP, if we're the host (p1) broadcast full snapshot so peer can mirror leader/deck
  try{
    if(__IS_MP && typeof __SIDE !== 'undefined' && __SIDE === 'p1' && window.NetPeer && window.NetPeer.sendSync){
      window.NetPeer.sendSync(JSON.parse(JSON.stringify(STATE)));
      console.log('selectSavedDeck: sent SYNC_FULL to peers');
    }
  }catch(e){ console.warn('selectSavedDeck sync failed', e); }
}

function getLeaderKey(leaderName) {
  if (leaderName.includes('Katsu')) return 'katsu';
  if (leaderName.includes('Valbrak')) return 'valbrak';
  if (leaderName.includes('Leafae')) return 'leafae';
  if (leaderName.includes('Ademais')) return 'ademais';
  return 'katsu'; // fallback
}

// ============== Configuração de Deck da IA ==============
function configureAIDeck(){
  const saved = getSavedDecks();
  const modal = document.createElement('div');
  modal.id = 'aiDeckModal';
  modal.style.position = 'fixed';
  modal.style.top = '0';
  modal.style.left = '0';
  modal.style.width = '100vw';
  modal.style.height = '100vh';
  modal.style.background = 'rgba(0,0,0,0.8)';
  modal.style.display = 'flex';
  modal.style.alignItems = 'center';
  modal.style.justifyContent = 'center';
  modal.style.zIndex = '9999';

  const box = document.createElement('div');
  Object.assign(box.style, { background:'linear-gradient(180deg,#07121b,#07111a)', border:'1px solid rgba(250,204,21,0.08)', borderRadius:'14px', padding:'20px', maxWidth:'720px', color:'#e2e8f0', boxShadow:'0 12px 40px rgba(0,0,0,0.7)' });

  const h = document.createElement('h3'); h.textContent = 'Deck da IA'; h.style.marginTop='0'; h.style.color='#facc15'; box.appendChild(h);
  const p = document.createElement('p'); p.textContent = 'Escolha como a IA montará seu deck:'; p.style.marginBottom='12px'; box.appendChild(p);
  const row = document.createElement('div'); Object.assign(row.style, { display:'flex', gap:'12px', flexWrap:'wrap' });

  const btnRand = document.createElement('button'); btnRand.className='btn'; Object.assign(btnRand.style, { background:'linear-gradient(180deg,#facc15,#f59e0b)', color:'#111', fontWeight:'800', border:'none', padding:'10px 14px', borderRadius:'8px' }); btnRand.textContent='Aleatório (padrão)'; btnRand.onclick = ()=>{ STATE.ai.customDeck = null; console.log('IA: deck aleatório selecionado.'); document.body.removeChild(modal); };

  const btnSaved = document.createElement('button'); btnSaved.className='btn'; Object.assign(btnSaved.style, { background:'#0f1724', color:'#facc15', border:'1px solid rgba(250,204,21,0.08)', padding:'10px 14px', borderRadius:'8px' }); btnSaved.textContent='Usar um dos meus decks salvos'; btnSaved.onclick = ()=>{ document.body.removeChild(modal); showAiDeckSelect(saved); };

  const btnClose = document.createElement('button'); btnClose.className='btn'; Object.assign(btnClose.style, { background:'#111', color:'#e2e8f0', padding:'10px 14px', borderRadius:'8px', border:'1px solid rgba(255,255,255,0.02)' }); btnClose.textContent='Cancelar'; btnClose.onclick = ()=>{ document.body.removeChild(modal); };

  row.appendChild(btnRand); if (saved && saved.length) row.appendChild(btnSaved); row.appendChild(btnClose); box.appendChild(row); modal.appendChild(box); document.body.appendChild(modal);
}

function showAiDeckSelect(decks){
  const modal = document.createElement('div');
  modal.id = 'aiDeckSelectModal';
  modal.style.position = 'fixed'; modal.style.top='0'; modal.style.left='0';
  modal.style.width = '100vw'; modal.style.height='100vh';
  modal.style.background='rgba(0,0,0,0.8)'; modal.style.display='flex';
  modal.style.alignItems='center'; modal.style.justifyContent='center'; modal.style.zIndex='9999';

  const container = document.createElement('div');
  container.style.background='#0e1a2b'; container.style.borderRadius='16px';
  container.style.padding='24px'; container.style.maxWidth='80vw'; container.style.maxHeight='80vh'; container.style.overflow='auto';

  const title = document.createElement('h2');
  title.textContent = 'Escolher Deck para IA';
  title.style.color = '#facc15'; title.style.textAlign='center'; title.style.marginBottom='20px';
  container.appendChild(title);

  const grid = document.createElement('div');
  grid.style.display='grid'; grid.style.gridTemplateColumns='repeat(auto-fit, minmax(200px, 1fr))'; grid.style.gap='16px'; grid.style.marginBottom='20px';

  decks.forEach((deck)=>{
    const deckDiv = document.createElement('div');
    deckDiv.style.background='#182a4d'; deckDiv.style.borderRadius='12px'; deckDiv.style.padding='16px'; deckDiv.style.cursor='pointer'; deckDiv.style.border='2px solid transparent';
    deckDiv.onmouseover = ()=> deckDiv.style.borderColor = '#facc15';
    deckDiv.onmouseout  = ()=> deckDiv.style.borderColor = 'transparent';

    const name = document.createElement('div');
    name.textContent = deck.deckName || deck.leader || 'Deck sem nome';
    name.style.color='#facc15'; name.style.fontWeight='bold'; name.style.marginBottom='8px'; name.style.textAlign='center';
    const leaderInfo = document.createElement('div');
    leaderInfo.textContent = `Líder: ${deck.leader}`; leaderInfo.style.color='#e2e8f0'; leaderInfo.style.fontSize='14px'; leaderInfo.style.textAlign='center'; leaderInfo.style.marginBottom='8px';
    const count = document.createElement('div');
    count.textContent = `${deck.cards?deck.cards.length:0} cartas`; count.style.color='#94a3b8'; count.style.fontSize='12px'; count.style.textAlign='center';
    deckDiv.appendChild(name); deckDiv.appendChild(leaderInfo); deckDiv.appendChild(count);

    deckDiv.onclick = ()=>{ selectAiSavedDeck(deck); document.body.removeChild(modal); };
    grid.appendChild(deckDiv);
  });

  const btnRow = document.createElement('div');
  btnRow.style.textAlign='center'; btnRow.style.display='flex'; btnRow.style.justifyContent='center'; btnRow.style.gap='12px';
  const cancel = document.createElement('button'); cancel.className='btn'; cancel.style.background='#555'; cancel.style.color='#e2e8f0'; cancel.textContent='Cancelar'; cancel.onclick=()=>document.body.removeChild(modal);
  btnRow.appendChild(cancel);

  container.appendChild(grid); container.appendChild(btnRow); modal.appendChild(container); document.body.appendChild(modal);
}

function selectAiSavedDeck(deck){
  // Define líder da IA de acordo com o deck salvo
  const key = getLeaderKey(deck.leader||'');
  const data = { key, kind:'leader', img: CHOSEN_IMAGES[key] };
  switch(key){
    case 'katsu': data.name='Katsu, o Vingador'; data.ac=12; data.hp=20; data.maxHp=20; data.atkBonus=4; data.damage=4; data.filiacao='Marcial'; break;
    case 'valbrak': data.name='Valbrak, Herói do Povo'; data.ac=10; data.hp=20; data.maxHp=20; data.atkBonus=2; data.damage=2; data.filiacao='Arcana'; break;
    case 'leafae': data.name='Leafae, Guardião'; data.ac=10; data.hp=20; data.maxHp=20; data.atkBonus=2; data.damage=1; data.filiacao='Religioso'; break;
    case 'ademais': data.name='Ademais, Aranha Negra'; data.ac=11; data.hp=20; data.maxHp=20; data.atkBonus=3; data.damage=3; data.filiacao='Sombras'; break;
    default: data.name='Katsu, o Vingador'; data.ac=12; data.hp=20; data.maxHp=20; data.atkBonus=4; data.damage=4; data.filiacao='Marcial';
  }
  STATE.ai.leader = data;
  STATE.ai.customDeck = deck.cards;
  if (deck.fragImg) { STATE.ai.fragImg = deck.fragImg; } else { try { ensureDefaultFrag('ai'); } catch(e){ console.warn('ensureDefaultFrag(ai) failed', e); } }
  console.log(`IA: usando deck salvo "${deck.deckName || deck.leader}" (líder ${deck.leader}).`);
}

/* ============== Fluxo / FRAGMENTOS ============== */
function coin(){ STATE.first=(Math.random()<0.5)?'you':'ai'; STATE.active=STATE.first; STATE.turnCount.you=STATE.turnCount.ai=0; STATE.maxPool.you=STATE.maxPool.ai=0; STATE.pool.you=STATE.pool.ai=0; console.log(`${STATE.first==='you'?'Você':'IA'} começa!`); renderHUD(); }
function startMatch(){
  try{ window.__MATCH_STARTED = true; }catch(e){}
  // Offline / VS IA: behave as before
  if(!IS_MP){
    try{
      // prepare both sides
      Game.createDeck('p1', getDeckFor('p1'));
      Game.createDeck('p2', getDeckFor('p2'));
      Game.shuffle('p1'); Game.shuffle('p2');
      // ensure leaders exist (try to use CARD_DEFS definitions)
      if(!STATE.you.leader || !STATE.ai.leader){
        try{
          const leaderMap = (window.CARD_DEFS||[]).filter(c=>c.kind==='leader').reduce((m,l)=>{ m[l.key || _slugKey(l.name)] = l; return m; }, {});
          const katsu = leaderMap['katsu'];
          const valbrak = leaderMap['valbrak'];
          if(!STATE.you.leader) STATE.you.leader = katsu ? ({ ...katsu, kind:'leader' }) : { kind:'leader', name:'Katsu', img:CHOSEN_IMAGES.katsu, ac:13, hp:20, atkBonus:4, damage:4, filiacao:'Marcial' };
          if(!STATE.ai.leader) STATE.ai.leader = valbrak ? ({ ...valbrak, kind:'leader' }) : { kind:'leader', name:'Valbrak', img:CHOSEN_IMAGES.valbrak, ac:13, hp:20, atkBonus:2, damage:2, filiacao:'Arcana' };
        }catch(e){
          STATE.you.leader = {kind:'leader',name:'Katsu',img:CHOSEN_IMAGES.katsu,ac:13,hp:20,atkBonus:4,damage:4,filiacao:'Marcial'};
          STATE.ai.leader = {kind:'leader',name:'Valbrak',img:CHOSEN_IMAGES.valbrak,ac:13,hp:20,atkBonus:2,damage:2,filiacao:'Arcana'};
        }
      }
      Game.drawStartHands();
      beginTurn();
    }catch(e){ console.warn('startMatch offline error', e); }
    return;
  }

  // === Multiplayer ===
  // 2.1 Render empty layout for both sides
  try{ Game.renderEmptyBoard('p1'); Game.renderEmptyBoard('p2'); }catch(e){ console.warn('renderEmptyBoard error', e); }

  // 2.2 Create only my local deck now
  try{
    Game.createDeck(MY_SIDE, getDeckFor(MY_SIDE));
    Game.shuffle(MY_SIDE);
    Game.drawStartHand(MY_SIDE);
  }catch(e){ console.warn('startMatch create local deck error', e); }

  // 2.3 If I'm p1 (host), build authoritative snapshot and publish
  try{
    if(MY_SIDE === 'p1' && window.Net && typeof window.Net.publishState === 'function'){
      const snap = Game.buildSnapshot();
      if(snap) Net.publishState(snap);
      console.log('startMatch: host published snapshot');
    }
  }catch(e){ console.warn('startMatch publishState failed', e); }

  // Note: we do NOT call beginTurn() here — wait for host/clients to apply snapshot and proceed.
}
// keep legacy name for buttons expecting start()
const start = startMatch;
let valbrakComprouTurno = { you: false, ai: false };
function beginTurn(){
  const side=STATE.active; STATE.phase='main'; STATE.turnCount[side]++;
  // mark beginTurn in progress so we can defer UI modals until the refresh finishes
  try{ window.__BEGIN_TURN_IN_PROGRESS = true; }catch(e){}
  valbrakComprouTurno[side] = false;
  STATE.maxPool[side] = (STATE.turnCount[side]===1)?((side===STATE.first)?1:2):clamp(STATE.maxPool[side]+2,0,10);
  STATE.pool[side]=STATE.maxPool[side];
  draw(side);
  try { applyEnvEffectsOnTurnStart(side); } catch(e) { console.error('applyEnvEffectsOnTurnStart error', e); log('⚠️ Erro em ambiente: '+(e?.message||e)); }
  // Desvirar: respeita _skipNextUntap (ex.: Constrição)
  STATE[side].allies.forEach(c=>{
    if(!c) return;
    c.summonedThisTurn=false;
    if (c._skipNextUntap) { c._skipNextUntap = Math.max(0, (c._skipNextUntap||0) - 1); }
    else { c.tapped=false; }
  });
  if (STATE[side].leader){
    const L=STATE[side].leader;
    if (L._skipNextUntap) { L._skipNextUntap = Math.max(0, (L._skipNextUntap||0) - 1); }
    else { L.tapped=false; }
  }
  // Resetar usos por turno (ex: Agiota)
  STATE[side].allies.forEach(a => { if(a) a._agiotaUsed = false; });
  log(`${side==='you'?'Seu':'IA'} turno começou. Fragmentos: ${STATE.pool[side]}/${STATE.maxPool[side]}.`); render();
  // allow any deferred modals to run after the turn refresh completes
  try{ window.__BEGIN_TURN_IN_PROGRESS = false; }catch(e){}
  try{ setTimeout(function(){ if(window.processModalQueue) window.processModalQueue(); }, 60); }catch(e){}
  // Em MP, não rodar IA localmente — o oponente humano joga via NetController
  if(side==='ai' && !__IS_MP) setTimeout(()=>{ try{ aiMain(); }catch(e){ console.error(e); log('⚠️ IA (beginTurn): '+(e?.message||e)); } }, 300);
}
function nextPhase(){ if(STATE.phase==='main'){ STATE.phase='battle'; log('Fase de Combate: clique no seu aliado/líder e depois no alvo.'); } else if(STATE.phase==='battle'){ STATE.phase='final'; } else endTurn(); renderHUD(); }
// Efeito do Cervo de Galhos Brancos: cura 1 de vida de outro Animal ao final do turno
function efeitoCervoGalhosBrancos(side) {
  // Recebe posição do cervo para ativar ao entrar em campo
  const aliados = STATE[side].allies;
  const cervoIdx = aliados.findIndex(a => a && a.name === 'Cervo de Galhos Brancos');
  if (cervoIdx === -1) return;
  let curados = false;
  for (let i = 0; i < aliados.length; i++) {
    if (i !== cervoIdx && aliados[i] && aliados[i].tipo === 'Animal' && aliados[i].hp < (aliados[i].maxHp || aliados[i].hp)) {
  aliados[i].hp = Math.min((aliados[i].maxHp || aliados[i].hp), aliados[i].hp + 1);
  log(`Cervo de Galhos Brancos curou 1 de vida de ${aliados[i].name}.`);
  // Trigger Leafae passive if present
  checkLeafaeOnAllyHealed(side, aliados[i]);
      curados = true;
      break;
    }
  }
  if (!curados) {
    log('Cervo de Galhos Brancos: nenhum Animal para curar.');
  }
}
function endTurn(){ STATE.phase='main'; STATE.active=(STATE.active==='you')?'ai':'you'; beginTurn(); }

  // (Removido: efeito agora é ao entrar em campo)

/* ============== Ações básicas ============== */
function draw(side){ const c=STATE[side].deck.pop(); if(!c) return; STATE[side].hand.push(c); STATE[side].hand=STATE[side].hand.filter(Boolean); renderSide(side); console.log(`${side==='you'?'Você':'IA'} comprou uma carta.`); }
function pay(side,c){ if(STATE.pool[side]<c){ alert('Fragmentos insuficientes!'); return false; } STATE.pool[side]-=c; renderHUD(); renderFrags(side); return true; }
// Solicita pagamento em HP de um aliado ou líder quando a carta possui `costHp`
function requestHpPayment(side, index, c){
  const costHp = c.costHp || 0;
  if(!costHp) return false;
  // montar opções (lider + aliados com hp suficiente)
  let payers = [];
  if(STATE[side].leader && (STATE[side].leader.hp>0)) payers.push({ type: 'leader', obj: STATE[side].leader });
  STATE[side].allies.forEach((a,i)=>{ if(a && a.hp>0) payers.push({ type: 'ally', obj: a, slot: i }); });
  if(!payers.length){ alert('Nenhum alvo para pagar vida.'); return false; }
  // IA: escolher o payer com mais HP
  if(side === 'ai'){
    payers.sort((x,y)=> (y.obj.hp||0)-(x.obj.hp||0));
    const chosen = payers[0];
    const tgt = chosen.type === 'leader' ? STATE[side].leader : STATE[side].allies[chosen.slot];
    tgt.hp = Math.max(0, (tgt.hp||0) - costHp);
    console.log(`${side==='you'?'Você':'IA'} pagou ${costHp} HP de ${tgt.name} para ${c.name}.`);
    // remover se morreu
  if(tgt.hp===0){ logEffect(`${tgt.name} morreu ao pagar vida.`); if(chosen.type==='ally'){ cleanupEquipsOf(side, tgt); STATE[side].grave.push(tgt); STATE[side].allies[chosen.slot]=null; try{ if(typeof MYTRAGOR_EFFECTS!=='undefined'&&MYTRAGOR_EFFECTS.notifyAllySentToGrave) MYTRAGOR_EFFECTS.notifyAllySentToGrave(tgt, side); }catch(e){} } else { cleanupEquipsOf(side, tgt); STATE[side].grave.push(tgt); STATE[side].leader=null; } }
    c._hpPaid = true; setTimeout(()=> playFromHand(side, index), 10); return true;
  }
  // Jogador: mostrar escolha visual
  showCardChoice(
    payers.map(p=>({ card: p.obj, label: p.type==='leader' ? 'Líder' : 'Aliado' })),
    (chosen, idx)=>{
    if(chosen==null){ console.log(`${c.name}: pagamento de HP cancelado.`); return; }
      const sel = payers[idx];
      const tgt = sel.type==='leader' ? STATE[side].leader : STATE[side].allies[sel.slot];
      if(!tgt){ alert('Alvo não encontrado.'); return; }
    tgt.hp = Math.max(0, (tgt.hp||0) - costHp);
    console.log(`Você pagou ${costHp} HP de ${tgt.name} para ${c.name}.`);
  if(tgt.hp===0){ logEffect(`${tgt.name} morreu ao pagar vida.`); if(sel.type==='ally'){ cleanupEquipsOf(side, tgt); STATE[side].grave.push(tgt); STATE[side].allies[sel.slot]=null; try{ if(typeof MYTRAGOR_EFFECTS!=='undefined'&&MYTRAGOR_EFFECTS.notifyAllySentToGrave) MYTRAGOR_EFFECTS.notifyAllySentToGrave(tgt, side); }catch(e){} } else { cleanupEquipsOf(side, tgt); STATE[side].grave.push(tgt); STATE[side].leader=null; } }
      c._hpPaid = true; setTimeout(()=> playFromHand(side, index), 10);
    },
    `Pague ${costHp} de vida para jogar ${c.name}`
  );
  return true;
}
// ---------- Discard utilities (isolated, non-invasive) ----------
// These functions are inserted carefully and do not alter playFromHand or UI flows.
function triggerDiscardEffects(card, ownerSide, source){
  try{
    if(!card) return;
    const eff = card.discardEffect || card.effectOnDiscard || null;
    if(!eff) return;
    if(eff.type === 'draw_owner'){
      const n = Number(eff.value||1);
      for(let i=0;i<n;i++) draw(ownerSide);
      log(`${card.name}: ao ser descartada, ${ownerSide==='you'?'você':'IA'} comprou ${n} carta(s).`);
    } else if(eff.type === 'damage_enemy'){
      const dmg = Number(eff.value||1);
      const foe = ownerSide === 'you' ? 'ai' : 'you';
  if(STATE[foe].leader){ STATE[foe].leader.hp = Math.max(0, (STATE[foe].leader.hp||0) - dmg); log(`${card.name}: ao ser descartada causou ${dmg} de dano ao líder inimigo.`); if(STATE[foe].leader.hp===0) showVictory(ownerSide==='you'?'Você':'IA', ownerSide); }
    } else if(eff.type === 'fragment_gain'){
      const v = Number(eff.value||1);
      const before = STATE[ownerSide].pool||0;
      STATE[ownerSide].pool = Math.min(STATE[ownerSide].maxPool||999, before + v);
      log(`${card.name}: ao ser descartada, recuperou ${STATE[ownerSide].pool-before} fragmento(s).`);
    } else if(eff.type === 'discard_enemy_random'){
      const n = Number(eff.value||1);
      const foe = ownerSide === 'you' ? 'ai' : 'you';
      const removed = discardRandomFromHand(foe, n, { sourceSide: ownerSide, sourceCard: card, reason: 'discardEffect' });
      log(`${card.name}: ao ser descartada, forçou ${foe==='ai'?'a IA':'você'} a descartar ${removed} carta(s).`);
    }
  }catch(e){ console.warn('triggerDiscardEffects error', e); }
}

function discardCardFromHand(ownerSide, handIndex, opts){
  try{
    if(!Array.isArray(STATE[ownerSide].hand)) return false;
    if(typeof handIndex !== 'number' || handIndex < 0 || handIndex >= STATE[ownerSide].hand.length) return false;
    const card = STATE[ownerSide].hand[handIndex];
    if(!card) return false;
    // remove from hand and send to grave
    STATE[ownerSide].hand.splice(handIndex, 1);
    STATE[ownerSide].grave.push(card);
    const actorName = opts && opts.actorName ? opts.actorName : (ownerSide==='you'?'Você':'IA');
    const reason = opts && opts.reason ? opts.reason : 'descarte';
    log(`${actorName}: ${card.name} foi descartada (${reason}).`);
    // trigger any on-discard effects
    triggerDiscardEffects(card, ownerSide, opts || {});
    render();
    return true;
  }catch(e){ console.warn('discardCardFromHand error', e); return false; }
}

function discardRandomFromHand(ownerSide, count=1, opts){
  try{
    const hand = STATE[ownerSide].hand || [];
    if(!hand.length) return 0;
    let removed = 0;
    for(let i=0;i<count;i++){
      if((STATE[ownerSide].hand||[]).length===0) break;
      const idx = Math.floor(Math.random() * STATE[ownerSide].hand.length);
      const ok = discardCardFromHand(ownerSide, idx, opts || {});
      if(ok) removed++; else break;
    }
    return removed;
  }catch(e){ console.warn('discardRandomFromHand error', e); return 0; }
}

// Debug helper: inject a card into a side's hand and immediately self-discard it (safe test without touching play flow)
function debug_inject_and_self_discard(side, cardName){
  try{
    const c = createCardFromName(cardName);
    if(!c){ log('debug: carta não encontrada: '+cardName); return; }
    STATE[side].hand.push(c);
    render();
    const idx = STATE[side].hand.length-1;
    // simulate paying cost minimally if needed
    const cost = c.cost || 0;
    if((STATE.pool[side]||0) >= cost) STATE.pool[side] -= cost;
    log(`debug: injetada ${c.name} na mão de ${side} e simulando self-discard.`);
    discardCardFromHand(side, idx, { sourceSide: side, sourceCard: c, reason: 'debug_self_discard', actorName: side==='you'?'Você':'IA' });
  }catch(e){ console.warn('debug_inject_and_self_discard error', e); }
}

// Solicita usar o efeito "agiota" de um aliado (pagar 2 HP do aliado para cobrir custo <=3)
function requestAgiotaPayment(side, index, c){
  // só aplica para cartas custo <=3
  if((c.cost||0) > 3) return false;
  // coletar aliados com efeito 'agiota' e que ainda não usaram este turno e têm hp>=2
  const candidates = [];
  STATE[side].allies.forEach((a,i)=>{ if(a && a.effect==='agiota' && !(a._agiotaUsed) && (a.hp||0) >= 2) candidates.push({ obj: a, slot: i }); });
  if(!candidates.length) return false;
  // IA heurística: usar se fragments insuficientes
  if(side === 'ai'){
  if(STATE.pool[side] >= (c.cost||0)) return false; // has fragments, don't steal
    const pick = candidates[0];
    pick.obj.hp = Math.max(0, (pick.obj.hp||0) - 2);
    pick.obj._agiotaUsed = true;
    log(`IA usou Agiota de ${pick.obj.name} para pagar HP e jogar ${c.name}.`);
    // handle death
  if(pick.obj.hp === 0){ log(`${pick.obj.name} morreu ao pagar vida.`); cleanupEquipsOf(side, pick.obj); STATE[side].grave.push(pick.obj); STATE[side].allies[pick.slot]=null; try{ if(typeof MYTRAGOR_EFFECTS!=='undefined'&&MYTRAGOR_EFFECTS.notifyAllySentToGrave) MYTRAGOR_EFFECTS.notifyAllySentToGrave(pick.obj, side); }catch(e){} }
    c._agiotaPaid = true; setTimeout(()=> playFromHand(side, index), 10); return true;
  }
  // Jogador: oferecer modal para escolher usar agiota (se houver candidatos)
  showCardChoice(
    candidates.map(p => ({ card: p.obj, label: 'Agiota' })),
    (chosen, idx)=>{
      if(chosen==null){ log(`${c.name}: uso de Agiota cancelado.`); return; }
      const pick = candidates[idx];
      if(!pick) return;
      pick.obj.hp = Math.max(0, (pick.obj.hp||0) - 2);
      pick.obj._agiotaUsed = true;
      log(`Você usou Agiota de ${pick.obj.name} para pagar 2 HP e jogar ${c.name}.`);
  if(pick.obj.hp === 0){ log(`${pick.obj.name} morreu ao pagar vida.`); cleanupEquipsOf(side, pick.obj); STATE[side].grave.push(pick.obj); STATE[side].allies[pick.slot]=null; try{ if(typeof MYTRAGOR_EFFECTS!=='undefined'&&MYTRAGOR_EFFECTS.notifyAllySentToGrave) MYTRAGOR_EFFECTS.notifyAllySentToGrave(pick.obj, side); }catch(e){} }
      c._agiotaPaid = true; setTimeout(()=> playFromHand(side, index), 10);
    },
    `Usar Agiota para pagar 2 HP e jogar ${c.name}?`
  );
  return true;
}
function playFromHand(side, index) {

  if (STATE.active !== side || STATE.phase !== 'main') return;
  const c = STATE[side].hand[index]; if (!c) return;
  // Se a carta tem custo em HP (costHp), solicitar pagamento de HP antes de prosseguir
  if (c.costHp && !c._hpPaid) { requestHpPayment(side, index, c); return; }
  // Se não há fragmentos suficientes, tente usar Agiota (se disponível)
  const cardCost = c.cost || 0;
  // Player pode optar por usar Agiota mesmo tendo fragmentos
  if (cardCost > 0) {
    // construir lista de candidatos Agiota (mesma lógica de requestAgiotaPayment)
    const agiotaCandidates = [];
    STATE[side].allies.forEach((a,i)=>{ if(a && a.effect==='agiota' && !(a._agiotaUsed) && (a.hp||0) >= 2) agiotaCandidates.push({ obj: a, slot: i }); });
    if (side === 'you' && agiotaCandidates.length > 0) {
      // perguntar ao jogador se quer usar Agiota em vez de pagar fragmentos
      try {
        if (confirm(`Usar Agiota para pagar 2 HP de um aliado e jogar ${c.name} em vez de gastar ${cardCost} fragmentos?`)) {
          if (requestAgiotaPayment(side, index, c)) return;
        }
      } catch(e){ /* em ambientes sem confirm, ignore */ }
    }
    if (STATE.pool[side] < cardCost) {
      // requestAgiotaPayment retorna true se iniciou o fluxo (player modal ou AI auto), então interrompemos
      if (requestAgiotaPayment(side, index, c)) return;
    }
  }
  // pagar fragmentos normalmente
  // If Agiota was used to pay instead of fragments, skip paying fragments
  if (c._agiotaPaid) {
    // clear the flag for safety after use
    delete c._agiotaPaid;
  } else {
    if (!pay(side, cardCost)) return;
  }

  // --- Intercepta magias/truques do oponente com Conversa Fiada ---
  // Comportamento:
  // - Se a IA está jogando (side === 'ai'), o jogador humano pode responder com o modal de Conversa Fiada (existente).
  // - Se o jogador está jogando (side === 'you') e a IA tem Conversa Fiada na mão, a IA pode usar automaticamente para anular.
  if ((c.kind === 'spell' || c.kind === 'truque')) {
    // Caso: IA jogando -> mostrar modal para o jogador usar Conversa Fiada
    if (side === 'ai') {
      const idxFiada = STATE['you'].hand.findIndex(card => card && card.name === 'Conversa Fiada');
      if (idxFiada !== -1 && !c._fiadaCheck) {
        let modal = document.getElementById('conversaFiadaModal');
        if (modal && window.enqueueModal) {
          // enqueue modal display so it won't collide with other modals (e.g., during fragment renewal)
          enqueueModal(function(done){
            try{ window.__WAITING_FOR_MODAL = true; }catch(e){}
            modal.style.display = 'flex';
            var custo = 0;
            if (STATE['you'].hand[idxFiada] && STATE['you'].hand[idxFiada].cost) {
              custo = STATE['you'].hand[idxFiada].cost;
            }
            var cfCusto = document.getElementById('cfCusto');
            if (cfCusto) cfCusto.textContent = custo;
            try {
              var cfImg = document.getElementById('cfTargetImg');
              var cfName = document.getElementById('cfTargetName');
              var cfSubtitle = document.getElementById('cfTargetSubtitle');
              if (cfImg) cfImg.src = c.img || 'assets/ui/card-back.png';
              if (cfName) cfName.textContent = c.name || 'Carta do oponente';
              if (cfSubtitle) cfSubtitle.textContent = (c.kind ? (c.kind + ' — ' + (c.filiacao || '')) : '') || 'Magia/Truque do oponente';
            } catch(e) { console.warn('cf preview set error', e); }
            var btnSim = document.getElementById('btnConversaSim');
            var btnNao = document.getElementById('btnConversaNao');
            btnSim.onclick = null;
            btnNao.onclick = null;
            btnSim.onclick = function () {
              try{ window.__WAITING_FOR_MODAL = false; }catch(e){}
              modal.style.display = 'none';
              const fiada = STATE['you'].hand[idxFiada];
              STATE['you'].grave.push(fiada);
              STATE['you'].hand.splice(idxFiada, 1);
              log('Você ativou Conversa Fiada e anulou a magia/truque do oponente!');
              render();
              c._fiadaCheck = true;
              STATE[side].grave.push(c);
              STATE[side].hand.splice(index, 1);
              render();
              done();
            };
            btnNao.onclick = function () {
              try{ window.__WAITING_FOR_MODAL = false; }catch(e){}
              modal.style.display = 'none';
              c._fiadaCheck = true;
              setTimeout(function(){ playFromHand(side, index); done(); }, 10);
            };
          });
        } else if (modal) {
          // fallback: show immediately
          window.__WAITING_FOR_MODAL = true;
          modal.style.display = 'flex';
        }
        return;
      }
      if (c._fiadaCheck) delete c._fiadaCheck;
    }

    // Caso: jogador (side === 'you') jogando -> IA pode auto-ativar Conversa Fiada se tiver na mão
    if (side === 'you') {
      const idxAiFiada = STATE['ai'].hand.findIndex(card => card && card.name === 'Conversa Fiada');
      if (idxAiFiada !== -1 && !c._fiadaCheck) {
        const fiada = STATE['ai'].hand[idxAiFiada];
        STATE['ai'].grave.push(fiada);
        STATE['ai'].hand.splice(idxAiFiada, 1);
        log('IA ativou Conversa Fiada e anulou sua magia/truque!');
        c._fiadaCheck = true;
        STATE[side].grave.push(c);
        STATE[side].hand.splice(index, 1);
        render();
        return;
      }
      if (c._fiadaCheck) delete c._fiadaCheck;
    }
  }

  // Lógica de escolha 1 — IA decide automaticamente, jogador vê modal
  if (c.escolha1) {
    if (side === 'ai') {
      // IA decide entre A/B por heurística simples
      const leader = STATE[side].leader;
      let escolha = 'B';
      // Se a IA tiver um aliado com 'provocar' que foi invocado neste turno e
      // portanto não pode atacar ainda (summonedThisTurn === true), prefira
      // escolher o efeito de "deitar aliado" (tap_ally) quando disponível —
      // isso permite que o provoker atue como proteção (taunt) ao ficar deitado.
      const hasFreshProvoker = (STATE[side].allies||[]).some(a => a && a.keywords && a.keywords.includes('provocar') && a.summonedThisTurn);
      if (hasFreshProvoker) {
        if (c.effectA && c.effectA.type === 'tap_ally') escolha = 'A';
        else if (c.effectB && c.effectB.type === 'tap_ally') escolha = 'B';
      }
      // Preferir cura se líder ferido e uma das opções cura (após a checagem de provoker)
      if (leader && leader.hp < (leader.maxHp || 0)) {
        if (c.effectA && c.effectA.type === 'heal') escolha = 'A';
        else if (c.effectB && c.effectB.type === 'heal') escolha = 'B';
      }
      // Se nenhuma cura/provoker, preferir buff (atk_temp) ou draw
      if (escolha === 'A') {
        // Suporte: banir carta (escolha A)
        if (c.effectA && c.effectA.type === 'ban_on_enter') {
          setTimeout(() => {
            const candidates = [];
            ['you','ai'].forEach(s => {
              (STATE[s].spells || []).forEach((card, i) => { if(card) candidates.push({ side: s, pile: 'spells', idx: i, card }); });
              (STATE[s].allies || []).forEach((card, i) => { if(card) candidates.push({ side: s, pile: 'allies', idx: i, card }); });
              if (STATE[s].env) candidates.push({ side: s, pile: 'env', idx: null, card: STATE[s].env });
            });
            if (!candidates.length) { log(`${c.name}: nenhuma carta disponível para banir.`); return; }
            // IA: prefere banir carta do oponente
            let choice = candidates.find(e => e.side !== side) || candidates[0];
            if (choice.pile === 'spells') { if (typeof choice.idx === 'number') STATE[choice.side].spells[choice.idx] = null; }
            else if (choice.pile === 'allies') { if (typeof choice.idx === 'number') STATE[choice.side].allies[choice.idx] = null; }
            else if (choice.pile === 'env') { STATE[choice.side].env = null; }
            STATE[choice.side].ban.push(choice.card);
            log(`IA: ${c.name} baniu ${choice.card.name}.`);
            render();
          }, 10);
        }
        if (c.effectA.type === 'heal') {
          leader.hp = Math.min(leader.maxHp, leader.hp + c.effectA.value);
          log(`IA curou ${c.effectA.value} de vida do líder.`);
        } else if (c.effectA.type === 'draw') {
          for (let i = 0; i < c.effectA.value; i++) draw(side);
          log(`IA comprou ${c.effectA.value} carta(s).`);
        } else if (c.effectA.type === 'tap_ally') {
          // tap first available ally
          const allyIdx = (STATE[side].allies||[]).findIndex(a => a && !a.tapped && a.hp>0);
          if (allyIdx !== -1) { STATE[side].allies[allyIdx].tapped = true; log(`IA deitou ${STATE[side].allies[allyIdx].name}.`); }
          else { log('IA tentou deitar aliado, mas nenhum disponível.'); }
        } else if (c.effectA.type === 'atk_temp') {
          // pick best target (highest damage ally or leader)
          let candidates = [];
          if (STATE[side].leader) candidates.push({type:'leader', obj: STATE[side].leader});
          (STATE[side].allies||[]).forEach(a=> a && candidates.push({type:'ally', obj:a}));
          candidates.sort((x,y)=>(y.obj.damage||0)-(x.obj.damage||0));
          if(candidates.length){ const tgt=candidates[0].obj; tgt.atkBonusTemp=(tgt.atkBonusTemp||0)+(c.effectA.value||0); tgt._resgate_energia={appliedTurn:STATE.turnCount[side]}; log(`IA aplicou +${c.effectA.value||0} ATK em ${tgt.name} (até o fim do turno).`); }
        } else if (c.effectA.type === 'fragment_back') {
          const gain = (c.effectA.value||0);
          const before = STATE.pool[side]||0;
          STATE.pool[side] = Math.min(STATE.maxPool[side] || 999, (STATE.pool[side]||0) + gain);
          log(`IA recuperou ${STATE.pool[side]-before} fragmento(s).`);
        } else if (c.effectA.type === 'search_deck') {
          // IA: buscar carta no deck (excluir o próprio equipamento/carta para evitar auto-seleção)
          const q = Object.assign({}, c.effectA.query || {});
          if (c && c.name) q.excludeName = c.name;
          performSearchDeck(side, q, c.effectA.max || 10, c.effectA.title || 'Buscar no deck', () => {});
        }
      } else {
        if (c.effectB.type === 'heal') {
          leader.hp = Math.min(leader.maxHp, leader.hp + c.effectB.value);
          log(`IA curou ${c.effectB.value} de vida do líder.`);
        } else if (c.effectB.type === 'draw') {
          for (let i = 0; i < c.effectB.value; i++) draw(side);
          log(`IA comprou ${c.effectB.value} carta(s).`);
        } else if (c.effectB.type === 'tap_ally') {
          const allyIdx = (STATE[side].allies||[]).findIndex(a => a && !a.tapped && a.hp>0);
          if (allyIdx !== -1) { STATE[side].allies[allyIdx].tapped = true; log(`IA deitou ${STATE[side].allies[allyIdx].name}.`); }
          else { log('IA tentou deitar aliado, mas nenhum disponível.'); }
        } else if (c.effectB.type === 'atk_temp') {
          let candidates = [];
          if (STATE[side].leader) candidates.push({type:'leader', obj: STATE[side].leader});
          (STATE[side].allies||[]).forEach(a=> a && candidates.push({type:'ally', obj:a}));
          candidates.sort((x,y)=>(y.obj.damage||0)-(x.obj.damage||0));
          if(candidates.length){ const tgt=candidates[0].obj; tgt.atkBonusTemp=(tgt.atkBonusTemp||0)+(c.effectB.value||0); tgt._resgate_energia={appliedTurn:STATE.turnCount[side]}; log(`IA aplicou +${c.effectB.value||0} ATK em ${tgt.name} (até o fim do turno).`); }
        } else if (c.effectB.type === 'fragment_back') {
          const gain = (c.effectB.value||0);
          const before = STATE.pool[side]||0;
          STATE.pool[side] = Math.min(STATE.maxPool[side] || 999, (STATE.pool[side]||0) + gain);
          log(`IA recuperou ${STATE.pool[side]-before} fragmento(s).`);
        } else if (c.effectB.type === 'search_deck') {
          const q = Object.assign({}, c.effectB.query || {});
          if (c && c.name) q.excludeName = c.name;
          performSearchDeck(side, q, c.effectB.max || 10, c.effectB.title || 'Buscar no deck', () => {});
        }
        else if (c.effectB && c.effectB.type === 'ban_on_enter') {
          setTimeout(() => {
            const candidates = [];
            ['you','ai'].forEach(s => {
              (STATE[s].spells || []).forEach((card, i) => { if(card) candidates.push({ side: s, pile: 'spells', idx: i, card }); });
              (STATE[s].allies || []).forEach((card, i) => { if(card) candidates.push({ side: s, pile: 'allies', idx: i, card }); });
              if (STATE[s].env) candidates.push({ side: s, pile: 'env', idx: null, card: STATE[s].env });
            });
            if (!candidates.length) { log(`${c.name}: nenhuma carta disponível para banir.`); return; }
            let choice = candidates.find(e => e.side !== side) || candidates[0];
            if (choice.pile === 'spells') { if (typeof choice.idx === 'number') STATE[choice.side].spells[choice.idx] = null; }
            else if (choice.pile === 'allies') { if (typeof choice.idx === 'number') STATE[choice.side].allies[choice.idx] = null; }
            else if (choice.pile === 'env') { STATE[choice.side].env = null; }
            STATE[choice.side].ban.push(choice.card);
            log(`IA: ${c.name} baniu ${choice.card.name}.`);
            render();
          }, 10);
        }
      }
      STATE[side].grave.push(c);
      STATE[side].hand.splice(index, 1);
      render();
      return;
    } else {
      // Jogador: mostra modal visual
      let modal = document.getElementById('escolha1Modal');
      // Build up-to-date modal content for this card `c` so the modal never shows stale content
      const escolhaHtml = `
          <div class="modalBox" style="min-width:320px;max-width:400px;padding:32px 24px 24px 24px;display:flex;flex-direction:column;align-items:center;">
            <img src="${c.img}" alt="${c.name}" style="width:80px;height:112px;border-radius:8px;margin-bottom:12px;box-shadow:0 2px 12px #facc15a0;" onerror="this.src='assets/ui/card-back.png';">
            <div style="font-size:17px;font-weight:bold;color:#facc15;text-align:center;margin-bottom:10px;">${c.name}</div>
            <div style="font-size:15px;color:#e2e8f0;text-align:left;margin-bottom:18px;white-space:pre-line;">
              <span style="color:#facc15;font-weight:bold;">Efeito 1:</span> ${
                c.effectA && c.effectA.type === 'heal' ? `Cure ${c.effectA.value} de vida` :
                c.effectA && c.effectA.type === 'draw' ? `Compre ${c.effectA.value} carta(s)` :
                c.effectA && c.effectA.type === 'tap_ally' ? `Deite um aliado` :
                c.effectA && c.effectA.type === 'atk_temp' ? `Dê +${c.effectA.value} ATK até o fim do turno` :
                c.effectA && c.effectA.type === 'fragment_back' ? `Recupere ${c.effectA.value||1} fragmento(s)` :
                c.effectA && c.effectA.type === 'ban_on_enter' ? `Banie uma carta do campo` :
                  c.effectA && c.effectA.type === 'search_deck' ? `Buscar carta no deck` :
                  'Efeito desconhecido'
              }<br>
              <span style="color:#facc15;font-weight:bold;">Efeito 2:</span> ${
                c.effectB && c.effectB.type === 'heal' ? `Cure ${c.effectB.value} de vida` :
                c.effectB && c.effectB.type === 'draw' ? `Compre ${c.effectB.value} carta(s)` :
                c.effectB && c.effectB.type === 'tap_ally' ? `Deite um aliado` :
                c.effectB && c.effectB.type === 'atk_temp' ? `Dê +${c.effectB.value} ATK até o fim do turno` :
                  c.effectB && c.effectB.type === 'fragment_back' ? `Recupere ${c.effectB.value||1} fragmento(s)` :
                  c.effectB && c.effectB.type === 'ban_on_enter' ? `Banie uma carta do campo` :
                  c.effectB && c.effectB.type === 'search_deck' ? `Buscar carta no deck` :
                'Efeito desconhecido'
              }
            </div>
            <div style="display:flex;gap:18px;justify-content:center;">
              <button id="btnEscolha1A" style="background:#fde68a;color:#7c2d12;font-weight:bold;font-size:16px;border:none;border-radius:10px;padding:12px 28px;box-shadow:0 2px 8px #fde68a88;cursor:pointer;">Efeito 1</button>
              <button id="btnEscolha1B" style="background:#fde68a;color:#7c2d12;font-weight:bold;font-size:16px;border:none;border-radius:10px;padding:12px 28px;box-shadow:0 2px 8px #fde68a88;cursor:pointer;">Efeito 2</button>
            </div>
          </div>
        `;
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'escolha1Modal';
        modal.className = 'modal';
        modal.style.zIndex = '150';
        document.body.appendChild(modal);
      }
  // Debug log: show which card and which choice options are being presented
  try { log(`Modal escolha1 aberto: ${c.name} — A:${(c.effectA&&c.effectA.type)||c.effectA||'?'} B:${(c.effectB&&c.effectB.type)||c.effectB||'?'} `); } catch(e){ console.warn('log error', e); }
  modal.innerHTML = escolhaHtml;
      modal.style.display = 'flex';
      // Efeito 1
      document.getElementById('btnEscolha1A').onclick = function () {
        modal.style.display = 'none';
        // search_deck handling
        if (c.effectA && c.effectA.type === 'search_deck') {
          const q = Object.assign({}, c.effectA.query || {});
          if (c && c.name) q.excludeName = c.name;
          performSearchDeck(side, q, c.effectA.max || 10, c.effectA.title || 'Buscar no deck', (chosenCard, chosenIdx) => {
            if (!chosenCard) { log('Busca cancelada ou sem resultados.'); return; }
            // remove chosen card from deck
            const di = STATE[side].deck.indexOf(chosenCard);
            if (di !== -1) STATE[side].deck.splice(di, 1);
            STATE[side].hand.push(chosenCard);
            log(`Você buscou ${chosenCard.name} e a colocou na mão.`);
            STATE[side].grave.push(c);
            STATE[side].hand.splice(index, 1);
            render();
          });
          return;
        }
        // ban_on_enter handling (player chose ban)
        if (c.effectA && c.effectA.type === 'ban_on_enter') {
          setTimeout(() => {
            const candidates = [];
            ['you','ai'].forEach(s => {
              (STATE[s].spells || []).forEach((card, i) => { if(card) candidates.push({ side: s, pile: 'spells', idx: i, card }); });
              (STATE[s].allies || []).forEach((card, i) => { if(card) candidates.push({ side: s, pile: 'allies', idx: i, card }); });
              if (STATE[s].env) candidates.push({ side: s, pile: 'env', idx: null, card: STATE[s].env });
            });
            if (!candidates.length) { log(`${c.name}: nenhuma carta disponível para banir.`); return; }
            const opts = candidates.map(o => ({ card: o.card, label: o.side === 'you' ? 'Seu' : 'Oponente' }));
            showCardChoice(opts, (chosen, idx) => {
              if (chosen == null) { log(`${c.name}: banimento cancelado.`); return; }
              const chosenItem = candidates[idx];
              if (!chosenItem) { alert('Carta não encontrada.'); return; }
              if (chosenItem.pile === 'spells') { if (typeof chosenItem.idx === 'number') STATE[chosenItem.side].spells[chosenItem.idx] = null; }
              else if (chosenItem.pile === 'allies') { if (typeof chosenItem.idx === 'number') STATE[chosenItem.side].allies[chosenItem.idx] = null; }
              else if (chosenItem.pile === 'env') { STATE[chosenItem.side].env = null; }
              STATE[chosenItem.side].ban.push(chosenItem.card);
              log(`${side === 'you' ? 'Você' : 'IA'} baniu ${chosenItem.card.name} com ${c.name}.`);
              STATE[side].grave.push(c);
              STATE[side].hand.splice(index, 1);
              render();
            }, 'Escolha uma carta para banir');
          }, 10);
          return;
        }
        if (c.effectA.type === 'heal') {
          // Permitir ao jogador escolher alvo para curar (líder ou aliados)
          let allyOptions = [];
          STATE[side].allies.forEach((a, i) => { if (a) allyOptions.push({ type: 'ally', slot: i, obj: a }); });
          if (STATE[side].leader) allyOptions.unshift({ type: 'leader', obj: STATE[side].leader });
          if (!allyOptions.length) {
            log('Nenhum alvo válido para curar.');
          } else {
            showCardChoice(
              allyOptions.map(opt => ({ card: opt.obj, label: opt.type === 'leader' ? 'Líder' : 'Aliado' })),
              (chosen, idx) => {
                const opt = allyOptions[idx];
                let targetObj = opt.type === 'leader' ? STATE[side].leader : STATE[side].allies[opt.slot];
                if (!targetObj) { alert('Alvo não encontrado.'); return; }
                targetObj.hp = Math.min(targetObj.maxHp || targetObj.hp, (targetObj.hp || 0) + c.effectA.value);
                log('Você curou ' + c.effectA.value + ' de vida em ' + (targetObj.name || (opt.type === 'leader' ? 'Líder' : 'Aliado')) + '.');
                // Se um aliado foi curado, aplicar passive de Leafae
                if(opt && opt.type === 'ally') checkLeafaeOnAllyHealed(side, targetObj);
                STATE[side].grave.push(c);
                STATE[side].hand.splice(index, 1);
                render();
              },
              'Escolha alvo para curar'
            );
          }
        } else if (c.effectA.type === 'draw') {
          for (let i = 0; i < c.effectA.value; i++) draw(side);
          log('Você comprou ' + c.effectA.value + ' carta(s).');
          STATE[side].grave.push(c);
          STATE[side].hand.splice(index, 1);
          render();
        } else if (c.effectA.type === 'tap_ally') {
          // Deitar um aliado: escolher um aliado e marcar tapped=true
          let allyOptions = [];
          STATE[side].allies.forEach((a, i) => { if (a) allyOptions.push({ type: 'ally', slot: i, obj: a }); });
          if (!allyOptions.length) { log('Nenhum aliado disponível para deitar.'); return; }
          showCardChoice(
            allyOptions.map(opt => ({ card: opt.obj })),
            (chosen, idx) => {
              const opt = allyOptions[idx];
              const target = STATE[side].allies[opt.slot];
              if (!target) { alert('Alvo não encontrado.'); return; }
              target.tapped = true;
              log(`Você deitou ${target.name}.`);
              STATE[side].grave.push(c);
              STATE[side].hand.splice(index, 1);
              render();
            },
            'Escolha um aliado para deitar'
          );
        } else if (c.effectA.type === 'atk_temp') {
          // Dar +N ATK até o fim do turno: escolher alvo (líder ou aliado)
          let allyOptions = [];
          STATE[side].allies.forEach((a, i) => { if (a) allyOptions.push({ type: 'ally', slot: i, obj: a }); });
          if (STATE[side].leader) allyOptions.unshift({ type: 'leader', obj: STATE[side].leader });
          if (!allyOptions.length) { log('Nenhum alvo válido para buff.'); return; }
          showCardChoice(
            allyOptions.map(opt => ({ card: opt.obj, label: opt.type === 'leader' ? 'Líder' : 'Aliado' })),
            (chosen, idx) => {
              if (chosen == null) { log('Cancelado.'); return; }
              const opt = allyOptions[idx];
              const targetObj = (opt.type === 'leader') ? STATE[side].leader : STATE[side].allies[opt.slot];
              if (!targetObj) { alert('Alvo não encontrado.'); return; }
              targetObj.atkBonusTemp = (targetObj.atkBonusTemp || 0) + (c.effectA.value || 0);
              targetObj._resgate_energia = { appliedTurn: STATE.turnCount[side] };
              log(`${targetObj.name} recebe +${c.effectA.value||0} ATK até o fim do turno.`);
              STATE[side].grave.push(c);
              STATE[side].hand.splice(index, 1);
              render();
            },
            'Escolha alvo para buff'
          );
        } else if (c.effectA.type === 'fragment_back') {
          const gain = (c.effectA.value||0);
          const before = STATE.pool[side]||0;
          STATE.pool[side] = Math.min(STATE.maxPool[side] || 999, (STATE.pool[side]||0) + gain);
          log(`Você recuperou ${STATE.pool[side]-before} fragmento(s).`);
          STATE[side].grave.push(c);
          STATE[side].hand.splice(index, 1);
          render();
        }
      };
      // Efeito 2
      document.getElementById('btnEscolha1B').onclick = function () {
        modal.style.display = 'none';
        // search_deck handling for option B
        if (c.effectB && c.effectB.type === 'search_deck') {
          const q = Object.assign({}, c.effectB.query || {});
          if (c && c.name) q.excludeName = c.name;
          performSearchDeck(side, q, c.effectB.max || 10, c.effectB.title || 'Buscar no deck', (chosenCard, chosenIdx) => {
            if (!chosenCard) { log('Busca cancelada ou sem resultados.'); return; }
            const di = STATE[side].deck.indexOf(chosenCard);
            if (di !== -1) STATE[side].deck.splice(di, 1);
            STATE[side].hand.push(chosenCard);
            log(`Você buscou ${chosenCard.name} e a colocou na mão.`);
            STATE[side].grave.push(c);
            STATE[side].hand.splice(index, 1);
            render();
          });
          return;
        }
  if (c.effectB.type === 'heal') {
          // Permitir ao jogador escolher alvo para curar (líder ou aliados)
          let allyOptions = [];
          STATE[side].allies.forEach((a, i) => { if (a) allyOptions.push({ type: 'ally', slot: i, obj: a }); });
          if (STATE[side].leader) allyOptions.unshift({ type: 'leader', obj: STATE[side].leader });
          if (!allyOptions.length) {
            log('Nenhum alvo válido para curar.');
          } else {
            showCardChoice(
              allyOptions.map(opt => ({ card: opt.obj, label: opt.type === 'leader' ? 'Líder' : 'Aliado' })),
              (chosen, idx) => {
                const opt = allyOptions[idx];
                let targetObj = opt.type === 'leader' ? STATE[side].leader : STATE[side].allies[opt.slot];
                if (!targetObj) { alert('Alvo não encontrado.'); return; }
                targetObj.hp = Math.min(targetObj.maxHp || targetObj.hp, (targetObj.hp || 0) + c.effectB.value);
                log('Você curou ' + c.effectB.value + ' de vida em ' + (targetObj.name || (opt.type === 'leader' ? 'Líder' : 'Aliado')) + '.');
                // Se um aliado foi curado, aplicar passive de Leafae
                if(opt && opt.type === 'ally') checkLeafaeOnAllyHealed(side, targetObj);
                STATE[side].grave.push(c);
                STATE[side].hand.splice(index, 1);
                render();
              },
              'Escolha alvo para curar'
            );
          }
        } else if (c.effectB.type === 'draw') {
          for (let i = 0; i < c.effectB.value; i++) draw(side);
          log('Você comprou ' + c.effectB.value + ' carta(s).');
          STATE[side].grave.push(c);
          STATE[side].hand.splice(index, 1);
          render();
        } else if (c.effectB.type === 'tap_ally') {
          let allyOptions = [];
          STATE[side].allies.forEach((a, i) => { if (a) allyOptions.push({ type: 'ally', slot: i, obj: a }); });
          if (!allyOptions.length) { log('Nenhum aliado disponível para deitar.'); return; }
          showCardChoice(
            allyOptions.map(opt => ({ card: opt.obj })),
            (chosen, idx) => {
              const opt = allyOptions[idx];
              const target = STATE[side].allies[opt.slot];
              if (!target) { alert('Alvo não encontrado.'); return; }
              target.tapped = true;
              log(`Você deitou ${target.name}.`);
              STATE[side].grave.push(c);
              STATE[side].hand.splice(index, 1);
              render();
            },
            'Escolha um aliado para deitar'
          );
        } else if (c.effectB.type === 'atk_temp') {
          let allyOptions = [];
          STATE[side].allies.forEach((a, i) => { if (a) allyOptions.push({ type: 'ally', slot: i, obj: a }); });
          if (STATE[side].leader) allyOptions.unshift({ type: 'leader', obj: STATE[side].leader });
          if (!allyOptions.length) { log('Nenhum alvo válido para buff.'); return; }
          showCardChoice(
            allyOptions.map(opt => ({ card: opt.obj, label: opt.type === 'leader' ? 'Líder' : 'Aliado' })),
            (chosen, idx) => {
              if (chosen == null) { log('Cancelado.'); return; }
              const opt = allyOptions[idx];
              const targetObj = (opt.type === 'leader') ? STATE[side].leader : STATE[side].allies[opt.slot];
              if (!targetObj) { alert('Alvo não encontrado.'); return; }
              targetObj.atkBonusTemp = (targetObj.atkBonusTemp || 0) + (c.effectB.value || 0);
              targetObj._resgate_energia = { appliedTurn: STATE.turnCount[side] };
              log(`${targetObj.name} recebe +${c.effectB.value||0} ATK até o fim do turno.`);
              STATE[side].grave.push(c);
              STATE[side].hand.splice(index, 1);
              render();
            },
            'Escolha alvo para buff'
          );
        } else if (c.effectB.type === 'fragment_back') {
          const gain = (c.effectB.value||0);
          const before = STATE.pool[side]||0;
          STATE.pool[side] = Math.min(STATE.maxPool[side] || 999, (STATE.pool[side]||0) + gain);
          log(`Você recuperou ${STATE.pool[side]-before} fragmento(s).`);
          STATE[side].grave.push(c);
          STATE[side].hand.splice(index, 1);
          render();
        }
      };
      return;
    }
  }

  if(c.kind==='equip'){
    const pos=STATE[side].spells.findIndex(x=>!x);
    if(pos===-1){ alert('Sem espaço para equipamento/magia.'); return; }

    // Mapeia aliados presentes para seleção visual
    let allyOptions = [];
    STATE[side].allies.forEach((a, i) => { if(a) allyOptions.push({ type:'ally', slot: i, obj: a }); });
    if(STATE[side].leader) allyOptions.unshift({ type:'leader', obj: STATE[side].leader });
    if(!allyOptions.length){ alert('Nenhum alvo válido para equipar.'); return; }
    if(side === 'ai'){
      // IA decide automaticamente: prefira um aliado existente, senão o líder
      let aiSlot = STATE[side].allies.findIndex(a => a);
      let target, targetObj;
      if(aiSlot !== -1){
        target = { type:'ally', index: aiSlot };
        targetObj = STATE[side].allies[aiSlot];
      } else {
        target = { type:'leader' };
        targetObj = STATE[side].leader;
      }
      // Aplica equipamento automaticamente
      c.ownerSide   = side;
      c.slotIndex   = pos;
      c.equippedSide= side;
      c.equippedTo  = target;
      if(targetObj){
        if(!targetObj.equipments) targetObj.equipments = [];
        targetObj.equipments.push(c);
        if(c.atkBonus)    targetObj.atkBonus = (targetObj.atkBonus||0) + c.atkBonus;
        if(c.acBonus)     targetObj.ac       = (targetObj.ac||0)       + c.acBonus;
        if(c.damageBonus) targetObj.damage   = (targetObj.damage||0)   + c.damageBonus;
        if(c.damageTakenReduction) targetObj.damageTakenReduction = (targetObj.damageTakenReduction||0) + c.damageTakenReduction;
        if(c.dmgBonus)    targetObj.damage   = (targetObj.damage||0)   + c.dmgBonus;
        if(c.hpBonus)     targetObj.hp       = (targetObj.hp||0)       + c.hpBonus;
        // Redoma Santa: se equipado em aliado já ferido, cura todo o dano desse aliado
        if(c.effect === 'redoma_santa' && target && target.type === 'ally' && targetObj.hp != null && targetObj.maxHp != null && targetObj.hp < targetObj.maxHp){
          const healed = (targetObj.maxHp || 0) - targetObj.hp;
          targetObj.hp = targetObj.maxHp;
          logEffect(`${c.name}: curou ${targetObj.name} por ${healed} de vida ao ser equipado.`);
          // Trigger Leafae passive when healed by equipment
          try { if (typeof checkLeafaeOnAllyHealed === 'function') checkLeafaeOnAllyHealed(side, targetObj); } catch (e) { console.warn('checkLeafaeOnAllyHealed error', e); }
        }
      }
  STATE[side].spells[pos]=c;
  STATE[side].hand.splice(index,1);
  logEffect((side==='you'?'Você':'IA') + ' equipou ' + c.name + (targetObj && targetObj.name ? ' em ' + targetObj.name + '.' : '.'));
      // Se o equipamento tem efeito de olhar topo, dispare o efeito também
      if (c.effect === 'olhar_topo' || c.effect === 'olhar_topo_2') {
        setTimeout(() => habilitarOlharTopo(1, side), 10);
      }
        // Se equipamento usa fragment_back, conceda fragments ao dono
        if (c.effect === 'fragment_back') {
          const gain = c.effectValue || c.value || 0;
          const before = STATE.pool[side] || 0;
          STATE.pool[side] = Math.min(STATE.maxPool[side] || 999, before + gain);
          log(`${c.name}: recuperou ${STATE.pool[side]-before} fragmento(s) ao equipar.`);
        }
      // Se equipamento tem efeito de buscar no deck ao equipar
          if (c.effect === 'search_deck') {
        const q = Object.assign({}, c.query || c.effectValue || {});
        // Prevent the equipment/card from finding itself
        if (c && c.name) q.excludeName = c.name;
        if (side === 'ai') {
          performSearchDeck(side, q, c.max || 10, c.title || `Buscar no deck`, () => {});
        } else {
          performSearchDeck(side, q, c.max || 10, c.title || `Buscar no deck`, (chosenCard) => {
            if (!chosenCard) { log(`${c.name}: busca cancelada ou sem resultados.`); return; }
            log(`${c.name}: você buscou ${chosenCard.name} e a colocou na mão.`);
            render();
          });
        }
      }
      render();
    } else {
      showCardChoice(
        allyOptions.map(opt => ({ card: opt.obj, label: opt.type === 'leader' ? 'Líder' : 'Aliado' })),
        (chosen, idx) => {
          if (chosen == null) {
            // Cancelled, do nothing and do NOT spend fragments
            return;
          }
          let target, targetObj;
          if(allyOptions[idx].type === 'leader') {
            target = { type:'leader' };
            targetObj = STATE[side].leader;
          } else {
            target = { type:'ally', index: allyOptions[idx].slot };
            targetObj = STATE[side].allies[allyOptions[idx].slot];
          }
          // Metadados do equipamento
          c.ownerSide   = side;
          c.slotIndex   = pos;
          c.equippedSide= side;
          c.equippedTo  = target;
          // Aplica bônus ao alvo
          if(!targetObj) { alert('Alvo não encontrado.'); return; }
          if(!targetObj.equipments) targetObj.equipments = [];
          targetObj.equipments.push(c);
          if(c.atkBonus)    targetObj.atkBonus = (targetObj.atkBonus||0) + c.atkBonus;
          if(c.acBonus)     targetObj.ac       = (targetObj.ac||0)       + c.acBonus;
          if(c.damageBonus) targetObj.damage   = (targetObj.damage||0)   + c.damageBonus;
          if(c.damageTakenReduction) targetObj.damageTakenReduction = (targetObj.damageTakenReduction||0) + c.damageTakenReduction;
          if(c.dmgBonus)    targetObj.damage   = (targetObj.damage||0)   + c.dmgBonus;
          if(c.hpBonus)     targetObj.hp       = (targetObj.hp||0)       + c.hpBonus;
          STATE[side].spells[pos]=c;
          STATE[side].hand.splice(index,1);
          log((side==='you'?'Você':'IA') + ' equipou ' + c.name + ' em ' + targetObj.name + '.');
          // Se o equipamento tem efeito de olhar topo, dispare o efeito também
          if (c.effect === 'olhar_topo' || c.effect === 'olhar_topo_2') {
            setTimeout(() => habilitarOlharTopo(1, side), 10);
          }
          // Se Redoma Santa e alvo aliado já ferido, cure todo o dano
          if(c.effect === 'redoma_santa' && allyOptions[idx].type === 'ally' && targetObj.hp != null && targetObj.maxHp != null && targetObj.hp < targetObj.maxHp){
            const healed = (targetObj.maxHp || 0) - targetObj.hp;
            targetObj.hp = targetObj.maxHp;
            log(`${c.name}: curou ${targetObj.name} por ${healed} de vida ao ser equipado.`);
            // Trigger Leafae passive when healed by equipment
            try { if (typeof checkLeafaeOnAllyHealed === 'function') checkLeafaeOnAllyHealed(side, targetObj); } catch (e) { console.warn('checkLeafaeOnAllyHealed error', e); }
          }
          // Se equipamento tem efeito de buscar no deck ao equipar (versão jogador)
          if (c.effect === 'search_deck') {
            const q = c.query || c.effectValue || {};
            performSearchDeck(side, q, c.max || 10, c.title || `Buscar no deck`, (chosenCard) => {
              if (!chosenCard) { log(`${c.name}: busca cancelada ou sem resultados.`); return; }
              log(`${c.name}: você buscou ${chosenCard.name} e a colocou na mão.`);
              render();
            });
          }
          render();
        },
        'Escolha alvo para equipar'
      );
    }
    return;
  }

  // Spell: Amizade com a Floresta — danifica um Animal aliado escolhido e depois cura o LÍDER do lado
  if (c.kind === 'spell' && c.effect === 'amizade_floresta') {
    const dmg = (c.effectValue && c.effectValue.damageToAnimal) || (c.effectValue || {}).damageToAnimal || 2;
    const heal = (c.effectValue && c.effectValue.healValue) || (c.effectValue || {}).healValue || 4;
    // montar opções: aliados do tipo Animal (apenas seus)
    const allyOptions = [];
    STATE[side].allies.forEach((a, i) => { if (a && a.tipo === 'Animal') allyOptions.push({ type: 'ally', obj: a, slot: i }); });
    if (!allyOptions.length) { log(`${c.name}: nenhum aliado Animal disponível.`); return; }

    if (side === 'ai') {
      // IA: prefira um Animal que não morra com o dano; senão escolha o com maior benefício (menor HP > 0)
      let pick = allyOptions.find(o => (o.obj.hp || 0) > dmg) || allyOptions.sort((x, y) => (x.obj.hp || 0) - (y.obj.hp || 0))[0];
      const target = pick ? STATE[side].allies[pick.slot] : null;
      if (!target) { log(`${c.name}: IA não encontrou alvo válido.`); return; }
      const hpAntes = target.hp || 0;
      target.hp = Math.max(0, (target.hp || 0) - dmg);
      log(`IA: ${c.name} causou ${hpAntes - target.hp} de dano em ${target.name}.`);
  if (target.hp === 0) { log(`${target.name} morreu.`); cleanupEquipsOf(side, target); STATE[side].grave.push(target); STATE[side].allies[pick.slot] = null; try{ if(typeof MYTRAGOR_EFFECTS!=='undefined'&&MYTRAGOR_EFFECTS.notifyAllySentToGrave) MYTRAGOR_EFFECTS.notifyAllySentToGrave(target, side); }catch(e){} }
      // Após causar dano ao aliado escolhido, cura o LÍDER deste lado em `heal`
      if (STATE[side].leader) {
        const leader = STATE[side].leader;
        const capL = (typeof leader.maxHp === 'number') ? leader.maxHp : ((leader.hp || 0) + heal);
        const healedL = Math.max(0, Math.min(heal, capL - (leader.hp || 0)));
        leader.hp = Math.min(capL, (leader.hp || 0) + healedL);
        if (healedL > 0) log(`IA: ${leader.name} foi curado em ${healedL} pontos por ${c.name}.`);
        else log(`IA: ${leader.name} já está no HP máximo; nenhuma cura aplicada por ${c.name}.`);
      } else {
        log(`IA: nenhum líder encontrado para curar.`);
      }
      STATE[side].grave.push(c); STATE[side].hand.splice(index, 1); render(); return;
    }

    // Jogador: escolha Animal aliado para sofrer o dano e receber a cura
    showCardChoice(
      allyOptions.map(o => ({ card: o.obj })),
      (chosen, idx) => {
        if (chosen == null) { log(`${c.name}: cancelado.`); return; }
        const opt = allyOptions[idx]; if (!opt) return;
        const target = STATE[side].allies[opt.slot]; if (!target) { alert('Alvo não encontrado.'); return; }
        const hpAntes = target.hp || 0;
        target.hp = Math.max(0, (target.hp || 0) - dmg);
        log(`Você causou ${hpAntes - target.hp} de dano a ${target.name} com ${c.name}.`);
  if (target.hp === 0) { log(`${target.name} morreu.`); cleanupEquipsOf(side, target); STATE[side].grave.push(target); STATE[side].allies[opt.slot] = null; try{ if(typeof MYTRAGOR_EFFECTS!=='undefined'&&MYTRAGOR_EFFECTS.notifyAllySentToGrave) MYTRAGOR_EFFECTS.notifyAllySentToGrave(target, side); }catch(e){} }
        // Cura o líder do lado por 'heal', independentemente do destino do aliado
        if (STATE[side].leader) {
          const leader = STATE[side].leader;
          const capL = (typeof leader.maxHp === 'number') ? leader.maxHp : ((leader.hp || 0) + heal);
          const healedL = Math.max(0, Math.min(heal, capL - (leader.hp || 0)));
          leader.hp = Math.min(capL, (leader.hp || 0) + healedL);
          if (healedL > 0) log(`Você curou ${leader.name} por ${healedL} ponto(s) com ${c.name}.`);
          else log(`${leader.name} já está no HP máximo; nenhuma cura aplicada por ${c.name}.`);
        } else {
          log('Nenhum líder encontrado para curar.');
        }
        
        STATE[side].grave.push(c); STATE[side].hand.splice(index, 1); render();
      },
      'Escolha um aliado do tipo Animal para Amizade com a Floresta'
    );
    return;
  }

  // Sacrifício de Sangue: pagar HP de aliado (via costHp) já foi tratado; aqui resolvemos o efeito
  if (c.kind === 'spell' && c.effect === 'blood_sacrifice') {
    const foe = side === 'you' ? 'ai' : 'you';
    let options = [];
    if (STATE[foe].leader && STATE[foe].leader.hp > 0) options.push({ type: 'leader', obj: STATE[foe].leader });
    STATE[foe].allies.forEach((a, i) => { if (a && a.hp > 0) options.push({ type: 'ally', obj: a, slot: i }); });
    if (!options.length) { log('Sacrifício de Sangue: nenhum alvo inimigo disponível.'); return; }
    if (side === 'ai') {
      // IA: preferir aliado inimigo com menor HP
      const allies = (STATE[foe].allies||[]).map((a,i)=>({a,i})).filter(x=>x.a && x.a.hp>0);
      let chosen = null;
      if (allies.length) {
        allies.sort((x,y)=> (x.a.hp||0) - (y.a.hp||0));
        chosen = { type: 'ally', slot: allies[0].i };
      } else if (STATE[foe].leader && STATE[foe].leader.hp>0) {
        chosen = { type: 'leader' };
      }
      if (!chosen) { log('Sacrifício de Sangue: nenhum alvo válido.'); return; }
      if (chosen.type === 'leader') {
        STATE[foe].leader.hp = Math.max(0, STATE[foe].leader.hp - 4);
        log(`Sacrifício de Sangue causou 4 de dano ao líder ${STATE[foe].leader.name}. (HP: ${STATE[foe].leader.hp})`);
  if (STATE[foe].leader.hp === 0) { showVictory((side==='you'?'Você':'IA'), side); }
      } else {
        const a = STATE[foe].allies[chosen.slot];
        a.hp = Math.max(0, a.hp - 4);
        log(`Sacrifício de Sangue causou 4 de dano a ${a.name}. (HP: ${a.hp})`);
  if (a.hp === 0) { log(`${a.name} morreu.`); cleanupEquipsOf(foe, a); STATE[foe].grave.push(a); STATE[foe].allies[chosen.slot]=null; try{ if(typeof MYTRAGOR_EFFECTS!=='undefined'&&MYTRAGOR_EFFECTS.notifyAllySentToGrave) MYTRAGOR_EFFECTS.notifyAllySentToGrave(a, foe); }catch(e){} }
      }
      STATE[side].grave.push(c); STATE[side].hand.splice(index, 1); render(); return;
    }
    // Jogador: escolha de alvo
    showCardChoice(
      options.map(o=>({ card: o.obj })),
      (chosen, idx) => {
        if (chosen == null) { log('Sacrifício de Sangue: cancelado.'); return; }
        const opt = options[idx];
        if (!opt) { alert('Alvo inválido.'); return; }
        if (opt.type === 'leader') {
          STATE[foe].leader.hp = Math.max(0, STATE[foe].leader.hp - 4);
          log(`Sacrifício de Sangue causou 4 de dano ao líder ${STATE[foe].leader.name}. (HP: ${STATE[foe].leader.hp})`);
          if (STATE[foe].leader.hp === 0) { showVictory('Você','you'); }
        } else {
          const a = STATE[foe].allies[opt.slot];
          a.hp = Math.max(0, a.hp - 4);
          log(`Sacrifício de Sangue causou 4 de dano a ${a.name}. (HP: ${a.hp})`);
          if (a.hp === 0) { log(`${a.name} morreu.`); cleanupEquipsOf(foe, a); STATE[foe].grave.push(a); STATE[foe].allies[opt.slot]=null; try{ if(typeof MYTRAGOR_EFFECTS!=='undefined'&&MYTRAGOR_EFFECTS.notifyAllySentToGrave) MYTRAGOR_EFFECTS.notifyAllySentToGrave(a, foe); }catch(e){} }
        }
        STATE[side].grave.push(c); STATE[side].hand.splice(index, 1); render();
      },
      'Escolha um alvo inimigo para Sacrifício de Sangue'
    );
    return;
  }

  // Spell: fragment_back (restaura fragments ao resolver)
  if (c.kind === 'spell' && c.effect === 'fragment_back') {
    const gain = c.effectValue || c.value || 0;
    const before = STATE.pool[side] || 0;
    STATE.pool[side] = Math.min(STATE.maxPool[side] || 999, before + gain);
    log(`${c.name}: recuperou ${STATE.pool[side]-before} fragmento(s).`);
    STATE[side].grave.push(c); STATE[side].hand.splice(index, 1); render(); return;
  }

  // Spell: Ajuda do Povo — cria até 2 tokens 'Cidadãos Unidos'
  if (c.kind === 'spell' && c.effect === 'ajuda_do_povo') {
    try {
      if (typeof MYTRAGOR_EFFECTS !== 'undefined' && MYTRAGOR_EFFECTS.triggerEffect) {
        MYTRAGOR_EFFECTS.triggerEffect('ajuda_do_povo', c, side);
      }
    } catch (e) { console.error('ajuda_do_povo error', e); }
    STATE[side].grave.push(c); STATE[side].hand.splice(index, 1); render(); return;
  }

  // Spell: Espionagem Sorrateira — olhar mão do oponente e descartar carta Religiosa/Marcial/Arcana
  if (c.kind === 'spell' && c.effect === 'espionagem_sorrateira') {
    try {
      if (typeof MYTRAGOR_EFFECTS !== 'undefined' && MYTRAGOR_EFFECTS.triggerEffect) {
        const res = MYTRAGOR_EFFECTS.triggerEffect('espionagem_sorrateira', c, side);
        // If handler resolved synchronously (res.discarded or res.pending), we still move the card to grave.
        // For player choices the handler will open a modal and resolve discard asynchronously; still move the spell to grave.
      }
    } catch (e) { console.error('espionagem_sorrateira error', e); }
    STATE[side].grave.push(c); STATE[side].hand.splice(index, 1); render(); return;
  }

  // Spell: Raio de Gelo — deita um inimigo (abre modal para escolher)
  if (c.kind === 'spell' && c.effect === 'raio_gelo') {
    try {
      if (typeof MYTRAGOR_EFFECTS !== 'undefined' && MYTRAGOR_EFFECTS.triggerEffect) {
        MYTRAGOR_EFFECTS.triggerEffect('raio_gelo', c, side);
      }
    } catch (e) { console.error('raio_gelo error', e); }
    STATE[side].grave.push(c); STATE[side].hand.splice(index, 1); render(); return;
  }

  // Spell: search_deck — buscar carta no deck (parâmetros em c.query ou c.effectValue)
  if (c.kind === 'spell' && c.effect === 'search_deck') {
    const q = Object.assign({}, c.query || c.effectValue || {});
    if (c && c.name) q.excludeName = c.name; // prevent the spell/card from finding itself
    // AI resolves automatically
    if (side === 'ai') {
      performSearchDeck(side, q, c.max || 10, c.title || `Buscar no deck`, () => {});
      STATE[side].grave.push(c); STATE[side].hand.splice(index, 1); render(); return;
    }
    // Player: open modal and let them choose
    performSearchDeck(side, q, c.max || 10, c.title || `Buscar no deck`, (chosenCard) => {
      if (!chosenCard) { log(`${c.name}: busca cancelada ou sem resultados.`); return; }
      // commit spell
      STATE[side].grave.push(c); STATE[side].hand.splice(index, 1);
      render();
    });
    return;
  }

  if(c.kind==='ally'){
    const pos=STATE[side].allies.findIndex(x=>!x); if(pos===-1){ alert('Sem espaço para aliado.'); return; }
    c.summonedThisTurn=true; STATE[side].allies[pos]=c; STATE[side].hand.splice(index,1);
    log(`${side==='you'?'Você':'IA'} baixou ${c.name}.`);
    verificarValbrakEngine(side, c);

    // Efeito automático de entrada: delegado ao módulo effects.js
    try {
      if (typeof MYTRAGOR_EFFECTS !== 'undefined' && MYTRAGOR_EFFECTS.triggerOnEnter) {
        MYTRAGOR_EFFECTS.triggerOnEnter(c, side, pos);
      }
    } catch (e) {
      console.warn('on-enter (playFromHand) error', e);
    }
    render();
    return;
  }

  if(c.kind==='env'){
    // Se já existe ambiente, envia para o cemitério
    if (STATE[side].env) {
      STATE[side].grave.push(STATE[side].env);
    }
    STATE[side].env = c;
    STATE[side].hand.splice(index,1);
    log(`${side==='you'?'Você':'IA'} ativou Ambiente: ${c.name}.`);
  // Aplicar efeitos de ambiente imediatamente (por exemplo, Catedral Ensolarada deve proteger já neste turno)
  try{ applyEnvEffectsOnTurnStart(side); }catch(e){ console.warn('applyEnvEffectsOnTurnStart error', e); }
  render();
    return;
  }

  if (c.kind === 'spell' && c.effect === 'destroy_equip') {
    let slots = [];
    ['you', 'ai'].forEach(s => {
      STATE[s].spells.forEach((card, i) => {
        if (card && card.kind === 'equip') slots.push({ side: s, idx: i, card });
      });
    });
    if (!slots.length) { log('Nenhum equipamento em campo para destruir.'); return; }
    // Se IA está jogando, escolha alvo automaticamente
    if(side === 'ai'){
      // prefira destruir equipamento do oponente
      let choiceIdx = slots.findIndex(s => s.side !== side);
      if(choiceIdx === -1) choiceIdx = 0;
      const o = slots[choiceIdx];
      sendEquipToGrave(o.side, o.card);
      log((side === 'you' ? 'Você' : 'IA') + ' destruiu ' + o.card.name + ' com Quebra-Aço.');
      STATE[side].grave.push(c);
      STATE[side].hand.splice(index, 1);
      render();
      return;
    }
    // Modal exclusivo: divide minicards em "Seus" e "Oponente" (corrigido)
    let modal = document.getElementById('targetChoiceModal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'targetChoiceModal';
      modal.className = 'modal';
      modal.style.display = 'flex';
      modal.style.alignItems = 'center';
      modal.style.justifyContent = 'center';
      modal.style.zIndex = '120';
      modal.innerHTML = `
        <div class="modalBox" style="min-width:420px;max-width:600px;padding:28px 18px 18px 18px;display:flex;flex-direction:row;gap:32px;justify-content:center;">
          <div style="flex:1;display:flex;flex-direction:column;align-items:center;">
            <div style="font-size:16px;font-weight:bold;color:#2563eb;margin-bottom:8px;">Seus</div>
            <div id="targetChoiceYou" style="background:#e0f2fe;border-radius:10px;padding:12px;display:flex;flex-direction:column;gap:12px;"></div>
          </div>
          <div style="width:2px;background:#64748b;margin:0 8px;"></div>
          <div style="flex:1;display:flex;flex-direction:column;align-items:center;">
            <div style="font-size:16px;font-weight:bold;color:#dc2626;margin-bottom:8px;">Oponente</div>
            <div id="targetChoiceOppo" style="background:#fee2e2;border-radius:10px;padding:12px;display:flex;flex-direction:column;gap:12px;"></div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    } else {
      modal.style.display = 'flex';
    }
    // Render minicards (corrigido)
    const youDiv = document.getElementById('targetChoiceYou');
    const oppoDiv = document.getElementById('targetChoiceOppo');
    youDiv.innerHTML = '';
    oppoDiv.innerHTML = '';
    slots.forEach((o, idx) => {
      const cardBtn = document.createElement('div');
      cardBtn.className = 'cardChoiceMini';
      cardBtn.style.width = '70px';
      cardBtn.style.height = '98px';
      cardBtn.style.border = '2px solid #2b3b5c';
      cardBtn.style.borderRadius = '8px';
      cardBtn.style.background = (side === o.side) ? '#e0f2fe' : '#fee2e2';
      cardBtn.style.overflow = 'hidden';
      cardBtn.style.display = 'flex';
      cardBtn.style.alignItems = 'center';
      cardBtn.style.justifyContent = 'center';
      cardBtn.style.cursor = 'pointer';
      cardBtn.style.position = 'relative';
      cardBtn.onclick = () => {
        modal.style.display = 'none';
        sendEquipToGrave(o.side, o.card);
        log(`${side === 'you' ? 'Você' : 'IA'} destruiu ${o.card.name} com Quebra-Aço.`);
        STATE[side].grave.push(c);
        STATE[side].hand.splice(index, 1);
        render();
      };
      const im = document.createElement('img');
      im.src = o.card.img || 'assets/ui/card-back.png';
      im.alt = o.card.name || '';
      im.style.width = '100%';
      im.style.height = '100%';
      im.style.objectFit = 'cover';
      cardBtn.appendChild(im);
      // Label
      const label = document.createElement('div');
      label.textContent = (side === o.side) ? 'Seu' : 'Oponente';
      label.style.position = 'absolute';
      label.style.bottom = '2px';
      label.style.left = '0';
      label.style.width = '100%';
      label.style.textAlign = 'center';
      label.style.background = (side === o.side) ? '#bae6fd' : '#fecaca';
      label.style.color = (side === o.side) ? '#2563eb' : '#dc2626';
      label.style.fontWeight = 'bold';
      label.style.fontSize = '13px';
      label.style.padding = '1px 0';
      label.style.borderRadius = '0 0 8px 8px';
      cardBtn.appendChild(label);
      if (side === o.side) youDiv.appendChild(cardBtn);
      else oppoDiv.appendChild(cardBtn);
    });
    return;
  }

  // Sede de Vingança: buff temporário em um Guerreiro aliado
  if (c.kind === 'spell' && c.effect === 'sede_vinganca') {
    // Monta opções: líder (se for Guerreiro) + aliados Guerreiros
    const allyOptions = [];
    if (STATE[side].leader && STATE[side].leader.classe === 'Guerreiro') allyOptions.push({ type: 'leader', obj: STATE[side].leader });
    STATE[side].allies.forEach((a, i) => { if (a && a.classe === 'Guerreiro') allyOptions.push({ type: 'ally', obj: a, slot: i }); });
    if (!allyOptions.length) { log('Sede de Vingança: nenhum Guerreiro aliado disponível.'); return; }

    if (side === 'ai') {
      // AI: pick the allied warrior with highest damage (fallback first)
      let pick = null;
      const candidates = allyOptions.map((o, i) => ({ opt: o, i }));
      candidates.sort((x, y) => (y.opt.obj.damage || 0) - (x.opt.obj.damage || 0));
      pick = candidates[0];
      const opt = pick.opt;
      const targetObj = (opt.type === 'leader') ? STATE[side].leader : STATE[side].allies[opt.slot];
      if (!targetObj) { log('Sede de Vingança: alvo inválido.'); return; }
      targetObj.atkBonusTemp = (targetObj.atkBonusTemp || 0) + (c.effectValue || 3);
      targetObj._sede_vinganca = { used: false, appliedTurn: STATE.turnCount[side] };
      log(`Sede de Vingança: ${targetObj.name} recebe +${c.effectValue||3} ATK até o fim do turno.`);
      STATE[side].grave.push(c); STATE[side].hand.splice(index, 1); render();
      return;
    }

    // Player: show choice modal
    showCardChoice(
      allyOptions.map(o => ({ card: o.obj })),
      (chosen, idx) => {
        if (chosen == null) { log('Sede de Vingança: cancelado.'); return; }
        const opt = allyOptions[idx];
        const targetObj = (opt.type === 'leader') ? STATE[side].leader : STATE[side].allies[opt.slot];
        if (!targetObj) { alert('Alvo não encontrado.'); return; }
        targetObj.atkBonusTemp = (targetObj.atkBonusTemp || 0) + (c.effectValue || 3);
        targetObj._sede_vinganca = { used: false, appliedTurn: STATE.turnCount[side] };
        log(`Sede de Vingança: ${targetObj.name} recebe +${c.effectValue||3} ATK até o fim do turno.`);
        STATE[side].grave.push(c); STATE[side].hand.splice(index, 1); render();
      },
      'Escolha um Guerreiro aliado para Sede de Vingança'
    );
    return;
  }

  if (c.kind === 'spell' && c.effect === 'dano_2_inimigo') {
    // Mãos Flamejantes: escolher alvo inimigo (aliado ou líder), causar 2 de dano
    const foe = side === 'you' ? 'ai' : 'you';
    let options = [];
    if (STATE[foe].leader && STATE[foe].leader.hp > 0) options.push({ type: 'leader', obj: STATE[foe].leader });
    STATE[foe].allies.forEach((a, i) => { if (a && a.hp > 0) options.push({ type: 'ally', obj: a, slot: i }); });
    if (!options.length) { log('Nenhum alvo inimigo disponível para Mãos Flamejantes.'); return; }
    // Se IA está jogando, escolha alvo automaticamente
    if(side === 'ai'){
      // preferir aliado inimigo com menor HP (entre aliados), senão líder
      const allies = (STATE[foe].allies||[]).map((a,i)=>({a,i})).filter(x=>x.a && x.a.hp>0);
      let chosen = null;
      if(allies.length){
        allies.sort((x,y)=> (x.a.hp||0) - (y.a.hp||0));
        chosen = { type:'ally', slot: allies[0].i };
      } else if(STATE[foe].leader && STATE[foe].leader.hp>0){
        chosen = { type:'leader' };
      }
      if(!chosen){ log('Nenhum alvo válido para Mãos Flamejantes.'); return; }
      if(chosen.type === 'leader'){
        STATE[foe].leader.hp = Math.max(0, STATE[foe].leader.hp - 2);
        STATE[foe].leader.hp = Math.max(0, STATE[foe].leader.hp - 2);
        log('Mãos Flamejantes causou 2 de dano ao líder ' + STATE[foe].leader.name + '. (HP: ' + STATE[foe].leader.hp + ')');
  if (STATE[foe].leader.hp === 0) { showVictory((side==='you'?'Você':'IA'), side); }
      } else {
        const a = STATE[foe].allies[chosen.slot];
        if(a){
          a.hp = Math.max(0, a.hp - 2);
          log('Mãos Flamejantes causou 2 de dano ao aliado ' + a.name + '. (HP: ' + a.hp + ')');
          if(a.hp === 0){
            cleanupEquipsOf(foe, a);
            STATE[foe].grave.push(a);
            STATE[foe].allies[chosen.slot] = null;
            log('☠️ Destruído: ' + a.name + '.');
            // Efeito automático: Chamar Especial via campo effect (genérico)
            if (a.effect === 'chamar_cidadao') {
              const dono = foe;
              // Por padrão, chamar Cidadão da mão (compatível com lógica anterior)
              // Schedule to avoid nested render/state issues and exclude the destroyed card by name
              setTimeout(()=>{ specialSummonByConfig(dono, { origem:['hand'], kind:'ally', classe:'Cidadão', excludeName: a.name }, 'Chamar Especial'); }, 10);
            }
          }
        }
      }
      STATE[side].grave.push(c);
      STATE[side].hand.splice(index, 1);
      render();
      return;
    }
    // Modal exclusivo: divide minicards em "Seus" e "Oponente" (corrigido)
    let modal = document.getElementById('targetChoiceModal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'targetChoiceModal';
      modal.className = 'modal';
      modal.style.display = 'flex';
      modal.style.alignItems = 'center';
      modal.style.justifyContent = 'center';
      modal.style.zIndex = '120';
      modal.innerHTML = `
        <div class="modalBox" style="min-width:420px;max-width:600px;padding:28px 18px 18px 18px;display:flex;flex-direction:row;gap:32px;justify-content:center;">
          <div style="flex:1;display:flex;flex-direction:column;align-items:center;">
            <div style="font-size:16px;font-weight:bold;color:#2563eb;margin-bottom:8px;">Seus</div>
            <div id="targetChoiceYou" style="background:#e0f2fe;border-radius:10px;padding:12px;display:flex;flex-direction:column;gap:12px;"></div>
          </div>
          <div style="width:2px;background:#64748b;margin:0 8px;"></div>
          <div style="flex:1;display:flex;flex-direction:column;align-items:center;">
            <div style="font-size:16px;font-weight:bold;color:#dc2626;margin-bottom:8px;">Oponente</div>
            <div id="targetChoiceOppo" style="background:#fee2e2;border-radius:10px;padding:12px;display:flex;flex-direction:column;gap:12px;"></div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    } else {
      modal.style.display = 'flex';
    }
    // Render minicards (corrigido)
    const youDiv = document.getElementById('targetChoiceYou');
    const oppoDiv = document.getElementById('targetChoiceOppo');
    youDiv.innerHTML = '';
    oppoDiv.innerHTML = '';
    options.forEach((opt, idx) => {
      const cardBtn = document.createElement('div');
      cardBtn.className = 'cardChoiceMini';
      cardBtn.style.width = '70px';
      cardBtn.style.height = '98px';
      cardBtn.style.border = '2px solid #2b3b5c';
      cardBtn.style.borderRadius = '8px';
      cardBtn.style.background = (side === opt.obj.side) ? '#e0f2fe' : '#fee2e2';
      cardBtn.style.overflow = 'hidden';
      cardBtn.style.display = 'flex';
      cardBtn.style.alignItems = 'center';
      cardBtn.style.justifyContent = 'center';
      cardBtn.style.cursor = 'pointer';
      cardBtn.style.position = 'relative';
      cardBtn.onclick = () => {
        modal.style.display = 'none';
        const alvo = options[idx];
        if (alvo.type === 'leader') {
          STATE[foe].leader.hp = Math.max(0, STATE[foe].leader.hp - 2);
          log(`Mãos Flamejantes causou 2 de dano ao líder ${STATE[foe].leader.name}. (HP: ${STATE[foe].leader.hp})`);
    if (STATE[foe].leader.hp === 0) { showVictory((side==='you'?'Você':'IA'), side); }
        } else {
          const a = STATE[foe].allies[alvo.slot];
          if (a) {
            a.hp = Math.max(0, a.hp - 2);
            log(`Mãos Flamejantes causou 2 de dano ao aliado ${a.name}. (HP: ${a.hp})`);
            if (a.hp === 0) {
              cleanupEquipsOf(foe, a);
              STATE[foe].grave.push(a);
              STATE[foe].allies[alvo.slot] = null;
              log(`☠️ Destruído: ${a.name}.`);
              // Chamar Especial genérico ao ser destruído — respeita a config .chamarEspecial
              if (a.chamarEspecial) {
                const dono = foe;
                // Schedule summon to the next tick and pass excludeName to avoid self-selection
                setTimeout(()=>{ specialSummonByConfig(dono, { ...a.chamarEspecial, kind: a.chamarEspecial.kind||'ally', excludeName: a.name }, 'Chamar Especial'); }, 10);
              }
            }
          }
        }
        STATE[side].grave.push(c);
        STATE[side].hand.splice(index, 1);
        render();
      };
      const im = document.createElement('img');
      im.src = opt.obj.img || 'assets/ui/card-back.png';
      im.alt = opt.obj.name || '';
      im.style.width = '100%';
      im.style.height = '100%';
      im.style.objectFit = 'cover';
      cardBtn.appendChild(im);
      // Label
      const label = document.createElement('div');
      label.textContent = (side === opt.obj.side) ? 'Seu' : 'Oponente';
      label.style.position = 'absolute';
      label.style.bottom = '2px';
      label.style.bottom = '2px';
      label.style.left = '0';
      label.style.width = '100%';
      label.style.textAlign = 'center';
      label.style.background = (side === opt.obj.side) ? '#bae6fd' : '#fecaca';
      label.style.color = (side === opt.obj.side) ? '#2563eb' : '#dc2626';
      label.style.fontWeight = 'bold';
      label.style.fontSize = '13px';
      label.style.padding = '1px 0';
      label.style.borderRadius = '0 0 8px 8px';
      cardBtn.appendChild(label);
      if (side === opt.obj.side) youDiv.appendChild(cardBtn);
      else oppoDiv.appendChild(cardBtn);
    });
    return;
  }

  render();
}

// Ajusta o layout do modal de escolha visual
function showCardChoice(options, onChoose, title='Escolha uma carta') {
  // Build a renderer function and enqueue it so card-choice modals don't burst after fragment renewal
  const renderChoice = function(done){
    // Generic modal to show a list of option objects (each should have .img and .name or .card)
    let modal = document.getElementById('showCardChoiceModal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'showCardChoiceModal';
      modal.className = 'modal';
      modal.style.alignItems = 'center';
      modal.style.justifyContent = 'center';
      modal.style.zIndex = '300';
      document.body.appendChild(modal);
    }
    // Debug log: list option card names for diagnostics
    try { log(`showCardChoice: ${title} — options: ${options.map(o => (o.card&&o.card.name) || o.name || '').join(', ')}`); } catch(e){ console.warn('log error', e); }
    // build content
    const wrap = document.createElement('div');
    wrap.className = 'modalBox';
    wrap.style.padding = '18px';
    wrap.style.minWidth = '360px';
    wrap.style.maxWidth = '820px';
    wrap.style.display = 'flex';
    wrap.style.flexDirection = 'row';
    wrap.style.gap = '12px';

    const h = document.createElement('div');
    h.style.fontSize = '18px';
    h.style.fontWeight = 'bold';
    h.style.color = '#facc15';
    h.textContent = title;
    wrap.appendChild(h);

    const grid = document.createElement('div');
    grid.style.display = 'grid';
    grid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(90px, 1fr))';
    grid.style.gap = '10px';
    grid.style.flex = '1 1 360px';

    // Preview pane on the right for a larger preview of the hovered/selected option
    const previewPane = document.createElement('div');
    previewPane.style.width = '320px';
    previewPane.style.minWidth = '220px';
    previewPane.style.display = 'flex';
    previewPane.style.flexDirection = 'column';
    previewPane.style.alignItems = 'stretch';
    previewPane.style.gap = '8px';
    previewPane.style.paddingLeft = '8px';
    previewPane.style.borderLeft = '1px solid rgba(255,255,255,0.04)';
    previewPane.style.boxSizing = 'border-box';
    // preview contents
    const prevImg = document.createElement('img');
    prevImg.src = '';
    prevImg.style.width = '100%';
    prevImg.style.height = '360px';
    prevImg.style.objectFit = 'cover';
    prevImg.style.borderRadius = '8px';
    prevImg.style.boxShadow = '0 6px 18px rgba(0,0,0,0.6)';
    const prevTitle = document.createElement('div');
    prevTitle.style.fontSize = '16px'; prevTitle.style.fontWeight = '700'; prevTitle.style.color = '#f8fafc';
    const prevMeta = document.createElement('div'); prevMeta.style.fontSize = '13px'; prevMeta.style.color = '#cbd5e1'; prevMeta.style.whiteSpace = 'pre-wrap';
    previewPane.appendChild(prevImg); previewPane.appendChild(prevTitle); previewPane.appendChild(prevMeta);

    options.forEach((opt, i) => {
      const cardBtn = document.createElement('div');
      cardBtn.style.width = '90px';
      cardBtn.style.height = '120px';
      cardBtn.style.border = '1.5px solid #2b3b5c';
      cardBtn.style.borderRadius = '8px';
      cardBtn.style.background = '#101f36';
      cardBtn.style.overflow = 'hidden';
      cardBtn.style.display = 'flex';
      cardBtn.style.alignItems = 'center';
      cardBtn.style.justifyContent = 'center';
      cardBtn.style.cursor = 'pointer';
      cardBtn.style.position = 'relative';
      // If option marked as disabled, show it greyed out and prevent selection
      if (opt.disabled) {
        cardBtn.style.opacity = '0.5';
        cardBtn.style.cursor = 'default';
        // show a small overlay with reason if provided
        if (opt.disabledReason) {
          const ol = document.createElement('div');
          ol.style.position = 'absolute';
          ol.style.bottom = '4px';
          ol.style.left = '4px';
          ol.style.right = '4px';
          ol.style.fontSize = '11px';
          ol.style.color = '#ffeead';
          ol.style.background = 'rgba(0,0,0,0.45)';
          ol.style.padding = '4px 6px';
          ol.style.borderRadius = '6px';
          ol.style.textAlign = 'center';
          ol.textContent = opt.disabledReason;
          cardBtn.appendChild(ol);
        }
        // clicking disabled just flashes a small message
        cardBtn.onclick = () => {
          try { const prev = cardBtn.style.boxShadow; cardBtn.style.boxShadow = '0 0 0 4px rgba(255,255,255,0.06) inset'; setTimeout(()=>cardBtn.style.boxShadow = prev, 220); } catch(e){}
        };
      } else {
        cardBtn.onclick = () => {
          modal.style.display = 'none';
          try{ onChoose(opt, i); }catch(e){}
          done();
        };
      }
      const im = document.createElement('img');
      im.src = (opt.card ? opt.card.img : opt.img) || 'assets/ui/card-back.png';
      im.alt = (opt.card ? opt.card.name : opt.name) || '';
      im.style.width = '100%';
      im.style.height = '100%';
      im.style.objectFit = 'cover';
      // hover/focus to update preview pane
      cardBtn.onmouseenter = cardBtn.onfocus = () => {
        try {
          const c = opt.card || {};
          prevImg.src = c.img || opt.img || 'assets/ui/card-back.png';
          prevTitle.textContent = c.name || opt.name || '';
          let meta = '';
          if (c.classe) meta += `Classe: ${c.classe}\n`;
          if (c.tipo) meta += `Tipo: ${c.tipo}\n`;
          if (c.hp!=null) meta += `HP: ${c.hp}/${c.maxHp || c.hp}\n`;
          if (c.damage!=null) meta += `Dano: ${c.damage}\n`;
          if (c.text) meta += `\n${c.text}`;
          prevMeta.textContent = meta;
        } catch (e) { console.warn('preview update error', e); }
      };
      cardBtn.appendChild(im);
      grid.appendChild(cardBtn);
    });

    // Default preview: first option
    setTimeout(() => { try { const o0 = options[0]; if(o0){ prevImg.src = (o0.card?o0.card.img:o0.img) || 'assets/ui/card-back.png'; prevTitle.textContent = (o0.card?o0.card.name:o0.name)||''; prevMeta.textContent = ((o0.card&&o0.card.text)||''); } } catch(e){} }, 10);

    wrap.appendChild(grid);
    wrap.appendChild(previewPane);
    // Close/cancel button
    const footer = document.createElement('div');
    footer.style.display = 'flex';
    footer.style.justifyContent = 'center';
    footer.style.marginTop = '8px';
    const btnClose = document.createElement('button');
    btnClose.textContent = 'Fechar';
    btnClose.style.background = '#334155';
    btnClose.style.color = '#f8fafc';
    btnClose.style.border = 'none';
    btnClose.style.padding = '10px 18px';
    btnClose.style.borderRadius = '8px';
    btnClose.style.cursor = 'pointer';
    btnClose.onclick = () => { modal.style.display = 'none'; try { onChoose(null, null); } catch(e){}; done(); };
    footer.appendChild(btnClose);
    wrap.appendChild(footer);
    // set modal content and show
    modal.innerHTML = '';
    modal.appendChild(wrap);
    modal.style.display = 'flex';
  };

  if (window.enqueueModal) enqueueModal(renderChoice);
  else renderChoice(function(){});
}

// ============== Chamar Especial Genérico (mão, cemitério, banidas, deck) ==============
// Config shape:
// {
//   origem: ['hand','grave','ban','deck'], // pilhas permitidas
//   kind: 'ally',                          // opcional, padrão 'ally'
//   name, filiacao, cost, tipo, classe     // filtros opcionais (string match case-insensitivo; cost pode ser número ou {lte,gte})
// }
function matchesSpecialFilter(card, cfg){
  if(!card || !cfg) return false;
  const lc = s => (s||'').toString().toLowerCase();
  if(cfg.kind && lc(card.kind) !== lc(cfg.kind)) return false;
  if(cfg.name){ if(!lc(card.name).includes(lc(cfg.name))) return false; }
  if(cfg.filiacao){ if(!lc(card.filiacao).includes(lc(cfg.filiacao))) return false; }
  if(cfg.classe){ if(!lc(card.classe).includes(lc(cfg.classe))) return false; }
  if(cfg.tipo){ if(!lc(card.tipo).includes(lc(cfg.tipo))) return false; }
  // Backwards/alternate filters: support cost, maxCost and minCost
  if(cfg.cost!==undefined && cfg.cost!==null){
    const c = card.cost||0;
    if(typeof cfg.cost==='number'){ if(c !== cfg.cost) return false; }
    else if(typeof cfg.cost==='object'){
      if(cfg.cost.lte!==undefined && !(c<=cfg.cost.lte)) return false;
      if(cfg.cost.gte!==undefined && !(c>=cfg.cost.gte)) return false;
    }
  }
  // sugar: allow specifying maxCost / minCost directly on config
  if(cfg.maxCost!==undefined && cfg.maxCost!==null){
    const c = card.cost||0;
    if(!(c <= cfg.maxCost)) return false;
  }
  if(cfg.minCost!==undefined && cfg.minCost!==null){
    const c = card.cost||0;
    if(!(c >= cfg.minCost)) return false;
  }
  // Exclude a specific name if requested (prevent self-selection)
  if(cfg.excludeName && card && card.name && typeof card.name === 'string'){
    try{
      if(card.name.trim().toLowerCase() === (cfg.excludeName||'').toString().trim().toLowerCase()) return false;
    }catch(e){}
  }
  return true;
}

function collectSpecialCandidates(side, cfg){
  const origins = (cfg?.origem && Array.isArray(cfg.origem) ? cfg.origem : ['hand']).map(o=>o.toLowerCase());
  const out = [];
  origins.forEach(org => {
    let pile = null;
    if(org==='hand') pile = STATE[side].hand;
    else if(org==='grave') pile = STATE[side].grave;
    else if(org==='ban') pile = STATE[side].ban;
    else if(org==='deck') pile = STATE[side].deck;
    if(!Array.isArray(pile)) return;
    pile.forEach((card, idx) => {
      if(matchesSpecialFilter(card, {kind: cfg.kind||'ally', name: cfg.name, filiacao: cfg.filiacao, cost: cfg.cost, tipo: cfg.tipo, classe: cfg.classe, excludeName: cfg.excludeName})){
        out.push({ card, origin: org, idx });
      }
    });
  });
  return out;
}

function removeFromOrigin(side, origin, idx, card){
  const arr = origin==='hand'?STATE[side].hand: origin==='grave'?STATE[side].grave: origin==='ban'?STATE[side].ban: origin==='deck'?STATE[side].deck: null;
  if(!arr) return;
  // prefer index when valid, else remove by identity
  if(typeof idx==='number' && idx>=0 && idx<arr.length && arr[idx]===card){ arr.splice(idx,1); }
  else{
    const i = arr.indexOf(card); if(i!==-1) arr.splice(i,1);
  }
}

function originLabel(pt){
  if(pt==='hand') return 'mão';
  if(pt==='grave') return 'cemitério';
  if(pt==='ban') return 'banidas';
  if(pt==='deck') return 'deck';
  return pt;
}

function specialSummonByConfig(side, cfg, title='Chamar Especial'){
  try{
    try{ log(`${title}: chamado (side=${side}) cfg=${JSON.stringify(cfg)}`); }catch(e){}
    const candidates = collectSpecialCandidates(side, cfg);
    try{
      const names = candidates.map(c=> (c.card && c.card.name) ? `${c.card.name}(${c.origin})` : `${c.origin}`);
      log(`${title}: candidatos encontrados (${candidates.length}): ${names.join(', ')}`);
    }catch(e){}
    if(!candidates.length){
      try{
        const info = {
          cfg,
          piles: { hand: (STATE[side].hand||[]).length, grave: (STATE[side].grave||[]).length, deck: (STATE[side].deck||[]).length, ban: (STATE[side].ban||[]).length }
        };
        log(`${title}: nenhum alvo elegível encontrado nas pilhas especificadas. (info: ${JSON.stringify(info)})`);
      }catch(e){ log(`${title}: nenhum alvo elegível encontrado nas pilhas especificadas.`); }
      return false;
    }
    const placeAlly = (entry)=>{
      const pos = (STATE[side].allies||[]).findIndex(x=>!x);
      if(pos===-1){ log(`${title}: sem espaço no campo para invocar.`); return false; }
      // remove da origem e coloca no campo
      removeFromOrigin(side, entry.origin, entry.idx, entry.card);
      const summoned = {...entry.card};
      // Normalize HP: if the card came from grave/hand/ban it may have hp===0 there.
      // Ensure summoned copies enter with at least 1 HP or their maxHp so they don't immediately count as dead.
      try {
        if (typeof summoned.hp !== 'number' || summoned.hp <= 0) {
          if (typeof summoned.maxHp === 'number' && summoned.maxHp > 0) summoned.hp = summoned.maxHp;
          else summoned.hp = Math.max(1, summoned.hp || 1);
        }
      } catch (e) { console.warn('normalize summoned hp error', e); }
      // If the card is summoned from the grave, hand or ban (special summon by effect),
      // make it enter ready (not tapped) and allow it to act immediately.
      // If it's summoned from the deck, treat as a normal summon (can't act this turn).
      if (entry.origin === 'deck') {
        summoned.summonedThisTurn = true;
      } else {
        summoned.summonedThisTurn = false;
        summoned.tapped = false;
      }
      STATE[side].allies[pos] = summoned;
      // Defensive normalization: ensure the summoned card is upright and able to act
      try {
        STATE[side].allies[pos].tapped = false;
        STATE[side].allies[pos].summonedThisTurn = false;
        STATE[side].allies[pos]._specialSummoned = true; // debug flag
      } catch (e) { console.warn('normalizing summoned card error', e); }
  try { if (typeof verificarValbrakEngine === 'function') verificarValbrakEngine(side, summoned); } catch(e) {}
  log(`${title}: ${summoned.name} foi invocado da ${originLabel(entry.origin)} sem custo. (origin=${entry.origin} tapped=${STATE[side].allies[pos].tapped} summonedThisTurn=${STATE[side].allies[pos].summonedThisTurn} HP=${summoned.hp})`);
      render();

      // Disparar efeitos "ao entrar em campo" usando o módulo MYTRAGOR_EFFECTS
      try {
        if (typeof MYTRAGOR_EFFECTS !== 'undefined' && MYTRAGOR_EFFECTS.triggerOnEnter) {
          MYTRAGOR_EFFECTS.triggerOnEnter(summoned, side, pos);
        }
      } catch (e) { console.warn('on-enter (special) error', e); }

      return true;
    };

    // Decisão de IA vs Jogador deve considerar o DONO do efeito (side),
    // não o turno atual (STATE.active). Assim o jogador vê modal mesmo no turno da IA.
    if(side === 'ai'){
      // IA escolhe primeiro candidato
      return placeAlly(candidates[0]);
    }
    // Jogador: se só 1, invoca direto; se >1, modal
    if(candidates.length === 1){ return placeAlly(candidates[0]); }
    const opts = candidates.map(c => ({ card: c.card, origin: c.origin, idx: c.idx }));
    showCardChoice(opts, (chosen, i)=>{
      if(!chosen) return;
      placeAlly(candidates[i]);
    }, `${title}: escolha o alvo para invocar`);
    return true;
  }catch(e){ console.warn('specialSummonByConfig failed', e); return false; }
}

// Pesquisa no deck com filtros simples (name, filiacao, cost, classe, tipo)
// query: { name, filiacao, cost, classe, tipo }
function performSearchDeck(side, query, maxResults = 10, title = 'Buscar no deck', callback) {
  const deck = STATE[side].deck || [];
  const qName = (query.name || '').toString().toLowerCase();
  const qKind = (query.kind || '').toString().toLowerCase();
  const qF = (query.filiacao || '').toString().toLowerCase();
  const qClasse = (query.classe || '').toString().toLowerCase();
  const qTipo = (query.tipo || '').toString().toLowerCase();
  const qCost = query.cost;
  const matches = deck.filter(card => {
    if (!card) return false;
    if (qKind && (card.kind || '').toString().toLowerCase() !== qKind) return false;
    if (qName && !(card.name || '').toString().toLowerCase().includes(qName)) return false;
    if (qF && !(card.filiacao || '').toString().toLowerCase().includes(qF)) return false;
    if (qClasse && !(card.classe || '').toString().toLowerCase().includes(qClasse)) return false;
    if (qTipo && !(card.tipo || '').toString().toLowerCase().includes(qTipo)) return false;
    if (qCost !== undefined && qCost !== null) {
      if (typeof qCost === 'number') {
        if ((card.cost || 0) !== qCost) return false;
      } else if (typeof qCost === 'object') {
        if (qCost.lte !== undefined && !((card.cost || 0) <= qCost.lte)) return false;
        if (qCost.gte !== undefined && !((card.cost || 0) >= qCost.gte)) return false;
      }
    }
    // support excluding a specific name (prevent searching the source card itself)
    if (query && query.excludeName && card && card.name && typeof card.name === 'string'){
      try{
        if(card.name.trim().toLowerCase() === (query.excludeName||'').toString().trim().toLowerCase()) return false;
      }catch(e){}
    }
    return true;
  }).slice(0, maxResults);

  if (!matches.length) {
    // No results
    if (typeof callback === 'function') callback(null, -1);
    log('Busca no deck: nenhum resultado encontrado.');
    return;
  }

  if (side === 'ai') {
    // IA: pega a primeira correspondência
    const chosen = matches[0];
    const idx = STATE[side].deck.indexOf(chosen);
    if (idx !== -1) STATE[side].deck.splice(idx, 1);
    STATE[side].hand.push(chosen);
    log(`IA buscou ${chosen.name} no deck e a colocou na mão.`);
    if (typeof callback === 'function') callback(chosen, 0);
    render();
    return;
  }

  // Jogador: mostrar modal com as correspondências
  const opts = matches.map(m => ({ card: m }));
  showCardChoice(opts, (chosen, idx) => {
    if (chosen == null) {
      if (typeof callback === 'function') callback(null, -1);
      return;
    }
    const chosenCard = opts[idx].card;
    if (!chosenCard) { if (typeof callback === 'function') callback(null, -1); return; }
    // remove from deck (first occurrence)
    const di = STATE[side].deck.indexOf(chosenCard);
    if (di !== -1) STATE[side].deck.splice(di, 1);
    if (!STATE[side].hand) STATE[side].hand = [];
    STATE[side].hand.push(chosenCard);
    if (typeof callback === 'function') callback(chosenCard, idx);
  }, title);
}

/* ============== Toupeira: olhar topo ============== */
function habilitarOlharTopo(qtd, side){
  if (side === 'ai') {
    // IA decide automaticamente: se a carta do topo for de custo baixo, mantém no topo; senão, coloca no fundo
    const deck = STATE[side].deck;
    if (deck.length === 0) return;
    const topCard = deck[deck.length - 1];
    if ((topCard.cost || 0) <= 2) {
      log('IA: carta mantida no topo do deck.');
    } else {
      deck.unshift(deck.pop());
      log('IA: carta movida para o fundo do deck.');
    }
    renderSide(side);
    return;
  }
  const oldBtn = document.getElementById('btnOlharTopo');
  if(oldBtn) oldBtn.remove();
  const deckSlot = document.getElementById(`${side}-deck`);
  if(deckSlot){
    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.id = 'btnOlharTopo';
    btn.textContent = 'Olhar topo';
    btn.style.marginLeft = '8px';
    btn.onclick = () => olharTopoDeck(qtd, side);
    deckSlot.parentNode.insertBefore(btn, deckSlot.nextSibling);
  }
}
function olharTopoDeck(qtd, side) {
  const deck = STATE[side].deck;
  if (deck.length === 0) { alert('Deck vazio!'); return; }
  const topCard = deck[deck.length - 1];

  // Cria modal customizado
  let modal = document.getElementById('olharTopoModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'olharTopoModal';
    modal.className = 'modal';
    modal.style.display = 'flex';
    modal.style.alignItems = 'center';
    modal.style.justifyContent = 'center';
    modal.style.zIndex = '200';
    modal.innerHTML = `
      <div class="modalBox" style="padding: 32px 32px 24px 32px; min-width: 320px; min-height: 320px; display: flex; flex-direction: column; align-items: center;">
        <div id="olharTopoCardWrap" style="display: flex; flex-direction: column; align-items: center; justify-content: center; margin-bottom: 24px;"></div>
        <div style="display: flex; gap: 24px; justify-content: center;">
          <button id="btnTopo" style="background: #bae6fd; color: #1e293b; border: none; border-radius: 10px; font-size: 18px; font-weight: bold; padding: 14px 32px; box-shadow: 0 2px 8px #bae6fd88; cursor: pointer;">Topo</button>
          <button id="btnFundo" style="background: #fecaca; color: #7f1d1d; border: none; border-radius: 10px; font-size: 18px; font-weight: bold; padding: 14px 32px; box-shadow: 0 2px 8px #fecaca88; cursor: pointer;">Fundo</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  } else {
    modal.style.display = 'flex';
  }

  // Renderiza minicard central — usa a classe .cardChoiceCard para manter estilo consistente
  const wrap = document.getElementById('olharTopoCardWrap');
  wrap.innerHTML = '';
  const cardDiv = document.createElement('div');
  cardDiv.className = 'cardChoiceCard';
  // Garantir posicionamento para o label overlay
  cardDiv.style.position = 'relative';
  cardDiv.style.background = '#101f36';
  cardDiv.style.border = '2.5px solid #38bdf8';
  cardDiv.style.borderRadius = '12px';
  cardDiv.style.boxShadow = '0 0 18px 2px #bae6fd88';
  cardDiv.style.margin = '0 auto';

  const im = document.createElement('img');
  im.src = topCard.img || 'assets/ui/card-back.png';
  im.alt = topCard.name || '';
  im.style.width = '100%';
  im.style.height = '100%';
  im.style.objectFit = 'cover';
  im.style.display = 'block';
  im.style.borderRadius = '10px';
  cardDiv.appendChild(im);

  // Nome da carta (overlay, não afeta layout)
  const label = document.createElement('div');
  label.textContent = topCard.name || '';
  label.style.position = 'absolute';
  label.style.left = '8px';
  label.style.right = '8px';
  label.style.bottom = '8px';
  label.style.background = 'rgba(0,0,0,0.45)';
  label.style.color = '#e2e8f0';
  label.style.fontSize = '12px';
  label.style.padding = '6px 8px';
  label.style.borderRadius = '6px';
  label.style.textAlign = 'center';
  label.style.pointerEvents = 'none';
  cardDiv.appendChild(label);

  // Adiciona minicard ao modal
  wrap.appendChild(cardDiv);

  // Botões de ação
  document.getElementById('btnTopo').onclick = function () {
    modal.style.display = 'none';
    log('Toupeira: carta mantida no topo do deck.');
    const btn = document.getElementById('btnOlharTopo');
    if (btn) btn.remove();
    renderSide(side);
  };
  document.getElementById('btnFundo').onclick = function () {
    modal.style.display = 'none';
    deck.unshift(deck.pop());
    log('Toupeira: carta movida para o fundo do deck.');
    const btn = document.getElementById('btnOlharTopo');
    if (btn) btn.remove();
    renderSide(side);
  };
}

function verificarValbrakEngine(side, c) {
  if (
    STATE[side].leader &&
    (STATE[side].leader.name === 'Valbrak, Herói do Povo' || STATE[side].leader.name === 'Valbrak') &&
    c.classe === 'Cidadão' &&
    !valbrakComprouTurno[side]
  ) {
    draw(side);
    valbrakComprouTurno[side] = true;
    log('Valbrak: Você comprou uma carta por baixar um Cidadão.');
  }
}

/* ============== Ambientes: início do turno ============== */
function applyEnvEffectsOnTurnStart(side){
  // Treat environments as global: if an environment with a given effect exists on either side,
  // it affects both players according to their own leaders/characters. This allows, for
  // example, Catedral Ensolarada played by one side to grant protection to the opponent
  // if the opponent meets the leader requirement.
  const anySombra = (STATE.you.env?.effect === 'sombra_penalty') || (STATE.ai.env?.effect === 'sombra_penalty');
  const anyArcana = (STATE.you.env?.effect === 'arcana_draw') || (STATE.ai.env?.effect === 'arcana_draw');
  const anyMarcial = (STATE.you.env?.effect === 'marcial_bonus') || (STATE.ai.env?.effect === 'marcial_bonus');
  const anyRelig  = (STATE.you.env?.effect === 'religioso_protecao') || (STATE.ai.env?.effect === 'religioso_protecao');

  // Sombra penalty: applies if any environment with that effect exists
  if (anySombra) {
    if (STATE[side].leader?.filiacao !== 'Sombras') { STATE.pool[side] = Math.max(0, STATE.pool[side] - 1); log('🕳️ Caminho das Sombras: -1 ação neste turno.'); }
  }

  // Arcana draw: if any tempestade arcana is on the field, Arcana leaders draw
  if (anyArcana) {
    if (STATE[side].leader?.filiacao === 'Arcana') { log('⚡ Tempestade Arcana: compra 1 carta extra.'); draw(side); }
  }

  // Reset temporary atk/damage bonuses for BOTH sides to avoid accumulation, then apply marcial bonus globally
  ['you', 'ai'].forEach(s => {
    (STATE[s].allies || []).forEach(a => { if (!a) return; a.atkBonusTemp = 0; a.damageBonusTemp = 0; });
    if (STATE[s].leader) { STATE[s].leader.atkBonusTemp = 0; STATE[s].leader.damageBonusTemp = 0; }
  });

  if (anyMarcial) {
    // Apply +1 ATK to all Marcial characters on both sides
    ['you', 'ai'].forEach(s => {
      let marcialAffected = 0;
      (STATE[s].allies || []).forEach(a => {
        if (!a) return;
        if (a.filiacao === 'Marcial') { a.atkBonusTemp = (a.atkBonusTemp || 0) + 1; marcialAffected++; }
      });
      if (STATE[s].leader && STATE[s].leader.filiacao === 'Marcial') { STATE[s].leader.atkBonusTemp = (STATE[s].leader.atkBonusTemp || 0) + 1; }
      if (marcialAffected > 0) log(`🩸 Campos Ensanguentados: ${marcialAffected} aliado(s) Marcial(is) recebem +1 ATK neste lado.`);
    });
  }

  // Catedral Ensolarada protection: clear protection flags for the side whose turn started
  STATE[side].allies.forEach(a => { if (a) a.protegido = false; });
  // If any Catedral Ensolarada exists anywhere AND this side's leader is Religioso, allow protection
  if (anyRelig && STATE[side].leader?.filiacao === 'Religioso') {
    const allies = STATE[side].allies.map((a, i) => ({ a, i })).filter(x => x.a);
    if (allies.length > 0) {
      if (side === 'ai') {
        allies.sort((x, y) => (x.a.hp || 0) - (y.a.hp || 0));
        const pick = allies[0];
        STATE[side].allies[pick.i].protegido = true;
        log(`⛪ Catedral Ensolarada (IA): ${STATE[side].allies[pick.i].name} recebe -1 de dano até o próximo turno.`);
      } else {
        showCardChoice(
          allies.map(x => ({ card: x.a, label: 'Aliado', metaIndex: x.i })),
          (chosen, idx) => {
            if (chosen == null) { log('Catedral: seleção cancelada. Nenhum aliado protegido.'); return; }
            const sel = allies[idx]; if (!sel) return;
            STATE[side].allies[sel.i].protegido = true;
            log(`⛪ Catedral Ensolarada: ${STATE[side].allies[sel.i].name} recebe -1 de dano até o próximo turno.`);
            render();
          },
          'Escolha aliado para proteger (−1 dano)'
        );
      }
    }
    // Nota: não executar aqui efeitos que dependam de uma carta local 'c'.
  }
}

/* ============== Combate: Provocar (deitado), Bloquear (em pé e deita), Atropelar ============== */
let ATTACK_CTX = { attacker:null, side:null };
function isBattlePhase(){ return STATE.phase==='battle'; }
function firstTurnOf(side){ return STATE.turnCount[side]===1; }
function canAttackCard(side, card) {
  if (!isBattlePhase()) { console.log('Ainda não é fase de combate.'); return false; }
  if (firstTurnOf(side)) { console.log('No 1º turno não pode atacar.'); return false; }
  if (!card || card.hp <= 0) return false;
  // Efeito de Katsu: Guerreiros podem atacar inimigos deitados ou em pé
  const katsu = STATE[side].leader && STATE[side].leader.name === 'Katsu';
    if (katsu && card.classe === 'Guerreiro') {
    if (card.tapped) { console.log('Este atacante já está deitado.'); return false; }
    if (card.summonedThisTurn) { console.log('Aliados não atacam no turno em que entram.'); return false; }
    return true;
  }
  // Regra normal
  if (card.tapped) { console.log('Este atacante já está deitado.'); return false; }
  if (card.summonedThisTurn) { console.log('Aliados não atacam no turno em que entram.'); return false; }
  return true;
}
// Variante silenciosa usada para render/indicação visual (não registra logs)
function canAttackCardQuiet(side, card) {
  if (!isBattlePhase()) return false;
  if (firstTurnOf(side)) return false;
  if (!card || card.hp <= 0) return false;
  const katsu = STATE[side].leader && STATE[side].leader.name === 'Katsu';
  if (katsu && card.classe === 'Guerreiro') {
    if (card.tapped) return false;
    if (card.summonedThisTurn) return false;
    return true;
  }
  if (card.tapped) return false;
  if (card.summonedThisTurn) return false;
  return true;
}
function selectAttacker(side, idx){
  const card=STATE[side].allies[idx];
  if(!canAttackCard(side,card)) return;
  ATTACK_CTX={ attacker:{side,idx}, side };
  // Janela de resposta: Constrição (defensor pode responder ao declarar ataque)
  try { if (tryConstricaoResponse(side, card)) return; } catch(e){ console.warn('Constrição hook (ally) error', e); }
  console.log(`Selecionado atacante: ${card.name}. Agora escolha um alvo.`);
  highlightTargetsFor(side);
}
function selectLeaderAttacker(side){
  const card=STATE[side].leader;
  if(!card||card.tapped||card.hp<=0||!isBattlePhase()||firstTurnOf(side)){ console.log('Líder não pode atacar agora.'); return; }
  ATTACK_CTX={ attacker:{side, leader:true}, side };
  // Janela de resposta: Constrição (defensor pode responder ao declarar ataque do líder)
  try { if (tryConstricaoResponse(side, card, true)) return; } catch(e){ console.warn('Constrição hook (leader) error', e); }
  console.log(`Líder selecionado. Escolha um alvo.`);
  highlightTargetsFor(side);
}
function enemySide(side){ return side==='you'?'ai':'you'; }
function clearTargetHighlights(){ document.querySelectorAll('.slot.clickable').forEach(n=>{n.classList.remove('clickable');n.onclick=null;}); document.querySelectorAll('.slot.selected').forEach(n=>n.classList.remove('selected')); }
function markSlotClickable(id, fn){ const el=document.getElementById(id); if(!el) return; el.classList.add('clickable'); el.onclick=ev=>{ev.stopPropagation(); fn();}; }
function markSlotSelected(id){ const el=document.getElementById(id); el&&el.classList.add('selected'); }

function highlightTargetsFor(side) {
  const foe = enemySide(side);
  clearTargetHighlights();
  let any = false;
  const katsu = STATE[side].leader && STATE[side].leader.name === 'Katsu';
  // Se atacante é Guerreiro e Katsu está em campo, pode atacar qualquer inimigo, EXCETO se houver provocadores deitados
  if (ATTACK_CTX.attacker) {
    const attackerCard = ATTACK_CTX.attacker.leader ? STATE[side].leader : STATE[side].allies[ATTACK_CTX.attacker.idx];
  if (katsu && attackerCard.classe === 'Guerreiro') {
      const enemies = STATE[foe].allies.map((c,i)=>({c,i})).filter(x=>x.c && x.c.hp>0);
      const tauntersTapped = enemies.filter(x => x.c.tapped && hasKw(x.c,'provocar'));
      if (tauntersTapped.length) {
        // Se há provocadores deitados, só pode atacar eles
  tauntersTapped.forEach(t => { any=true; markSlotClickable(`${foe}-ally-${t.i}`, ()=>resolveAttackOn({type:'ally',side:foe,index:t.i})); });
  console.log('Provocar (deitado): escolha um dos provocadores deitados.');
        if(!any) log('Sem alvos válidos.');
        if (ATTACK_CTX.attacker?.leader) markSlotSelected(`${side}-leader`);
        else if (ATTACK_CTX.attacker) markSlotSelected(`${side}-ally-${ATTACK_CTX.attacker.idx}`);
        return;
      } else {
        // Se não há provocadores deitados, pode atacar qualquer inimigo
        STATE[foe].allies.forEach((c, i) => {
          if (c && c.hp > 0) {
            any = true;
            markSlotClickable(`${foe}-ally-${i}`, () => resolveAttackOn({ type: 'ally', side: foe, index: i }));
          }
        });
        if (STATE[foe].leader && STATE[foe].leader.hp > 0) {
          any = true;
          markSlotClickable(`${foe}-leader`, () => resolveAttackOn({ type: 'leader', side: foe }));
        }
        if (!any) console.log('Sem alvos válidos.');
        if (ATTACK_CTX.attacker?.leader) markSlotSelected(`${side}-leader`);
        else if (ATTACK_CTX.attacker) markSlotSelected(`${side}-ally-${ATTACK_CTX.attacker.idx}`);
        return;
      }
    }
  }
  const enemies = STATE[foe].allies.map((c,i)=>({c,i})).filter(x=>x.c && x.c.hp>0);
  const tauntersTapped = enemies.filter(x => x.c.tapped && hasKw(x.c,'provocar'));

  // Log dos alvos possíveis
  console.log('Alvos possíveis:');
  enemies.forEach(x => {
    console.log(`Slot ${x.i}: ${x.c.name} | tapped: ${!!x.c.tapped}`);
  });

  if (tauntersTapped.length){
    tauntersTapped.forEach(t => { any=true; markSlotClickable(`${foe}-ally-${t.i}`, ()=>resolveAttackOn({type:'ally',side:foe,index:t.i})); });
    console.log('Provocar (deitado): escolha um dos provocadores deitados.');
  } else {
    enemies.filter(x => x.c.tapped).forEach(x => {
      any=true;
      console.log(`Marcando como alvo: ${x.c.name} (slot ${x.i})`);
      markSlotClickable(`${foe}-ally-${x.i}`, ()=>resolveAttackOn({type:'ally',side:foe,index:x.i}));
    });
    if(STATE[foe].leader && STATE[foe].leader.hp>0){ any=true; markSlotClickable(`${foe}-leader`, ()=>resolveAttackOn({type:'leader',side:foe})); }
  }

  if(!any) console.log('Sem alvos válidos.');
  if(ATTACK_CTX.attacker?.leader) markSlotSelected(`${side}-leader`);
  else if(ATTACK_CTX.attacker)    markSlotSelected(`${side}-ally-${ATTACK_CTX.attacker.idx}`);
}
function getAC(target){ const s=target.side; return (target.type==='leader') ? (STATE[s].leader?.ac??13) : (STATE[s].allies[target.index]?.ac??12); }

// Reação: Constrição — ao declarar ataque, o defensor pode negar o ataque e o atacante não desvira no próximo início de turno do seu controlador.
// Retorna true se a reação foi usada e o fluxo de ataque deve ser interrompido.
function tryConstricaoResponse(attackerSide, attackerCard, isLeader=false){
  const defender = attackerSide === 'you' ? 'ai' : 'you';
  // Apenas permitir resposta do jogador humano por enquanto; IA pode usar de forma simplificada
  const defenderIsYou = (defender === 'you');
  const hand = STATE[defender]?.hand || [];
  const idxConstr = hand.findIndex(c => c && (c.name === 'Constrição' || ['freeser','constricao','aranhas_emboscada'].includes(c.effect)));
  if (idxConstr === -1) return false;

  // Se for a IA defendendo, use com probabilidade se tiver custo
    if (!defenderIsYou) {
    const card = hand[idxConstr];
    // Delegate reaction handling to effects module for embedded reactions (e.g. aranhas_emboscada)
    try {
      if (typeof MYTRAGOR_EFFECTS !== 'undefined' && MYTRAGOR_EFFECTS.triggerEffect) {
        const res = MYTRAGOR_EFFECTS.triggerEffect('aranhas_emboscada_reaction', card, attackerSide, attackerCard, defender);
        if (res && res.used) {
          // If the effect explicitly cancels the attack, stop; otherwise continue
          return !!res.cancelAttack;
        }
      }
    } catch (e) { console.warn('reaction module error', e); }
    // fallback: do nothing
    return false;
  }

  // Jogador humano: abrir modal de confirmação com custo
  const card = hand[idxConstr];
  const cost = card.cost || 0;
  // Criar modal simples se não existir
  let modal = document.getElementById('constricaoModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'constricaoModal';
    modal.className = 'modal';
    modal.style.zIndex = '151';
    document.body.appendChild(modal);
  }
  // Modal content varies depending on the card effect (Constrição cancels attack; Emboscada applies debuff)
  const titleText = card.name || 'Reação';
  let bodyText = '';
  if (card.effect === 'aranhas_emboscada') {
    bodyText = `Aplicar −3 de bônus de ataque ao atacante <b>${attackerCard?.name||'inimigo'}</b> agora? (Custo ${cost})<br><small>Se você controlar um aliado com "Aranhas Negras" no nome, comprará 1 carta.</small>`;
  } else {
    bodyText = `Negar o ataque de <b>${attackerCard?.name||'inimigo'}</b> agora? (Custo ${cost})<br><small>O atacante não desvira no próximo início de turno do controlador.</small>`;
  }
  const html = `
    <div class="modalBox" style="min-width:360px;max-width:460px;padding:24px 20px;display:flex;flex-direction:column;align-items:center;gap:10px;">
      <div style="display:flex;gap:12px;align-items:center;">
        <img src="${(card.img||'assets/trick/contricao.png')}" alt="${titleText}" style="width:70px;height:98px;border-radius:8px;box-shadow:0 2px 12px #0008;" onerror="this.src='assets/ui/card-back.png'">
        <div>
          <div style="font-size:18px;font-weight:700;color:#facc15;">${titleText}</div>
          <div style="font-size:14px;color:#e2e8f0;">${bodyText}</div>
        </div>
      </div>
      <div style="display:flex;gap:14px;margin-top:10px;">
        <button id="btnConstricaoNao" class="btn" style="background:#334155;color:#e2e8f0;">Não</button>
        <button id="btnConstricaoSim" class="btn" style="background:#facc15;color:#1f2937;">Lançar</button>
      </div>
    </div>`;
  modal.innerHTML = html;
  modal.style.display = 'flex';

  const btnNao = modal.querySelector('#btnConstricaoNao');
  const btnSim = modal.querySelector('#btnConstricaoSim');
  btnNao.onclick = () => { modal.style.display = 'none'; };
    btnSim.onclick = () => {
    // checar custo
    if ((STATE.pool[defender]||0) < cost) { alert('Sem fragmentos suficientes.'); return; }
    // Delegate effect application for emboscada to module; keep Constrição handled locally
    if (card.effect === 'aranhas_emboscada') {
      try {
        if (typeof MYTRAGOR_EFFECTS !== 'undefined' && MYTRAGOR_EFFECTS.triggerEffect) {
          MYTRAGOR_EFFECTS.triggerEffect('aranhas_emboscada_reaction', card, attackerSide, attackerCard, defender);
        }
      } catch (e) { console.warn('reaction module error', e); }
      modal.style.display = 'none';
      try { highlightTargetsFor(attackerSide); } catch(e){ console.warn('highlight after emboscada error', e); }
      render();
      return; // não cancela o ataque
    }
    // caso padrão: Constrição
    if ((STATE.pool[defender]||0) < cost) { alert('Sem fragmentos suficientes para Constrição.'); return; }
    STATE.pool[defender] -= cost;
    // mover carta para o cemitério
    STATE[defender].grave.push(card);
    STATE[defender].hand.splice(idxConstr, 1);
    applyConstricaoOn(attackerSide, attackerCard);
    log(`Você lançou Constrição e negou o ataque de ${attackerCard.name}.`);
    modal.style.display = 'none';
    endAttackCleanup();
    render();
  };
  return true; // pausa o fluxo de escolha de alvo até o jogador decidir
}

function applyConstricaoOn(attackerSide, attackerCard){
  try{
    if (!attackerCard) return;
    attackerCard.tapped = true; // fica deitado agora
    attackerCard._skipNextUntap = (attackerCard._skipNextUntap||0) + 1; // não desvira no próximo início de turno do controlador
    // opcional: marca visual? podemos reutilizar outline via equippedGlow já existente; omitido por simplicidade
  }catch(e){ console.warn('applyConstricaoOn error', e); }
}

function resolveAttackOn(target){
  const atk=ATTACK_CTX.attacker; if(!atk){ clearTargetHighlights(); return; }
  const side=atk.side, foe=enemySide(side);
  const attackerCard = atk.leader?STATE[side].leader:STATE[side].allies[atk.idx];
  const katsu = STATE[side].leader && STATE[side].leader.name === 'Katsu';
  // Permite atacar o líder inimigo (escolhido) em pé ou deitado por qualquer personagem
  if(target.type==='leader'){
    // Pode atacar normalmente
  } else if(attackerCard.classe === 'Guerreiro' && katsu) {
    // Guerreiros com Katsu podem atacar qualquer inimigo
  } else {
    // Regra normal: só pode atacar aliados deitados
    const t=STATE[foe].allies[target.index];
    if(!t || t.hp<=0){ log('Alvo inválido.'); endAttackCleanup(); return; }
    if(!t.tapped){ log('Só é possível atacar aliados deitados.'); endAttackCleanup(); return; }
  }

  // Reação síncrona para IA atacando: permitir que o jogador use Constrição via confirm, sem modal assíncrono
  try {
    if (side === 'ai') {
      const hand = STATE['you'].hand || [];
      const idxC = hand.findIndex(c => c && (c.name === 'Constrição' || ['freeser','constricao','aranhas_emboscada'].includes(c.effect)));
      if (idxC !== -1) {
        const constr = hand[idxC];
        const cost = constr.cost || 0;
        let canPay = (STATE.pool['you'] || 0) >= cost;
        // Confirm text depends on card effect
        const promptText = (constr.effect === 'aranhas_emboscada')
          ? `O oponente declarou um ataque com ${attackerCard?.name||'inimigo'}\nLançar ${constr.name} agora? (Custo ${cost}${canPay?'':' — insuficiente'})`
          : `O oponente declarou um ataque com ${attackerCard?.name||'inimigo'}\nLançar Constrição agora? (Custo ${cost}${canPay?'':' — insuficiente'})`;
        let ask = confirm(promptText);
        if (ask) {
          if (!canPay) {
            alert('Sem fragmentos suficientes.');
          } else {
            // If it's Emboscada, delegate to effects module which handles removal, cost and draw
            if (constr.effect === 'aranhas_emboscada') {
              try {
                if (typeof MYTRAGOR_EFFECTS !== 'undefined' && MYTRAGOR_EFFECTS.triggerEffect) {
                  MYTRAGOR_EFFECTS.triggerEffect('aranhas_emboscada_reaction', constr, side, attackerCard, 'you');
                }
              } catch (e) { console.warn('reaction module error', e); }
              // do not cancel the attack; continue
              render();
              return;
            }
            // default: Constrição behavior
            STATE.pool['you'] -= cost;
            STATE['you'].grave.push(constr);
            STATE['you'].hand.splice(idxC, 1);
            applyConstricaoOn(side, attackerCard);
            log(`Você lançou Constrição e negou o ataque de ${attackerCard.name}.`);
            endAttackCleanup();
            render();
            return; // cancela o ataque
          }
        }
      }
    }
  } catch(e){ console.warn('Constrição confirm path error', e); }

  // BLOQUEAR
  let finalTarget = target;
  if(target.type==='leader'){
    const blockers = STATE[foe].allies.map((c,i)=>({c,i})).filter(x=>x.c && !x.c.tapped && x.c.hp>0 && hasKw(x.c,'bloquear'));
    if(blockers.length){
      const defenderIsYou = (foe==='you');
      if(defenderIsYou && blockers.length > 1){
        let msg = 'Escolha um bloqueador para redirecionar o ataque ao seu Líder:\n';
        blockers.forEach((b,j)=>{msg+=`${j+1}: ${b.c.name} (HP ${b.c.hp})\n`;});
        let idx = parseInt(prompt(msg, '1'))-1;
        if(idx>=0 && idx<blockers.length){
          STATE[foe].allies[blockers[idx].i].tapped = true;
          finalTarget = {type:'ally', side:foe, index:blockers[idx].i};
          log(`🛡️ Bloquear: ataque redirecionado para ${blockers[idx].c.name}, que ficou deitado.`);
        }
      } else {
        let wants = defenderIsYou ? confirm(`Você tem BLOQUEAR (${blockers[0].c.name}). Deseja bloquear este ataque ao seu Líder?`) : (Math.random()<0.75);
        if(wants){
          STATE[foe].allies[blockers[0].i].tapped = true;
          finalTarget = {type:'ally', side:foe, index:blockers[0].i};
          log(`🛡️ Bloquear: ataque redirecionado para ${blockers[0].c.name}, que ficou deitado.`);
        }
      }
    }
  }

  // rolagem
  const bonusTempAtk = attackerCard.atkBonusTemp || 0;
  let d20 = 1 + Math.floor(Math.random() * 20);
  let d20b = null;
  if (hasKw(attackerCard, 'precisão') || hasKw(attackerCard, 'precisao')) {
    d20b = 1 + Math.floor(Math.random() * 20);
    d20 = Math.max(d20, d20b);
  }
  const total = d20 + (attackerCard.atkBonus || 0) + bonusTempAtk;
  const ac = getAC(finalTarget);
  if (d20b !== null) {
    const txt = `Rolagem precisão: ${d20} (maior de ${d20} e ${d20b}) + ${attackerCard.atkBonus||0}${bonusTempAtk ? "+"+bonusTempAtk+" (Campos Ensanguentados)" : ""} vs AC ${ac} → ${total>=ac?'ACERTOU':'ERROU'}.`;
    logAttackResult(total>=ac, txt);
  } else {
    const txt = `Rolagem ${d20}+${attackerCard.atkBonus||0}${bonusTempAtk ? "+"+bonusTempAtk+" (Campos Ensanguentados)" : ""} vs AC ${ac} → ${total>=ac?'ACERTOU':'ERROU'}.`;
    logAttackResult(total>=ac, txt);
  }
  attackerCard.tapped=true;

  if(total<ac){ endAttackCleanup(); render(); return; }

  const baseDmg=attackerCard.damage||1, damageBonusTemp=attackerCard.damageBonusTemp||0;
  if(finalTarget.type==='leader'){
    let dmg=baseDmg+damageBonusTemp;
    STATE[foe].leader.hp=Math.max(0,(STATE[foe].leader.hp||20)-dmg);
  logEffect(`💥 Dano ${dmg} no Escolhido (${STATE[foe].leader.hp}).`);
  if(STATE[foe].leader.hp===0){ showVictory((side==='you'?'Você':'IA'), side); }
  } else {
    const t=STATE[foe].allies[finalTarget.index];
    let dmg=baseDmg+damageBonusTemp;
    // Apply damage taken reduction from equips (numeric) first, otherwise fall back to boolean protegido (-1)
    if (t?.damageTakenReduction) {
      dmg = Math.max(0, dmg - (t.damageTakenReduction || 0));
    } else if (t?.protegido) {
      dmg = Math.max(0, dmg - 1);
    }
    const before=t.hp; t.hp=Math.max(0,t.hp-dmg);
  logEffect(`💥 Dano ${dmg} em ${t.name} (${t.hp}).`);

    // ATROPELAR
    if(hasKw(attackerCard,'atropelar') && t.hp===0){
      const over = dmg - before;
      if(over>0){
        STATE[foe].leader.hp=Math.max(0,(STATE[foe].leader.hp||20)-over);
  logEffect(`🐘 Atropelar: excesso ${over} no Líder! (${STATE[foe].leader.hp}).`);
  if(STATE[foe].leader.hp===0){ showVictory((side==='you'?'Você':'IA'), side); }
      }
    }
    if(t.hp===0){
      // LIMPA EQUIPAMENTOS DO ALVO ANTES DE SAIR DO CAMPO (NOVO)
      cleanupEquipsOf(foe, t);

      STATE[foe].grave.push(t);
  STATE[foe].allies[finalTarget.index]=null;
  // Notificar módulo de efeitos que um aliado foi enviado ao cemitério
  try{ if(typeof MYTRAGOR_EFFECTS!=='undefined' && MYTRAGOR_EFFECTS.notifyAllySentToGrave) MYTRAGOR_EFFECTS.notifyAllySentToGrave(t, foe); }catch(e){}
  logEffect(`☠️ Destruído: ${t.name}.`);

      // Gladiador Implacável: efeito buff_on_kill
      if(attackerCard && attackerCard.effect === 'buff_on_kill' && attackerCard.effectValue){
        const val = attackerCard.effectValue;
        if(val.atk){ attackerCard.atkBonus = (attackerCard.atkBonus||0) + val.atk; log(`${attackerCard.name} ganhou +${val.atk} ATK permanentemente.`); }
        if(val.ac){ attackerCard.ac = (attackerCard.ac||0) + val.ac; log(`${attackerCard.name} ganhou +${val.ac} AC permanentemente.`); }
      }

      // Efeito fragment_back ativado por matar uma unidade (se definido no atacante)
      if (attackerCard && attackerCard.effect === 'fragment_back') {
        const gain = attackerCard.effectValue || attackerCard.value || 0;
        const before = STATE.pool[side] || 0;
        STATE.pool[side] = Math.min(STATE.maxPool[side] || 999, before + gain);
        log(`${attackerCard.name}: recuperou ${STATE.pool[side]-before} fragmento(s) por matar ${t.name}.`);
      }

      // Chamar Especial genérico ao ser destruído
      if(t && t.chamarEspecial) {
        const dono = foe;
        // Defer special summon to avoid reentrancy and exclude the dead card by name
        setTimeout(()=>{ specialSummonByConfig(dono, { ...t.chamarEspecial, kind: t.chamarEspecial.kind||'ally', excludeName: t.name }, 'Chamar Especial'); }, 10);
      }

        // Sede de Vingança: se o atacante possui o efeito e ainda não usou, conceder compra e permitir atacar de novo
        try {
          if (attackerCard && attackerCard._sede_vinganca && !attackerCard._sede_vinganca.used) {
            // Marca como usado para evitar múltiplos gatilhos
            attackerCard._sede_vinganca.used = true;
            // Compra de carta
            draw(side);
            log('Sede de Vingança: você comprou 1 carta por derrotar um inimigo com o alvo marcado.');
            // Permitir atacar novamente (levantar)
            attackerCard.tapped = false;
            log(`${attackerCard.name} pode levantar e atacar novamente este turno.`);
          }
        } catch(e) { console.warn('sede_vinganca post-kill handler failed', e); }
    }
  }
  endAttackCleanup(); render();
}
function endAttackCleanup(){ ATTACK_CTX={attacker:null,side:null}; clearTargetHighlights(); }

/* ============== Pilhas ============== */
function showPile(side,which,title){
  const piles = [
    { key: 'deck', label: 'Deck' },
    { key: 'grave', label: 'Cemitério' },
    { key: 'ban', label: 'Banidas' }
  ];
  let current = which;
  function renderPile() {
    const list = STATE[side][current];
    $('#pileTitle').textContent = `${piles.find(p=>p.key===current).label} — ${side==='you'?'Você':'Oponente'}`;
    const G = $('#pileGrid'); G.innerHTML = '';
    if (!list.length) {
      G.innerHTML = '<div style="color:#e2e8f0;text-align:center;padding:24px 0;font-size:16px;">Nenhuma carta nesta pilha.</div>';
      return;
    }
    list.forEach(c => {
      const m = document.createElement('div');
      m.className = 'mini';
      m.style.display = 'flex';
      m.style.flexDirection = 'column';
      m.style.alignItems = 'center';
      m.style.justifyContent = 'center';
      m.style.padding = '6px';
      const im = document.createElement('img');
      im.src = (c.faceDown ? CARD_BACK : (c.img || CARD_BACK));
      im.onerror = () => im.src = FALLBACK_BACK;
      im.style.width = '60px';
      im.style.height = '84px';
      im.style.borderRadius = '6px';
      m.appendChild(im);
      const info = document.createElement('div');
      info.style.fontSize = '13px';
      info.style.color = '#e2e8f0';
      info.style.textAlign = 'center';
      info.style.marginTop = '4px';
      info.innerHTML = `<b>${c.name||'?'}</b><br><span style="color:#facc15">${c.kind||''}</span>`;
      m.appendChild(info);
      G.appendChild(m);
    });
  }
  // Navegação entre pilhas
  const nav = document.createElement('div');
  nav.style.display = 'flex';
  nav.style.justifyContent = 'center';
  nav.style.gap = '12px';
  nav.style.margin = '12px 0 8px 0';
  piles.forEach(pile => {
    const btn = document.createElement('button');
    btn.textContent = pile.label;
    btn.className = 'btn';
    btn.style.background = (pile.key === current) ? '#facc15' : '#334155';
    btn.style.color = (pile.key === current) ? '#7c2d12' : '#e2e8f0';
    btn.style.fontWeight = 'bold';
    btn.style.borderRadius = '8px';
    btn.style.padding = '6px 18px';
    btn.style.border = 'none';
    btn.style.cursor = 'pointer';
    btn.onclick = () => {
      current = pile.key;
      renderPile();
      Array.from(nav.children).forEach(b => {
        b.style.background = (b.textContent === pile.label) ? '#facc15' : '#334155';
        b.style.color = (b.textContent === pile.label) ? '#7c2d12' : '#e2e8f0';
      });
    };
    nav.appendChild(btn);
  });
  const modalBox = $('#pileModal .modalBox');
  if (modalBox) {
    // Remove navegação antiga se houver
    const oldNav = modalBox.querySelector('.pileNav');
    if (oldNav) modalBox.removeChild(oldNav);
    nav.className = 'pileNav';
    modalBox.insertBefore(nav, modalBox.children[1]);
  }
  renderPile();
  $('#pileModal').style.display = 'flex';
}
function hidePile(){ $('#pileModal').style.display='none'; }

// Mostra modal de vitória (nome: string; sideKey: 'you'|'ai' etc. opcional para mostrar imagem do líder)
function showVictory(name, sideKey){
  try{
    const modal = document.getElementById('victoryModal');
    const title = document.getElementById('victoryTitle');
    const img = document.getElementById('victoryImg');
    const text = document.getElementById('victoryText');
    title.textContent = `${name} venceu!`;
    // tentativa de pegar imagem do líder se sideKey fornecido
    if(sideKey && STATE && STATE[sideKey] && STATE[sideKey].leader && STATE[sideKey].leader.img){
      img.src = STATE[sideKey].leader.img;
    } else {
      img.src = 'assets/ui/card-back.png';
    }
    text.textContent = `Parabéns — ${name} venceu a partida.`;
    // botões
    document.getElementById('victoryBtnClose').onclick = () => { hideVictory(); };
    document.getElementById('victoryBtnReload').onclick = () => { try{ location.reload(); } catch(e){ window.location.href = window.location.href; } };
    modal.style.display = 'flex';
  }catch(e){ console.warn('showVictory error', e); alert(name + ' venceu!'); }
}
function hideVictory(){ const m = document.getElementById('victoryModal'); if(m) m.style.display='none'; }

// Ligações dos botões do topo
try {
  // Ligações dos slots de pilhas para abrir modal
  ['you','ai'].forEach(side => {
    const deckSlot = document.getElementById(`${side}-deck`);
    const graveSlot = document.getElementById(`${side}-grave`);
    const banSlot = document.getElementById(`${side}-ban`);
    if (deckSlot) deckSlot.onclick = () => showPile(side, 'deck', 'Deck');
    if (graveSlot) graveSlot.onclick = () => showPile(side, 'grave', 'Cemitério');
    if (banSlot) banSlot.onclick = () => showPile(side, 'ban', 'Banidas');
  });
  document.getElementById('btnCoin')?.addEventListener('click', coin);
  // startMatch now triggered via phase action button; remove direct Start button listener from log
  document.getElementById('btnChoose')?.addEventListener('click', chooseLeader);
  // btnChooseAI removed from UI — no listener attached
  // nextPhase/endTurn listeners removed from log controls (buttons were removed from UI)
  document.getElementById('btnRestart')?.addEventListener('click', () => { try { location.reload(); } catch(e) { window.location.href = window.location.href; } });
  // Voltar ao menu (index.html)
  try{ const _b = document.getElementById('btnBackMenu'); if(_b) _b.addEventListener('click', ()=>{ location.href = 'index.html'; }); }catch(e){}

  // Atalhos de teclado (quando não digitando em inputs)
  document.addEventListener('keydown', (ev) => {
    const tag = (ev.target && ev.target.tagName || '').toLowerCase();
    const isTyping = tag === 'input' || tag === 'textarea' || ev.isComposing;
    if (isTyping) return;
    const k = (ev.key || '').toLowerCase();
  if (k === 'n') { ev.preventDefault(); try{ nextPhase(); }catch{} }
  else if (k === 'e') { ev.preventDefault(); try{ endTurn(); }catch{} }
  else if (k === 's') { ev.preventDefault(); try{ startMatch(); }catch{} }
    else if (k === 'd') { ev.preventDefault(); try{ chooseLeader(); }catch{} }
  else if (k === 'a') { ev.preventDefault(); if(!__IS_MP){ try{ configureAIDeck(); }catch{} } }
    else if (k === 'r') { ev.preventDefault(); try { location.reload(); } catch { window.location.href = window.location.href; } }
  });
} catch(e) { console.warn('Falha ao vincular botões', e); }

// Wrap dispatcher to broadcast local actions in MP using Net.sendAction
function wrapDispatcherForMP(){
  // If we're not in MP mode, do nothing
  if (!IS_MP) return;
  // If a NetController exists it will install its own wrapper and handle sends.
  if (window.NetController) {
    console.log('MP: NetController present, skipping inline dispatcher wrapper');
    return;
  }
  // Wait for Dispatcher to be ready
  if (!window.Dispatcher || typeof window.Dispatcher.apply !== 'function') return setTimeout(wrapDispatcherForMP, 100);
  // Install inline wrapper (idempotent guard)
  if (window.__MP_INLINE_DISPATCHER_WRAPPED) return;
  window.__MP_INLINE_DISPATCHER_WRAPPED = true;
  const _apply = window.Dispatcher.apply;
  window.Dispatcher.apply = function(action, opts = {}) {
    const ret = _apply.call(window.Dispatcher, action, opts);
    try{
      if (!opts.remote && window.Net && typeof window.Net.sendAction === 'function') {
        window.Net.sendAction(action);
      }
    }catch(e){ console.warn('wrapDispatcherForMP send failed', e); }
    return ret;
  };
}
wrapDispatcherForMP();

// Stub simples da IA para evitar erros quando beginTurn() tentar chamar aiMain()
function aiMain(){
  // Helper: checar se a IA tem alvos válidos para esta carta
  function aiHasValidTargets(side, c){
    const foe = side==='you'?'ai':'you';
    try{
      if(!c) return false;
      // Truques: só reativos, não jogar proativamente
      if(c.kind === 'truque') return false;
      // Efeitos que exigem alvo
      if(c.kind === 'equip'){
        const hasSlot = (STATE[side].spells||[]).some(x=>!x);
        const hasTarget = !!STATE[side].leader || (STATE[side].allies||[]).some(a=>!!a);
        return hasSlot && hasTarget;
      }
      if(c.effect === 'destroy_equip'){
        // existe algum equipamento em campo?
        let any=false; ['you','ai'].forEach(s=>{ (STATE[s].spells||[]).forEach(card=>{ if(card && card.kind==='equip') any=true; }); });
        return any;
      }
      if(c.effect === 'dano_2_inimigo'){
        const anyAlly = (STATE[foe].allies||[]).some(a=>a && a.hp>0);
        const leaderOk = !!(STATE[foe].leader && STATE[foe].leader.hp>0);
        return anyAlly || leaderOk;
      }
      if(c.effect === 'amizade_floresta'){
        return (STATE[side].allies||[]).some(a=>a && a.tipo==='Animal');
      }
      if(c.effect === 'sede_vinganca'){
        if(STATE[side].leader && STATE[side].leader.classe==='Guerreiro') return true;
        return (STATE[side].allies||[]).some(a=>a && a.classe==='Guerreiro');
      }
      if(c.effect === 'search_deck') return true;
      if(c.effect === 'fragment_back') return true;
      if(c.effect === 'blood_sacrifice'){
        const anyEnemy = (STATE[foe].leader && STATE[foe].leader.hp>0) || (STATE[foe].allies||[]).some(a=>a && a.hp>0);
        return anyEnemy; // pagamento de HP já é tratado antes
      }
      // Aliados/ambientes normalmente não precisam de alvos
      return true;
    }catch(e){ console.warn('aiHasValidTargets error', e); return false; }
  }

    try {
    let progressed = true;
    while (progressed && STATE.phase === 'main' && STATE.active === 'ai') {
      // If a modal is open waiting for player input, pause AI loop
      if (window.__WAITING_FOR_MODAL) { progressed = false; break; }
      progressed = false;
      const hand = STATE.ai.hand || [];

      // Score cards to play in a priority order (prefer direct damage / removal / strong allies)
      const EFFECT_AI_MAP = {
        'dano_2_inimigo': { score: 900, type: 'damage' },
        'blood_sacrifice': { score: 900, type: 'damage' },
        'destroy_equip': { score: 700, type: 'removal' },
        'destroy_equip_on_enter': { score: 700, type: 'removal' },
        'on_grave_damage_leader': { score: 450, type: 'trigger_damage' },
        'search_deck': { score: 220, type: 'draw' },
        'olhar_topo': { score: 120, type: 'info' },
        'draw_bonus': { score: 200, type: 'draw' },
        'arcana_draw': { score: 160, type: 'draw' },
        'aura_hp': { score: 260, type: 'aura' },
        'buff_on_kill': { score: 260, type: 'buff' },
        'raio_gelo': { score: 300, type: 'disrupt' },
        'discard_enemy_hand': { score: 380, type: 'disrupt' },
        'sede_vinganca': { score: 320, type: 'tempo' },
        'dmg_bonus': { score: 180, type: 'buff' },
        'on_grave_damage_leader': { score: 450, type: 'trigger_damage' },
        'blood_sacrifice': { score: 700, type: 'cost_hp' },
        'ban_on_enter': { score: 420, type: 'removal' },
        'aranhas_mascote': { score: 240, type: 'token' },
        'aranhas_emboscada': { score: 260, type: 'trap' },
        'anular_magia_truque': { score: 480, type: 'counter' },
        'bem_treinado': { score: 200, type: 'resurrect' },
        'redoma_santa': { score: 320, type: 'protection' },
        'fragment_back': { score: 140, type: 'resource' },
        'search_deck': { score: 220, type: 'search' }
      };

      const scored = hand.map((c, idx) => ({ c, idx, score: 0 })).filter(x => x.c && x.c.kind !== 'truque');
      scored.forEach(s => {
        const c = s.c;
        const cost = c.cost || 0;
        if (cost > (STATE.pool.ai || 0) || !aiHasValidTargets('ai', c)) { s.score = -9999; return; }
        // Base type priorities
        if (c.kind === 'ally') s.score += 300 + ((c.damage||0) * 20) + ((c.hp||0) * 8);
        if (c.kind === 'equip') s.score += 240;
        if (c.kind === 'env') s.score += 200;
        if (c.kind === 'spell') s.score += 180;

        // Effect-based adjustments: support strings and choice objects
        const effNames = [];
        if (c.effect) effNames.push(c.effect);
        if (c.effectA && c.effectA.type) effNames.push(c.effectA.type);
        if (c.effectB && c.effectB.type) effNames.push(c.effectB.type);
        // also include specific effectValue keys if present
        if (c.effectValue && typeof c.effectValue === 'string') effNames.push(c.effectValue);

        effNames.forEach(name => {
          if (!name) return;
          const key = name.toString();
          if (EFFECT_AI_MAP[key]) s.score += EFFECT_AI_MAP[key].score;
          // small heuristics: spells that directly damage leader get a bonus proportional to damage
          if (key === 'dano_2_inimigo' && (c.effectValue||0) > 0) s.score += (c.effectValue||0) * 80;
        });

        // prefer lower cost if similar
        s.score += Math.max(0, 50 - (c.cost||0)*6);
      });

      scored.sort((a,b) => b.score - a.score);

      for (let entry of scored) {
        const i = entry.idx;
        const c = entry.c;
        if (!c || (c._aiSkipTurn === STATE.turnCount.ai)) continue;
        const cost = c.cost || 0;
        if (cost <= (STATE.pool.ai||0) && aiHasValidTargets('ai', c)) {
          const beforeLen = (STATE.ai.hand||[]).length;
          const ref = c;
          playFromHand('ai', i);
          // If hand changed, we made progress — restart scoring
          const handChanged = (STATE.ai.hand||[]).length !== beforeLen;
          if (handChanged || !(STATE.ai.hand||[]).includes(ref)) { progressed = true; break; }
          else { try{ ref._aiSkipTurn = STATE.turnCount.ai; }catch(e){} }
        }
      }
    }
  } catch(e){ console.warn('aiMain improved error', e); }
  // Avança fases rapidamente
  if(STATE.phase==='main') nextPhase();
  // Na fase de batalha, faça ataques simples pela IA antes de encerrar
  if(STATE.phase==='battle'){
    try {
      const side = 'ai';
      const foe = enemySide(side);
      // construir lista de atacantes válidos (aliados então líder)
      const attackers = [];
      (STATE[side].allies||[]).forEach((a,i)=>{ if(a && canAttackCard(side,a)) attackers.push({attacker:{side,idx:i}, card:a}); });
      if(STATE[side].leader && canAttackCard(side,STATE[side].leader)) attackers.unshift({attacker:{side, leader:true}, card:STATE[side].leader});

      // Evaluate targets for an attacker using simple heuristic scoring
      const attackScore = (att, targetObj, isLeader=false) => {
        try{
          const dmg = (att.damage||1) + (att.damageBonusTemp||0) + (att.damageBonus||0);
          const targHp = targetObj.hp || 0;
          let score = 0;
          if(isLeader){
            // prefer dealing damage to leader; lethal is best
            score += Math.min(dmg, targHp) * 6;
            if(targHp <= dmg) score += 500; // finish the leader
            // small bonus for whittling down leader
            score += Math.max(0, 20 - targHp);
            return score;
          }
          // Ally target: prefer killing enemy allies (especially high-value or low-hp)
          if(targHp <= dmg) score += 300; // kill
          else score += Math.min(dmg, targHp) * 3;
          // penalize risky trades where attacker likely dies
          const targetDmg = targetObj.damage || 0;
          const attackerHp = att.hp || 1;
          if(attackerHp <= targetDmg) score -= 80;
          // slightly prefer targets with disruptive effects (taunt/provoc, high damage)
          if((targetObj.key||'').toString().toLowerCase().includes('provoke') || (targetObj.key||'').toString().toLowerCase().includes('provocar')) score += 40;
          score += (targetObj.damage||0) * 6;
          return score;
        }catch(e){ return 0; }
      };

      const chooseTargetFor = (attackerCard) => {
        const katsu = STATE[side].leader && STATE[side].leader.name === 'Katsu';
        const candidates = [];
        // enemy allies
        (STATE[foe].allies||[]).forEach((c,i)=>{ if(c && c.hp>0) candidates.push({ type:'ally', side:foe, index:i, obj:c }); });
        // leader
        if(STATE[foe].leader && STATE[foe].leader.hp>0) candidates.push({ type:'leader', side:foe, obj: STATE[foe].leader });
        if(candidates.length===0) return null;
        // score every candidate
        let best = null; let bestScore = -1e9;
        for(const cand of candidates){
          // skip provoking rules only if Katsu allows free attack for warriors
          if(!katsu || attackerCard.classe === 'Guerreiro' || cand.type === 'leader'){
            const s = attackScore(attackerCard, cand.obj, cand.type==='leader');
            if(s > bestScore){ bestScore = s; best = cand; }
          }
        }
        // require minimum positive score to commit to attack
        if(bestScore <= 0) return null;
        return best.type === 'leader' ? { type:'leader', side:best.side } : { type:'ally', side:best.side, index:best.index };
      };

      for(let a of attackers){
        ATTACK_CTX = { attacker: a.attacker, side: a.attacker.side };
        const target = chooseTargetFor(a.card);
        if(target){
          resolveAttackOn(target);
        } else {
          // sem alvo válido para este atacante
          endAttackCleanup();
        }
      }
    } catch(err){ console.warn('aiMain attack error', err); }
    // terminar o turno após ataques
    endTurn();
    return;
  }
}

// Render inicial
try {
  // Em MP, esconder controles específicos da IA
  // btnChooseAI removed; previously hidden in MP mode
  render();
} catch(e) { console.warn('Render inicial falhou', e); }
</script>

<script>
// Melhora visual dos botões: dourado + brilho cíclico por clique
(function(){
  function enhanceButtons(){
    const btns = document.querySelectorAll('button');
    if(!btns || btns.length===0) return;
    btns.forEach(btn=>{
      // permitir opt-out adicionando a classe `no-gold`
      if(btn.classList.contains('no-gold')) return;
      // adicionar classe dourada base (preserva classes existentes como btn-start etc.)
      btn.classList.add('gold-btn');

      // ciclo local por botão (0..2)
      btn.dataset._goldGlowIdx = btn.dataset._goldGlowIdx || '-1';
      btn.addEventListener('click', function(e){
        const idx = (Number(btn.dataset._goldGlowIdx || -1) + 1) % 3;
        btn.dataset._goldGlowIdx = String(idx);
        // remover classes anteriores e forçar reflow para reiniciar animação
        btn.classList.remove('glow-0','glow-1','glow-2');
        void btn.offsetWidth;
        btn.classList.add('glow-' + idx);
      });

      // limpar classe de brilho quando a animação acabar para manter DOM limpo
      btn.addEventListener('animationend', function(ev){
        if(!ev || !ev.animationName) return;
        if(ev.animationName.indexOf('glow') === 0 || ev.animationName.indexOf('glow')>-1){
          btn.classList.remove('glow-0','glow-1','glow-2');
        }
      });
    });
  }

  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', enhanceButtons);
  else enhanceButtons();
})();
</script>

<script>
// Tour simples (zero-deps) — pt-BR steps. Opens only ao clicar em #btnTutorial.
(function(){
  const steps = [
    { el: null, title: 'O que é o jogo e como vencer', text: '<strong>Objetivo:</strong> reduzir o HP do líder adversário a 0. <br><br><strong>Regras básicas:</strong><br> - Turnos divididos em fases: Início, Principal, Combate e Final.<br> - Na Fase Principal você pode jogar cartas da mão pagando o custo; aliados vão para sua área de jogo.<br> - Na Fase de Combate você declara atacantes (aliados ou líder) e escolhe alvos; cartas com <em>Provocar</em> devem ser atacadas primeiro.<br> - Ao atacar, a carta vira (fica deitada) enquanto resolve o combate; cartas deitadas não podem atacar novamente até serem levantadas no próximo turno.<br> - Quando uma carta tem HP ≤ 0, ela vai para o cemitério. Truques ativam no turno do oponente; Ambiente aplica efeitos enquanto ativo.<br> - Algumas condições de derrota/vitória específicas dependem do modo (ex.: regras relacionadas a deck vazio).', },
    { el: '#phaseBar', title: 'Barra de Fases', text: 'Mostra as fases do turno: Início, Principal, Combate e Final. Use o botão de ação ao lado para avançar.' },
    { el: '#opArena', title: 'Arena do Oponente', text: 'Aqui ficam as cartas e fragmentos do oponente.' },
    { el: '#youArena', title: 'Sua Arena', text: 'Sua zona de jogo: aliados, magias e seu líder aparecem aqui.' },
    { el: '#phaseActionBtn', title: 'Botão de Ação', text: 'Este botão inicia a partida ou avança/encerra fases dependendo do estado.' },
    { el: '.logControls', title: 'Controles', text: 'Use estes botões para iniciar, avançar fases, encerrar turno ou reiniciar.' },
    { el: '#youHand', title: 'Suas cartas na mão', text: 'Cada carta mostra custo, classe e texto. Clique na carta para jogá-la. Passe o mouse para ver a prévia detalhada.',
      onShow: function(){
        try{
          // Always inject a demo "film" state for the tutorial (backup existing state first)
          if(window.STATE){
            window.__tour_sampleBackup = window.__tour_sampleBackup || {
              leader: JSON.parse(JSON.stringify(window.STATE.you?.leader || null)),
              hand: JSON.parse(JSON.stringify(window.STATE.you?.hand || [])),
              env: JSON.parse(JSON.stringify(window.STATE.you?.env || null))
            };

            // sample leader (Valbrak)
            const sampleLeader = { name: 'Valbrak', kind: 'leader', key: 'valbrak', img: 'assets/chosens/valbrak.png', hp: 16, classe: 'Arcana' };
            // sample cards: ally, spell, truque, ally, spell
            const sampleCards = [
              { name: 'Guerreiro Novato', kind: 'ally', img: 'assets/cards/sample_ally.png', cost: 2, classe: 'Marcial', hp: 3, damage: 1, keywords: [], text: 'Aliado básico: posiciona-se em campo.' },
              { name: 'Bola de Fogo', kind: 'spell', img: 'assets/cards/sample_spell.png', cost: 3, text: 'Cause 3 de dano a um alvo.' },
              { name: 'Armadilha de Vento', kind: 'truque', img: 'assets/cards/sample_trick.png', cost: 1, text: 'Truque: ativado apenas no turno do oponente. Ex.: interrompe uma jogada.', keywords: ['truque'] },
              { name: 'Sentinela', kind: 'ally', img: 'assets/cards/sample_ally2.png', cost: 1, classe: 'Arcana', hp: 2, damage: 1, text: 'Aliado rápido.' },
              { name: 'Proteção', kind: 'spell', img: 'assets/cards/sample_spell2.png', cost: 2, text: 'Concede +2 HP temporário a um aliado.' }
            ];

            // sample environment card
            const sampleEnv = { name: 'Floresta Encantada', kind: 'env', img: 'assets/cards/sample_env.png', text: 'Carta de Ambiente: enquanto ativa, altera regras de campo (ex.: +1 HP para aliados)', cost: 0 };

            // Inject demo state
            window.STATE.you = window.STATE.you || {};
            window.STATE.you._prevInjected = true;
            window.STATE.you.leader = sampleLeader;
            window.STATE.you.hand = sampleCards;
            window.STATE.you.env = sampleEnv;

            // re-render player's side to reflect sample cards
            try{ renderSide && typeof renderSide === 'function' && renderSide('you'); }catch(e){}
          }
        }catch(e){ console.warn('tour sample onShow error', e); }
        // simulate hover on first card to show preview if present
        try{ const hand = document.querySelector('#youHand'); if(hand && hand.firstElementChild){ const c = hand.firstElementChild; if(typeof c.onmouseenter === 'function') try{ c.onmouseenter({clientX: c.getBoundingClientRect().left+10, clientY: c.getBoundingClientRect().top+10}); }catch(e){} else c.dispatchEvent(new Event('mouseenter')); } }catch(e){}
      },
      onHide: function(){
        try{
          // restore previous state if we injected samples
          if(window.__tour_sampleBackup && window.STATE){
            try{ window.STATE.you.leader = window.__tour_sampleBackup.leader; window.STATE.you.hand = window.__tour_sampleBackup.hand || []; window.STATE.you.env = window.__tour_sampleBackup.env || null; }catch(e){}
            try{ renderSide && typeof renderSide === 'function' && renderSide('you'); }catch(e){}
            delete window.__tour_sampleBackup;
            if(window.STATE.you) delete window.STATE.you._prevInjected;
          }
          if(window.inspect) window.inspect(null);
        }catch(e){ console.warn('tour onHide restore error', e); }
      }
    },
    { el: '.inspector', title: 'Prévia da carta', text: 'A prévia mostra nome, atributos (HP/AC/Dano) e o texto da carta. Use-a para confirmar efeitos antes de jogar.' },
    { el: '#you-allies', title: 'Onde colocar aliados', text: 'Se for um aliado, clique na carta na sua mão e escolha um slot livre nesta área para posicioná-lo em campo.' },
  { el: '#you-env', title: 'Carta de Ambiente', text: 'A carta de Ambiente fica ao lado do líder e aplica efeitos globais enquanto estiver em jogo. Exemplos: buff em aliados ou penalidades ao oponente.' },
  { el: null, title: 'Fragmentos', text: '<strong>O que são:</strong> Fragmentos são a sua energia mágica e vital no mundo de Mytragor.<br><br><strong>Em jogo:</strong> As cartas possuem um custo mostrado por um número no canto superior esquerdo; esse número representa a quantidade de fragmentos que serão consumidos para convocar ou ativar a carta.<br><br><strong>Renovação e aumento:</strong> Os fragmentos se renovam a cada turno do jogador (ou seja, ao começar o seu turno você recupera fragmentos) e a quantidade máxima disponível sobe progressivamente de 2 em 2.<br><br><strong>Contagem inicial e evolução:</strong> O Jogador 1 começa com 1 fragmento e o Jogador 2 começa com 2 fragmentos. A cada novo ciclo os máximos sobem de 2 em 2: por exemplo, no segundo turno o Jogador 1 terá 3 fragmentos e o Jogador 2 terá 4; no terceiro turno P1 terá 5 e P2 terá 6, e assim por diante.<br><br><strong>Exemplo prático:</strong> Turno 1 → P1=1, P2=2; Turno 2 → P1=3, P2=4; Turno 3 → P1=5, P2=6.<br><br><strong>Dica:</strong> Planeje suas jogadas considerando o crescimento de fragmentos — cartas de custo alto tornam-se viáveis em turnos posteriores quando seu total de fragmentos aumenta.' }
  ];

  // Additional combat & zones steps appended dynamically
  steps.push(
    { el: '.phaseItem[data-phase="battle"]', title: 'Fase de Combate', text: 'Na Fase de Combate você declara atacantes e escolhe alvos. Clique no seu aliado ou líder para selecioná-lo como atacante e depois clique no alvo (aliado inimigo ou líder). Se um inimigo tiver "Provocar", ele deve ser priorizado como alvo. Ao resolver, atacante e alvo trocam dano; cartas com HP ≤ 0 vão para o cemitério. Alguns efeitos (ex.: bloquear/provocar) alteram as opções de alvo.' ,
      onShow: function(){
        try{
              // backup current battlefield state (safe with optional chaining)
              window.__tour_battleBackup = window.__tour_battleBackup || {
                you_allies: JSON.parse(JSON.stringify(window.STATE?.you?.allies || [])),
                ai_allies: JSON.parse(JSON.stringify(window.STATE?.ai?.allies || [])),
                you_deck: JSON.parse(JSON.stringify(window.STATE?.you?.deck || [])),
                ai_deck: JSON.parse(JSON.stringify(window.STATE?.ai?.deck || [])),
                you_grave: JSON.parse(JSON.stringify(window.STATE?.you?.grave || [])),
                ai_grave: JSON.parse(JSON.stringify(window.STATE?.ai?.grave || [])),
                you_ban: JSON.parse(JSON.stringify(window.STATE?.you?.ban || [])),
                ai_ban: JSON.parse(JSON.stringify(window.STATE?.ai?.ban || []))
              };

              // Ensure STATE structure exists before injecting
              window.STATE = window.STATE || {};
              window.STATE.you = window.STATE.you || {};
              window.STATE.ai = window.STATE.ai || {};

              // Inject simple battlefield examples (two allies each side, one with provoke)
          const allyA1 = { name: 'Guardião Antigo', kind:'ally', img:'assets/cards/sample_ally.png', cost:2, classe:'Arcana', hp:5, damage:2, keywords:['provocar'], text:'Provocar: força adversários a atacarem este.' };
          const allyA2 = { name: 'Vanguarda', kind:'ally', img:'assets/cards/sample_ally2.png', cost:1, classe:'Marcial', hp:3, damage:1, text:'Aliado de linha.' };
          const allyB1 = { name: 'Saqueador', kind:'ally', img:'assets/cards/sample_ally.png', cost:2, classe:'Sombras', hp:4, damage:2, text:'Ataca com força.' };
          const allyB2 = { name: 'Batedor', kind:'ally', img:'assets/cards/sample_ally2.png', cost:1, classe:'Arcana', hp:2, damage:1, text:'Rápido.' };

          window.STATE.you.allies = [allyA1, allyA2, null, null, null];
          window.STATE.ai.allies = [allyB1, allyB2, null, null, null];

          // set example deck/grave/ban arrays so counts show
          window.STATE.you.deck = (window.STATE.you.deck && window.STATE.you.deck.length>0) ? window.STATE.you.deck : new Array(18).fill({});
          window.STATE.ai.deck = (window.STATE.ai.deck && window.STATE.ai.deck.length>0) ? window.STATE.ai.deck : new Array(22).fill({});
          window.STATE.you.grave = (window.STATE.you.grave && window.STATE.you.grave.length>0) ? window.STATE.you.grave : [{ name:'Cadáver Antigo', img:'assets/cards/sample_ally.png' }];
          window.STATE.ai.grave = (window.STATE.ai.grave && window.STATE.ai.grave.length>0) ? window.STATE.ai.grave : [{ name:'Fragmento Quebrado', img:'assets/cards/sample_spell.png' }];
          window.STATE.you.ban = (window.STATE.you.ban && window.STATE.you.ban.length>0) ? window.STATE.you.ban : [{ name:'Banido', img:'assets/cards/sample_trick.png' }];
          window.STATE.ai.ban = (window.STATE.ai.ban && window.STATE.ai.ban.length>0) ? window.STATE.ai.ban : [];

          // render board to reflect injections
          try{ render && typeof render === 'function' ? render() : (renderSide && renderSide('you'), renderSide && renderSide('ai')); }catch(e){ console.warn('render error in tour battle onShow', e); }
          // after a short delay, run a visual attack demo (first ally attacks first enemy)
          try{ setTimeout(()=>{ simulateAttackDemo('#you-allies .card','#ai-allies .card',2); }, 700); }catch(e){}
        }catch(e){ console.warn('tour battle onShow error', e); }
      },
      onHide: function(){
        try{
          if(window.__tour_battleBackup && window.STATE){
            window.STATE.you.allies = window.__tour_battleBackup.you_allies || [];
            window.STATE.ai.allies = window.__tour_battleBackup.ai_allies || [];
            window.STATE.you.deck = window.__tour_battleBackup.you_deck || [];
            window.STATE.ai.deck = window.__tour_battleBackup.ai_deck || [];
            window.STATE.you.grave = window.__tour_battleBackup.you_grave || [];
            window.STATE.ai.grave = window.__tour_battleBackup.ai_grave || [];
            window.STATE.you.ban = window.__tour_battleBackup.you_ban || [];
            window.STATE.ai.ban = window.__tour_battleBackup.ai_ban || [];
            try{ render && typeof render === 'function' ? render() : (renderSide && renderSide('you'), renderSide && renderSide('ai')); }catch(e){}
            delete window.__tour_battleBackup;
          }
        }catch(e){ console.warn('tour battle onHide error', e); }
      }
    },
    { el: '#you-deck', title: 'Deck (Seu)', text: 'O Deck contém as cartas que você ainda não comprou. O número indicado mostra quantas cartas restam. Quando um jogador precisa comprar e o deck estiver vazio, regras de derrota podem ocorrer (dependendo do modo).'},
    { el: '#you-grave', title: 'Cemitério (Seu)', text: 'O Cemitério guarda cartas usadas ou destruídas. A maioria dos efeitos busca ou interage com o cemitério.' },
    { el: '#you-ban', title: 'Banidas (Seu)', text: 'Cartas banidas são removidas permanentemente do jogo, fora do deck e do cemitério.' },
    { el: '#ai-deck', title: 'Deck (Oponente)', text: 'Deck do oponente — funciona igual ao seu.' },
    { el: '#ai-grave', title: 'Cemitério (Oponente)', text: 'Cemitério do oponente — muitos efeitos podem interagir com este local.' },
    { el: '#ai-ban', title: 'Banidas (Oponente)', text: 'Cartas banidas do oponente: usadas para certas mecânicas e contadores.' }
  );

  // find demo step index (if any) for quick navigation
  const DEMO_IDX = (function(){ try{ return steps.findIndex(st=> st && st.title && String(st.title).toLowerCase().includes('demonstração')); }catch(e){ return -1; } })();

  // final glossary slide explaining common keywords
  steps.push({ el: null, title: 'Glossário rápido', text: '<strong>Precisão:</strong> ao declarar um ataque, role 2d20 e use o maior dos dois resultados; some esse valor com seu bônus de ataque para comparar com a defesa (AC) do alvo — o maior dos dois d20 é usado.<br><strong>Atropelar:</strong> quando um atacante causa dano que excede o HP do bloqueador, o excesso pode atingir o líder inimigo (depende das regras locais).<br><strong>Bloquear:</strong> um aliado pode interceptar um ataque dirigindo-se ao atacante, protegendo outro alvo; bloqueadores trocam dano com atacantes.<br><strong>Provocar:</strong> (taunt) habilidade que força os atacantes a escolherem esse alvo antes de outros alvos livres.<br><strong>Descartar:</strong> remover uma carta da mão para o cemitério, seja como custo ou como efeito de carta.<br><strong>Banir:</strong> remover uma carta permanentemente do jogo (zona de banidas); normalmente não pode ser retornada sem um efeito especial.' });

  // animated demo: inject a small playable-looking example and animate a short exchange
  steps.push({ el: null, title: 'Demonstração rápida (animada)', text: 'Veja uma pequena partida demonstrativa: aliados atacam, recebem dano e o líder também pode sofrer — tudo visual e não alterará seu jogo atual.<br><div style="margin-top:8px"><button id="tourDemoPlayInline" onclick="(window.__tour_startDemo && window.__tour_startDemo())" style="padding:8px 12px;border-radius:6px;background:linear-gradient(180deg,#facc15,#e6a600);border:none;cursor:pointer">▶ Reproduzir demonstração</button></div>',
    onShow: function(){
      try{
        // clear any previous demo timers
        try{ if(window.__tour_demoTimers && window.__tour_demoTimers.length){ window.__tour_demoTimers.forEach(id=>clearTimeout(id)); window.__tour_demoTimers = []; } }catch(e){}

        // backup relevant parts of STATE
        window.__tour_demoBackup = {
          you: JSON.parse(JSON.stringify(window.STATE?.you || {})),
          ai: JSON.parse(JSON.stringify(window.STATE?.ai || {})),
          turn: window.STATE?.turn || null,
          phase: window.STATE?.phase || null
        };

        // helper to clear demo timers
        window.__tour_demoTimers = [];

        function clearDemoTimers(){ try{ if(window.__tour_demoTimers){ window.__tour_demoTimers.forEach(id=>clearTimeout(id)); window.__tour_demoTimers = []; } }catch(e){} }

        // Build simple demo pieces
        const yLeader = { name: 'Valbrak', kind: 'leader', key: 'valbrak', img: 'assets/chosens/valbrak.png', hp: 14, ac: 13 };
        const aLeader = { name: 'Katsu', kind: 'leader', key: 'katsu', img: 'assets/chosens/katsu.png', hp: 12, ac: 13 };
        const yAlly = { name: 'Guerreiro Novato', kind: 'ally', img: 'assets/cards/sample_ally.png', cost:2, classe:'Marcial', hp:4, damage:2, text:'Aliado de demonstração' };
        const aAlly = { name: 'Saqueador', kind: 'ally', img: 'assets/cards/sample_ally2.png', cost:2, classe:'Sombras', hp:3, damage:1, text:'Inimigo agressivo' };

        // inject demo state (temporary)
        window.STATE = window.STATE || {};
        window.STATE.you = window.STATE.you || {};
        window.STATE.ai = window.STATE.ai || {};
        window.STATE.you.leader = JSON.parse(JSON.stringify(yLeader));
        window.STATE.ai.leader = JSON.parse(JSON.stringify(aLeader));
        window.STATE.you.allies = [JSON.parse(JSON.stringify(yAlly)), null, null, null, null];
        window.STATE.ai.allies = [JSON.parse(JSON.stringify(aAlly)), null, null, null, null];
        window.STATE.you.hand = [];
        window.STATE.ai.hand = [];
        window.STATE.you.deck = new Array(6).fill({});
        window.STATE.ai.deck = new Array(6).fill({});
        window.STATE.you.grave = [];
        window.STATE.ai.grave = [];
        // ensure UI shows demo
        try{ render && typeof render === 'function' ? render() : (renderSide && renderSide('you'), renderSide && renderSide('ai')); }catch(e){ console.warn('render error demo', e); }

        // define the animated sequence as a function so we can repeat it
        function startDemo(){
          clearDemoTimers();
          // 1) your ally attacks enemy ally
          const t1 = setTimeout(()=>{
            try{ simulateAttackDemo('#you-allies .card','#ai-allies .card',2); }catch(e){}
            const t1b = setTimeout(()=>{
              try{
                if(window.STATE && window.STATE.ai && window.STATE.ai.allies && window.STATE.ai.allies[0]){
                  window.STATE.ai.allies[0].hp = Math.max(0, (window.STATE.ai.allies[0].hp||0) - 2);
                  if(window.STATE.ai.allies[0].hp <= 0){ window.STATE.ai.grave = window.STATE.ai.grave || []; window.STATE.ai.grave.push(window.STATE.ai.allies[0]); window.STATE.ai.allies[0] = null; }
                  try{ renderSide && typeof renderSide === 'function' && (renderSide('ai'), renderSide('you')); }catch(e){}
                }
              }catch(e){}
            },700);
            window.__tour_demoTimers.push(t1b);
          },200);
          window.__tour_demoTimers.push(t1);

          // 2) AI ally counterattacks your leader
          const t2 = setTimeout(()=>{
            try{ simulateAttackDemo('#ai-allies .card','#you-leader',1); }catch(e){}
            const t2b = setTimeout(()=>{
              try{ if(window.STATE && window.STATE.you && window.STATE.you.leader){ window.STATE.you.leader.hp = Math.max(0, (window.STATE.you.leader.hp||0) - 1); try{ renderSide && typeof renderSide === 'function' && (renderSide('you'), renderSide('ai')); }catch(e){} } }catch(e){}
            },700);
            window.__tour_demoTimers.push(t2b);
          },1200);
          window.__tour_demoTimers.push(t2);

          // 3) Your leader attacks enemy leader
          const t3 = setTimeout(()=>{
            try{ simulateAttackDemo('#you-leader','#ai-leader',3); }catch(e){}
            const t3b = setTimeout(()=>{
              try{ if(window.STATE && window.STATE.ai && window.STATE.ai.leader){ window.STATE.ai.leader.hp = Math.max(0, (window.STATE.ai.leader.hp||0) - 3); try{ render && typeof render === 'function' ? render() : (renderSide && renderSide('you'), renderSide && renderSide('ai')); }catch(e){} if(window.STATE.ai.leader && window.STATE.ai.leader.hp===0){ try{ showVictory && showVictory('Você', 'you'); }catch(e){} } } }catch(e){}
            },700);
            window.__tour_demoTimers.push(t3b);
          },2600);
          window.__tour_demoTimers.push(t3);
        }

        // auto-start demo once the step appears
        try{ startDemo(); }catch(e){ console.warn('startDemo err', e); }

        // wire inline play button for manual replay
        try{
          const btn = document.getElementById('tourDemoPlayInline');
          if(btn){ btn.onclick = function(){ try{ startDemo(); }catch(e){ console.warn('inline play err', e); } } }
        }catch(e){}

      }catch(e){ console.warn('tour demo onShow error', e); }
    },
    onHide: function(){
      try{
        // clear timers
        try{ if(window.__tour_demoTimers){ window.__tour_demoTimers.forEach(id=>clearTimeout(id)); window.__tour_demoTimers = []; } }catch(e){}
        if(window.__tour_demoBackup && window.STATE){
          try{ window.STATE.you = window.__tour_demoBackup.you || window.STATE.you; window.STATE.ai = window.__tour_demoBackup.ai || window.STATE.ai; window.STATE.turn = window.__tour_demoBackup.turn; window.STATE.phase = window.__tour_demoBackup.phase; }catch(e){}
          try{ render && typeof render === 'function' ? render() : (renderSide && renderSide('you'), renderSide && renderSide('ai')); }catch(e){}
          delete window.__tour_demoBackup;
        }
      }catch(e){ console.warn('tour demo onHide error', e); }
    }
  });

  let idx = 0;
  let overlay, highlight, tooltip;

  function createOverlay(){
    overlay = document.createElement('div'); overlay.className = 'tour-overlay'; overlay.style.display='none'; document.body.appendChild(overlay);
    highlight = document.createElement('div'); highlight.className = 'tour-highlight'; overlay.appendChild(highlight);
    tooltip = document.createElement('div'); tooltip.className = 'tour-tooltip'; tooltip.innerHTML = '<div class="tour-body"></div><div class="tour-controls"><button id="tourPrev">◀ Anterior</button><button id="tourNext">Próximo ▶</button><button id="tourClose" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:#e6eef8;">Fechar</button></div>'; overlay.appendChild(tooltip);

    tooltip.querySelector('#tourPrev').addEventListener('click', ()=>showStep(idx-1));
    tooltip.querySelector('#tourNext').addEventListener('click', ()=>showStep(idx+1));
    tooltip.querySelector('#tourClose').addEventListener('click', hideTour);
    overlay.addEventListener('click', (e)=>{ if(e.target === overlay) hideTour(); });
  }

  function showTour(){ if(!overlay) createOverlay(); idx = 0; showStep(0); overlay.style.display='block'; document.body.style.overflow='hidden'; }
  function hideTour(){ if(overlay) overlay.style.display='none'; document.body.style.overflow=''; }

  let _prevOnHide = null;
  function showStep(i){
    if(i < 0) i = 0; if(i >= steps.length) { hideTour(); return; }
    // call previous step's onHide if any
    try{ if(typeof _prevOnHide === 'function') _prevOnHide(); }catch(e){}
    idx = i;
    const s = steps[idx];
    const el = document.querySelector(s.el);
    const body = tooltip.querySelector('.tour-body');
    body.innerHTML = `<h4>${s.title}</h4><div style="font-size:13px;color:#d9e6ff">${s.text}</div>`;

    // position highlight and tooltip near element
    if(el){
      const r = el.getBoundingClientRect();
      highlight.style.left = (r.left - 8) + 'px';
      highlight.style.top = (r.top - 8) + 'px';
      highlight.style.width = (r.width + 16) + 'px';
      highlight.style.height = (r.height + 16) + 'px';

      // prefer side placement for inspector/hand to keep tooltip next to preview
      const preferSide = (s.el && (s.el.indexOf('.inspector')>-1 || s.el.indexOf('youHand')>-1 || s.el.indexOf('#youHand')>-1));
      // reset any inline width so offsetWidth is measured correctly
      tooltip.style.width = '';
      // ensure browser computes sizes
      const ttW = tooltip.offsetWidth || 360;
      const spaceRight = window.innerWidth - r.right;
      const spaceLeft = r.left;
      let ttLeft, ttTop;
      if(preferSide && spaceRight > ttW + 32){
        // place to the right
        tooltip.style.width = Math.min(480, Math.max(320, ttW)) + 'px';
        ttLeft = r.right + 12;
        ttTop = r.top;
      } else if(preferSide && spaceLeft > ttW + 32){
        // place to the left
        tooltip.style.width = Math.min(480, Math.max(320, ttW)) + 'px';
        ttLeft = Math.max(12, r.left - (tooltip.offsetWidth || 360) - 12);
        ttTop = r.top;
      } else {
        // default: position above (or below if not enough space)
        const preferredLeft = Math.max(12, r.left + (r.width/2) - (tooltip.offsetWidth/2 || 180));
        ttLeft = preferredLeft;
        ttTop = r.top - 12 - tooltip.offsetHeight;
        if(ttTop < 12) ttTop = r.bottom + 12;
      }

      // clamp vertically to viewport
      if(ttTop + tooltip.offsetHeight > window.innerHeight - 12) ttTop = Math.max(12, window.innerHeight - tooltip.offsetHeight - 12);
      tooltip.style.left = ttLeft + 'px';
      tooltip.style.top = ttTop + 'px';
      tooltip.style.transform = '';
    } else {
      // center tooltip
      highlight.style.left = '-9999px'; highlight.style.top='-9999px';
      tooltip.style.left = '50%'; tooltip.style.top = '20%'; tooltip.style.transform = 'translateX(-50%)';
    }

    // run onShow for this step if provided
    try{ if(s.onShow) s.onShow(); }catch(e){ console.warn('tour onShow error', e); }
    _prevOnHide = (typeof s.onHide === 'function') ? s.onHide : null;

    // update control button text and handlers
    const prev = tooltip.querySelector('#tourPrev');
    const next = tooltip.querySelector('#tourNext');
    prev.disabled = (idx === 0);
    // default handlers
    prev.onclick = ()=> showStep(idx-1);
    next.onclick = ()=> showStep(idx+1);
    // If the current step is the glossary, offer to run the demo (if present)
    if(typeof s.title === 'string' && s.title.toLowerCase().includes('glossário') && typeof DEMO_IDX === 'number' && DEMO_IDX !== -1){
      next.textContent = 'Ver Demonstração ▶';
      next.onclick = ()=> showStep(DEMO_IDX);
    } else if(typeof s.title === 'string' && s.title.toLowerCase().includes('demonstração')){
      // On demo step: allow repeating the demo
      next.textContent = 'Repetir ▶';
      next.onclick = ()=> { try{ if(typeof s.onShow === 'function') s.onShow(); }catch(e){ console.warn('repeat demo err', e); } };
      // also change prev to go back normally
    } else {
      if(idx === steps.length -1) { next.textContent = 'Finalizar ▶'; next.onclick = hideTour; } else { next.textContent = 'Próximo ▶'; }
    }
  }

  // wire button
  document.addEventListener('DOMContentLoaded', ()=>{
    const tbtn = document.getElementById('btnTutorial');
    if(tbtn){ tbtn.addEventListener('click', (e)=>{ e.preventDefault(); showTour(); }); }
  });

  // expose for debugging and reuse from lesson/slideshow
  window.__tour = { show: showTour, hide: hideTour, steps: steps, showStep: showStep };
})();
</script>

<script>
// Global helper: start the demo step if present. This is a safe-entry point for inline onclick handlers.
window.__tour_startDemo = function(){ try{
  const t = window.__tour; if(!t || !t.steps) return; const demo = (t.steps || []).find(s=> s && s.title && String(s.title).toLowerCase().includes('demonstração')); if(demo && typeof demo.onShow === 'function') demo.onShow();
}catch(e){ try{ console.warn('__tour_startDemo error', e);}catch(_){} } };
</script>

<!-- Controllers / AI / Networking scaffold -->
<script src="game/dispatcher.js"></script>
<script src="ai/brain.js"></script>
<script src="controllers/HumanController.js"></script>
<script src="controllers/AIController.js"></script>
<script src="controllers/NetController.js"></script>
<script src="net/bootstrap.js"></script>
<script src="net/net.js"></script>
<script src="mp_intercept.js"></script>

</body>
</html>